<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BlueprintLLM — Live Pipeline Monitor</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Outfit:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
:root {
  --bg-deep: #0a0e17;
  --bg-panel: #111827;
  --bg-card: #1a2234;
  --bg-card-hover: #1f2a3f;
  --border: #2a3650;
  --border-bright: #3b4f6e;
  --text-primary: #e8edf5;
  --text-secondary: #8899b4;
  --text-dim: #556680;
  --accent-blue: #3b82f6;
  --accent-cyan: #06b6d4;
  --accent-emerald: #10b981;
  --accent-amber: #f59e0b;
  --accent-rose: #f43f5e;
  --accent-violet: #8b5cf6;
  --glow-blue: rgba(59, 130, 246, 0.15);
  --glow-emerald: rgba(16, 185, 129, 0.15);
  --glow-amber: rgba(245, 158, 11, 0.15);
  --glow-rose: rgba(244, 63, 94, 0.15);
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: var(--bg-deep); color: var(--text-primary);
  font-family: 'Outfit', sans-serif; min-height: 100vh; overflow-x: hidden;
}
body::before {
  content: ''; position: fixed; inset: 0;
  background-image: linear-gradient(rgba(59,130,246,0.03) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(59,130,246,0.03) 1px, transparent 1px);
  background-size: 60px 60px; pointer-events: none; z-index: 0;
}
body::after {
  content: ''; position: fixed; top: -200px; left: 50%; transform: translateX(-50%);
  width: 800px; height: 500px;
  background: radial-gradient(ellipse, rgba(59,130,246,0.08) 0%, transparent 70%);
  pointer-events: none; z-index: 0;
}
.dashboard { position: relative; z-index: 1; max-width: 1280px; margin: 0 auto; padding: 28px 36px; }

/* Header */
.header {
  display: flex; align-items: center; justify-content: space-between;
  margin-bottom: 28px; padding-bottom: 20px; border-bottom: 1px solid var(--border);
}
.header-left { display: flex; align-items: center; gap: 14px; }
.logo {
  width: 40px; height: 40px;
  background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
  border-radius: 10px; display: flex; align-items: center; justify-content: center;
  font-family: 'JetBrains Mono', monospace; font-weight: 700; font-size: 16px;
  color: white; box-shadow: 0 4px 20px rgba(59,130,246,0.3);
}
.header-title { font-size: 20px; font-weight: 700; letter-spacing: -0.5px; }
.header-title span { color: var(--text-dim); font-weight: 400; }
.header-right { display: flex; align-items: center; gap: 14px; }
.status-pill {
  display: flex; align-items: center; gap: 8px;
  padding: 5px 14px; border-radius: 20px;
  font-size: 13px; font-weight: 600; font-family: 'JetBrains Mono', monospace;
}
.status-pill.running { background: var(--glow-blue); color: var(--accent-blue); border: 1px solid rgba(59,130,246,0.25); }
.status-pill.idle { background: var(--glow-emerald); color: var(--accent-emerald); border: 1px solid rgba(16,185,129,0.2); }
.status-pill.disconnected { background: var(--glow-rose); color: var(--accent-rose); border: 1px solid rgba(244,63,94,0.2); }
.status-pill.retrying { background: var(--glow-amber); color: var(--accent-amber); border: 1px solid rgba(245,158,11,0.25); }
.status-pill.error { background: var(--glow-rose); color: var(--accent-rose); border: 1px solid rgba(244,63,94,0.25); }
.status-dot {
  width: 8px; height: 8px; border-radius: 50%;
}
.running .status-dot { background: var(--accent-blue); animation: pulse 2s ease-in-out infinite; }
.idle .status-dot { background: var(--accent-emerald); }
.disconnected .status-dot { background: var(--accent-rose); }
.retrying .status-dot { background: var(--accent-amber); animation: pulse 1.5s ease-in-out infinite; }
.error .status-dot { background: var(--accent-rose); animation: pulse 2s ease-in-out infinite; }
@keyframes pulse { 0%,100% { opacity:1; transform:scale(1); } 50% { opacity:0.5; transform:scale(0.85); } }
.run-badge {
  padding: 5px 10px; border-radius: 8px; background: var(--bg-card);
  border: 1px solid var(--border); font-family: 'JetBrains Mono', monospace;
  font-size: 11px; color: var(--text-dim);
}

/* Clock row */
.clock-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 14px; margin-bottom: 20px; }
.clock-card {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px;
  padding: 16px 20px; text-align: center;
}
.clock-label {
  font-size: 11px; font-weight: 500; text-transform: uppercase; letter-spacing: 1px;
  color: var(--text-dim); margin-bottom: 6px;
}
.clock-value {
  font-size: 28px; font-weight: 700; font-family: 'JetBrains Mono', monospace;
  letter-spacing: -1px; color: var(--text-primary);
}
.clock-value.accent-blue { color: var(--accent-blue); }
.clock-value.accent-amber { color: var(--accent-amber); }
.clock-value.accent-cyan { color: var(--accent-cyan); }

/* Current step */
.current-step-panel {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px;
  padding: 20px 24px; margin-bottom: 20px;
}
.step-header { display: flex; align-items: center; gap: 12px; margin-bottom: 14px; }
.step-id {
  font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 600;
  padding: 4px 10px; border-radius: 6px;
  background: var(--glow-blue); color: var(--accent-blue);
}
.step-desc { font-size: 16px; font-weight: 600; }
.step-pct {
  margin-left: auto; font-family: 'JetBrains Mono', monospace;
  font-size: 14px; font-weight: 600; color: var(--accent-blue);
}
.progress-track {
  height: 10px; background: var(--bg-deep); border-radius: 5px; overflow: hidden;
}
.progress-fill {
  height: 100%; border-radius: 5px; transition: width 0.6s ease;
  background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
  background-size: 30px 10px;
  animation: stripes 1s linear infinite;
}
@keyframes stripes {
  0% { background-position: 0 0; }
  100% { background-position: 30px 0; }
}
.progress-fill.striped {
  background-image: linear-gradient(
    45deg,
    rgba(255,255,255,0.1) 25%, transparent 25%,
    transparent 50%, rgba(255,255,255,0.1) 50%,
    rgba(255,255,255,0.1) 75%, transparent 75%
  );
  background-size: 30px 10px;
  animation: stripes 1s linear infinite;
}

/* Main grid */
.main-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
.panel {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px;
  padding: 20px;
}
.panel-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
.panel-title { font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
.panel-badge {
  font-size: 11px; font-family: 'JetBrains Mono', monospace;
  padding: 3px 10px; border-radius: 6px;
  background: var(--bg-deep); color: var(--text-dim); border: 1px solid var(--border);
}

/* Timeline */
.timeline { display: flex; flex-direction: column; gap: 0; }
.tl-item { display: flex; align-items: stretch; gap: 12px; }
.tl-rail { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
.tl-dot {
  width: 12px; height: 12px; border-radius: 50%; border: 2px solid var(--border);
  flex-shrink: 0; margin-top: 2px;
}
.tl-dot.complete { background: var(--accent-emerald); border-color: var(--accent-emerald); }
.tl-dot.active { background: var(--accent-blue); border-color: var(--accent-blue); box-shadow: 0 0 10px rgba(59,130,246,0.5); animation: pulse 2s ease-in-out infinite; }
.tl-dot.upcoming { background: transparent; border-color: var(--border); }
.tl-line { width: 2px; flex: 1; min-height: 8px; background: var(--border); }
.tl-line.done { background: var(--accent-emerald); }
.tl-content { flex: 1; padding: 0 0 14px; }
.tl-title { font-size: 13px; font-weight: 600; margin-bottom: 2px; }
.tl-title.dim { color: var(--text-dim); }
.tl-meta { font-size: 11px; color: var(--text-dim); font-family: 'JetBrains Mono', monospace; }

/* Metrics cards */
.metrics-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
.m-card {
  background: var(--bg-deep); border-radius: 10px; padding: 14px 16px;
  border: 1px solid var(--border);
}
.m-label {
  font-size: 10px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.8px;
  color: var(--text-dim); margin-bottom: 6px;
}
.m-value {
  font-size: 24px; font-weight: 700; font-family: 'JetBrains Mono', monospace;
  letter-spacing: -0.5px;
}
.m-value.blue { color: var(--accent-blue); }
.m-value.cyan { color: var(--accent-cyan); }
.m-value.amber { color: var(--accent-amber); }

/* Loss chart */
.chart-wrap { position: relative; height: 200px; }
.chart-wrap svg { width: 100%; height: 100%; }
svg text { font-family: 'JetBrains Mono', monospace; }
.chart-grid line { stroke: var(--border); stroke-dasharray: 4 4; stroke-width: 0.5; }
.chart-line { fill: none; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }

/* Error panel */
.error-panel {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px;
  padding: 0; margin-bottom: 20px; overflow: hidden;
}
.error-panel.has-errors { border-color: rgba(244, 63, 94, 0.3); }
.error-panel-header {
  display: flex; align-items: center; gap: 10px; padding: 14px 20px;
  cursor: pointer; user-select: none;
}
.error-panel-header:hover { background: var(--bg-card-hover); }
.error-icon { font-size: 16px; }
.error-panel-title { font-size: 14px; font-weight: 600; flex: 1; }
.error-count-badge {
  font-size: 11px; font-family: 'JetBrains Mono', monospace;
  padding: 2px 8px; border-radius: 10px;
  background: var(--glow-rose); color: var(--accent-rose);
  font-weight: 600;
}
.retry-badge {
  font-size: 11px; font-family: 'JetBrains Mono', monospace;
  padding: 2px 8px; border-radius: 10px;
  background: var(--glow-amber); color: var(--accent-amber);
  font-weight: 600;
}
.error-chevron {
  font-size: 12px; color: var(--text-dim); transition: transform 0.2s;
}
.error-panel.expanded .error-chevron { transform: rotate(90deg); }
.error-list { padding: 0 20px 14px; display: none; }
.error-panel.expanded .error-list { display: block; }
.error-entry {
  display: flex; align-items: flex-start; gap: 10px; padding: 8px 0;
  border-bottom: 1px solid var(--border); font-size: 12px;
}
.error-entry:last-child { border-bottom: none; }
.error-cat-tag {
  font-family: 'JetBrains Mono', monospace; font-size: 10px;
  padding: 2px 6px; border-radius: 4px; white-space: nowrap;
  background: var(--bg-deep); color: var(--accent-rose); border: 1px solid rgba(244,63,94,0.2);
}
.error-cat-tag.timeout { color: var(--accent-amber); border-color: rgba(245,158,11,0.2); }
.error-cat-tag.cuda_oom { color: var(--accent-violet); border-color: rgba(139,92,246,0.2); }
.error-cat-tag.network { color: var(--accent-cyan); border-color: rgba(6,182,212,0.2); }
.error-msg { color: var(--text-secondary); flex: 1; word-break: break-word; }
.error-step { color: var(--text-dim); white-space: nowrap; }

/* Idle overlay */
.idle-overlay {
  position: fixed; inset: 0; z-index: 10;
  background: rgba(10, 14, 23, 0.7); backdrop-filter: blur(4px);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
}
.idle-overlay .idle-title {
  font-size: 28px; font-weight: 700; color: var(--text-dim); margin-bottom: 12px;
}
.idle-overlay .idle-sub {
  font-size: 14px; color: var(--text-dim); font-family: 'JetBrains Mono', monospace;
}
.idle-overlay .idle-steps {
  margin-top: 24px; max-width: 400px; width: 100%;
}
.idle-step {
  display: flex; align-items: center; gap: 10px; padding: 6px 0;
  font-size: 13px; color: var(--text-dim); font-family: 'JetBrains Mono', monospace;
}
.idle-step .check { color: var(--accent-emerald); }
.hidden { display: none !important; }

@media (max-width: 900px) {
  .main-grid { grid-template-columns: 1fr; }
  .clock-row { grid-template-columns: 1fr; }
  .metrics-grid { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="dashboard">
  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <div class="logo">B</div>
      <div class="header-title">BlueprintLLM <span>Live Pipeline Monitor</span></div>
    </div>
    <div class="header-right">
      <div id="statusPill" class="status-pill idle">
        <div class="status-dot"></div>
        <span id="statusLabel">idle</span>
      </div>
      <div id="runBadge" class="run-badge">—</div>
    </div>
  </header>

  <!-- Clock row -->
  <div class="clock-row">
    <div class="clock-card">
      <div class="clock-label">Started</div>
      <div id="clockStarted" class="clock-value accent-blue">—</div>
    </div>
    <div class="clock-card">
      <div class="clock-label">Elapsed</div>
      <div id="clockElapsed" class="clock-value">—</div>
    </div>
    <div class="clock-card">
      <div class="clock-label">ETA Remaining</div>
      <div id="clockEta" class="clock-value accent-cyan">—</div>
    </div>
  </div>

  <!-- Current step -->
  <div id="currentStepPanel" class="current-step-panel">
    <div class="step-header">
      <div id="stepId" class="step-id">—</div>
      <div id="stepDesc" class="step-desc">Waiting for pipeline...</div>
      <div id="stepPct" class="step-pct"></div>
    </div>
    <div class="progress-track">
      <div id="progressFill" class="progress-fill striped" style="width:0%"></div>
    </div>
  </div>

  <!-- Error panel -->
  <div id="errorPanel" class="error-panel hidden">
    <div class="error-panel-header" onclick="toggleErrorPanel()">
      <span class="error-icon">&#9888;</span>
      <span class="error-panel-title">Errors &amp; Retries</span>
      <span id="retryBadge" class="retry-badge hidden"></span>
      <span id="errorCountBadge" class="error-count-badge hidden">0</span>
      <span class="error-chevron">&#9654;</span>
    </div>
    <div class="error-list" id="errorList"></div>
  </div>

  <!-- Main grid -->
  <div class="main-grid">
    <!-- Left: Timeline -->
    <div class="panel">
      <div class="panel-header">
        <div class="panel-title">Step Timeline</div>
        <div id="timelineBadge" class="panel-badge">0 steps</div>
      </div>
      <div id="timeline" class="timeline"></div>
    </div>

    <!-- Right: Training metrics -->
    <div id="metricsPanel" class="panel">
      <div class="panel-header">
        <div class="panel-title">Training Metrics</div>
        <div id="metricsBadge" class="panel-badge">step 4.x</div>
      </div>
      <div class="metrics-grid">
        <div class="m-card">
          <div class="m-label">Loss</div>
          <div id="mLoss" class="m-value blue">—</div>
        </div>
        <div class="m-card">
          <div class="m-label">Learning Rate</div>
          <div id="mLr" class="m-value cyan">—</div>
        </div>
      </div>
      <div class="chart-wrap">
        <svg id="lossChart" viewBox="0 0 500 180" preserveAspectRatio="none">
          <defs>
            <linearGradient id="lossGrad" x1="0" y1="0" x2="0" y2="1">
              <stop offset="0%" stop-color="var(--accent-blue)" stop-opacity="0.25"/>
              <stop offset="100%" stop-color="var(--accent-blue)" stop-opacity="0"/>
            </linearGradient>
          </defs>
          <g class="chart-grid" id="chartGrid"></g>
          <path id="lossArea" fill="url(#lossGrad)" d=""/>
          <path id="lossLine" class="chart-line" stroke="var(--accent-blue)" d=""/>
        </svg>
      </div>
    </div>
  </div>
</div>

<!-- Idle overlay -->
<div id="idleOverlay" class="idle-overlay hidden">
  <div class="idle-title">Pipeline Idle</div>
  <div id="idleSub" class="idle-sub">No pipeline is currently running</div>
  <div id="idleSteps" class="idle-steps"></div>
</div>

<script>
// ─── Configuration ───────────────────────────────────────────────────────
const POLL_INTERVAL = 3000;
const STATE_URL = '../logs/pipeline_live_state.json';

let lastRunId = null;
let tickTimer = null;
let cycleStartTime = null;  // Unix timestamp (seconds) — fixed for the entire run

// ─── Fetch State ─────────────────────────────────────────────────────────
async function fetchState() {
  try {
    const resp = await fetch(STATE_URL + '?t=' + Date.now(), { cache: 'no-store' });
    if (!resp.ok) throw new Error(resp.status);
    return await resp.json();
  } catch (e) {
    return null;
  }
}

// ─── Duration Formatting ─────────────────────────────────────────────────
function fmtDuration(secs) {
  if (secs == null || secs < 0) return '—';
  secs = Math.round(secs);
  if (secs < 60) return secs + 's';
  const m = Math.floor(secs / 60);
  const s = secs % 60;
  if (m < 60) return m + 'm ' + (s > 0 ? s + 's' : '');
  const h = Math.floor(m / 60);
  const rm = m % 60;
  return h + 'h ' + rm + 'm';
}

function fmtTime(unixTs) {
  if (!unixTs) return '—';
  const d = new Date(unixTs * 1000);
  return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
}

// ─── Render: Header ──────────────────────────────────────────────────────
function renderHeader(state) {
  const pill = document.getElementById('statusPill');
  const label = document.getElementById('statusLabel');
  const badge = document.getElementById('runBadge');

  if (!state) {
    pill.className = 'status-pill disconnected';
    label.textContent = 'disconnected';
    badge.textContent = '—';
    return;
  }

  const status = state.status || 'idle';
  let pillClass = 'idle';
  let labelText = status;

  if (status === 'running') {
    pillClass = 'running';
  } else if (status === 'retrying') {
    pillClass = 'retrying';
    const ri = state.retry_info;
    if (ri) {
      labelText = 'retry ' + ri.attempt + '/' + ri.max_retries;
    }
  } else if (status === 'error') {
    pillClass = 'error';
  } else {
    pillClass = 'idle';
  }

  pill.className = 'status-pill ' + pillClass;
  label.textContent = labelText;
  badge.textContent = state.run_id ? 'run ' + state.run_id : '—';
}

// ─── Render: Clocks ──────────────────────────────────────────────────────
function renderClocks(state) {
  const started = document.getElementById('clockStarted');
  const elapsed = document.getElementById('clockElapsed');
  const eta = document.getElementById('clockEta');

  const isActive = state && (state.status === 'running' || state.status === 'retrying' || state.status === 'error');
  if (!isActive) {
    // Show final values if we have them
    if (state && state.cycle_start_time) {
      started.textContent = fmtTime(state.cycle_start_time);
      elapsed.textContent = fmtDuration(state.elapsed_seconds);
    } else {
      started.textContent = '—';
      elapsed.textContent = '—';
    }
    eta.textContent = '—';
    cycleStartTime = null;
    stopElapsedTick();
    return;
  }

  started.textContent = fmtTime(state.cycle_start_time);
  eta.textContent = state.eta_remaining_seconds != null
    ? fmtDuration(state.eta_remaining_seconds)
    : '—';

  // Lock to cycle_start_time once — never reset mid-run
  cycleStartTime = state.cycle_start_time;
  startElapsedTick();
}

function startElapsedTick() {
  if (tickTimer) return;
  tickTimer = setInterval(() => {
    if (cycleStartTime) {
      const localElapsed = Date.now() / 1000 - cycleStartTime;
      document.getElementById('clockElapsed').textContent = fmtDuration(localElapsed);
    }
  }, 1000);
}

function stopElapsedTick() {
  if (tickTimer) { clearInterval(tickTimer); tickTimer = null; }
}

// ─── Render: Current Step ────────────────────────────────────────────────
function renderCurrentStep(state) {
  const panel = document.getElementById('currentStepPanel');
  const id = document.getElementById('stepId');
  const desc = document.getElementById('stepDesc');
  const pct = document.getElementById('stepPct');
  const fill = document.getElementById('progressFill');

  const isActive = state && (state.status === 'running' || state.status === 'retrying' || state.status === 'error');
  if (!isActive || !state.step_id) {
    id.textContent = '—';
    desc.textContent = 'Waiting for pipeline...';
    pct.textContent = '';
    fill.style.width = '0%';
    fill.classList.remove('striped');
    return;
  }

  id.textContent = 'STEP ' + state.step_id;
  desc.textContent = state.description || '';

  if (state.progress_current != null && state.progress_total) {
    const p = Math.round(100 * state.progress_current / state.progress_total);
    pct.textContent = p + '%';
    fill.style.width = p + '%';
    fill.classList.add('striped');
  } else {
    pct.textContent = '';
    // Indeterminate: show pulsing bar
    fill.style.width = '100%';
    fill.classList.add('striped');
  }
}

// ─── Render: Timeline (hierarchical) ─────────────────────────────────────
// Groups substeps (e.g. "1.3") under parent steps (e.g. "1") derived from
// step_plan. Active parent is expanded; completed parents are collapsed.

function getParentId(stepId) {
  if (!stepId) return null;
  const dot = stepId.indexOf('.');
  return dot > 0 ? stepId.substring(0, dot) : null;
}

function renderTimeline(state) {
  const container = document.getElementById('timeline');
  const badge = document.getElementById('timelineBadge');

  if (!state) { container.innerHTML = ''; badge.textContent = '0 steps'; return; }

  const plan = state.step_plan || [];
  const completed = state.completed_steps || [];
  const upcoming = state.upcoming_steps || [];
  const currentId = (state.status === 'running') ? state.step_id : null;
  const activeParent = currentId ? (getParentId(currentId) || currentId) : null;

  // Build sets for quick lookup
  const completedIds = new Set(completed.map(s => s.step));
  const upcomingIds = new Set(upcoming.map(s => s.step));
  const completedMap = {};
  completed.forEach(s => { completedMap[s.step] = s; });
  const upcomingMap = {};
  upcoming.forEach(s => { upcomingMap[s.step] = s; });

  // Identify parent steps (no dot) from plan
  const parents = plan.filter(s => !s.step.includes('.'));
  const completedParents = parents.filter(p =>
    completedIds.has(p.step) ||
    plan.filter(s => getParentId(s.step) === p.step).every(s => completedIds.has(s.step))
  );

  badge.textContent = completedParents.length + '/' + parents.length + ' phases';

  let html = '';

  parents.forEach((parent, pi) => {
    const children = plan.filter(s => getParentId(s.step) === parent.step);
    const allChildrenDone = children.length > 0 && children.every(c => completedIds.has(c.step));
    const parentDone = completedIds.has(parent.step) || allChildrenDone;
    const isActive = parent.step === activeParent;
    const isLast = (pi === parents.length - 1);

    // Compute total duration for collapsed parent
    let totalDur = 0;
    if (parentDone) {
      children.forEach(c => {
        if (completedMap[c.step]) totalDur += completedMap[c.step].duration || 0;
      });
      if (completedMap[parent.step]) totalDur += completedMap[parent.step].duration || 0;
    }

    if (parentDone && !isActive) {
      // Collapsed completed parent
      html += tlItem('complete', parent.name || parent.step,
        fmtDuration(totalDur), !isLast, true);
    } else if (isActive) {
      // Expanded active parent
      html += tlItem('active', parent.name || parent.step, 'in progress', true, false);
      // Show children
      children.forEach((child, ci) => {
        const childDone = completedIds.has(child.step);
        const childActive = child.step === currentId;
        const childIsLast = (ci === children.length - 1) && isLast;
        if (childDone) {
          const dur = completedMap[child.step] ? fmtDuration(completedMap[child.step].duration) : '';
          html += tlItem('complete', '  ' + (child.name || child.step), dur, !childIsLast, true);
        } else if (childActive) {
          let meta = 'in progress';
          if (state.progress_current != null && state.progress_total) {
            const p = Math.round(100 * state.progress_current / state.progress_total);
            meta = state.progress_current + '/' + state.progress_total + ' (' + p + '%)';
          }
          html += tlItem('active', '  ' + (child.name || child.step), meta, !childIsLast, false);
        } else {
          const eta = upcomingMap[child.step] && upcomingMap[child.step].eta_seconds != null
            ? 'ETA: ' + fmtDuration(upcomingMap[child.step].eta_seconds) : '';
          html += tlItem('upcoming', '  ' + (child.name || child.step), eta, !childIsLast, false);
        }
      });
    } else {
      // Upcoming parent
      const eta = upcomingMap[parent.step] && upcomingMap[parent.step].eta_seconds != null
        ? 'ETA: ' + fmtDuration(upcomingMap[parent.step].eta_seconds) : '';
      html += tlItem('upcoming', parent.name || parent.step, eta, !isLast, false);
    }
  });

  // Fallback if no plan: flat list (backwards compat)
  if (parents.length === 0) {
    completed.forEach((s, i) => {
      const isLast2 = (!currentId && i === completed.length - 1 && upcoming.length === 0);
      html += tlItem('complete', s.name || s.step, fmtDuration(s.duration), !isLast2, true);
    });
    if (currentId && state.status === 'running') {
      const desc = state.description || currentId;
      let meta = 'in progress';
      if (state.progress_current != null && state.progress_total) {
        const p = Math.round(100 * state.progress_current / state.progress_total);
        meta = state.progress_current + '/' + state.progress_total + ' (' + p + '%)';
      }
      html += tlItem('active', desc, meta, upcoming.length > 0, false);
    }
    upcoming.forEach((s, i) => {
      const isLast2 = (i === upcoming.length - 1);
      const meta = s.eta_seconds != null ? 'ETA: ' + fmtDuration(s.eta_seconds) : '';
      html += tlItem('upcoming', s.name || s.step, meta, !isLast2, false);
    });
  }

  container.innerHTML = html;
}

function tlItem(type, title, meta, showLine, isDone) {
  const dimClass = type === 'upcoming' ? ' dim' : '';
  const lineClass = isDone ? ' done' : '';
  return '<div class="tl-item">' +
    '<div class="tl-rail">' +
      '<div class="tl-dot ' + type + '"></div>' +
      (showLine ? '<div class="tl-line' + lineClass + '"></div>' : '') +
    '</div>' +
    '<div class="tl-content">' +
      '<div class="tl-title' + dimClass + '">' + esc(title) + '</div>' +
      (meta ? '<div class="tl-meta">' + esc(meta) + '</div>' : '') +
    '</div>' +
  '</div>';
}

// ─── Render: Training Metrics ────────────────────────────────────────────
function renderTrainingMetrics(state) {
  const panel = document.getElementById('metricsPanel');
  const lossEl = document.getElementById('mLoss');
  const lrEl = document.getElementById('mLr');
  const badgeEl = document.getElementById('metricsBadge');

  if (!state) { panel.classList.add('hidden'); return; }

  const metrics = state.latest_metrics || {};
  const lossHistory = state.loss_history || [];
  const isTraining = state.step_id && (state.step_id.startsWith('4.') || state.step_id.startsWith('3.'));
  const hasMetrics = Object.keys(metrics).length > 0 || lossHistory.length > 0;

  if (!hasMetrics && !isTraining) {
    panel.classList.add('hidden');
    return;
  }
  panel.classList.remove('hidden');

  if (metrics.loss != null) {
    lossEl.textContent = metrics.loss.toFixed(4);
  }
  if (metrics.learning_rate != null) {
    lrEl.textContent = metrics.learning_rate.toExponential(2);
  }

  badgeEl.textContent = lossHistory.length + ' data points';
  renderLossChart(lossHistory);
}

// ─── Render: Loss Chart ──────────────────────────────────────────────────
function renderLossChart(history) {
  const line = document.getElementById('lossLine');
  const area = document.getElementById('lossArea');
  const grid = document.getElementById('chartGrid');

  if (!history || history.length < 2) {
    line.setAttribute('d', '');
    area.setAttribute('d', '');
    grid.innerHTML = '';
    return;
  }

  const W = 500, H = 180;
  const pad = { l: 45, r: 10, t: 10, b: 25 };
  const cW = W - pad.l - pad.r;
  const cH = H - pad.t - pad.b;

  const steps = history.map(p => p.step);
  const losses = history.map(p => p.loss);
  const minStep = Math.min(...steps);
  const maxStep = Math.max(...steps);
  const maxLoss = Math.max(...losses) * 1.1 || 1;
  const stepRange = maxStep - minStep || 1;

  const x = s => pad.l + ((s - minStep) / stepRange) * cW;
  const y = l => pad.t + (1 - l / maxLoss) * cH;

  // Grid lines
  const gridLines = 4;
  let gridHtml = '';
  for (let i = 0; i <= gridLines; i++) {
    const yy = pad.t + (i / gridLines) * cH;
    const val = (maxLoss * (1 - i / gridLines)).toFixed(2);
    gridHtml += '<line x1="' + pad.l + '" y1="' + yy + '" x2="' + (W - pad.r) + '" y2="' + yy + '"/>';
    gridHtml += '<text x="' + (pad.l - 4) + '" y="' + (yy + 3) + '" text-anchor="end" fill="#556680" font-size="9">' + val + '</text>';
  }
  grid.innerHTML = gridHtml;

  // Path
  let d = '';
  history.forEach((p, i) => {
    const px = x(p.step);
    const py = y(p.loss);
    d += (i === 0 ? 'M' : 'L') + px.toFixed(1) + ',' + py.toFixed(1);
  });
  line.setAttribute('d', d);

  // Area fill
  const lastX = x(history[history.length - 1].step);
  const firstX = x(history[0].step);
  const bottom = pad.t + cH;
  area.setAttribute('d', d + ' L' + lastX.toFixed(1) + ',' + bottom + ' L' + firstX.toFixed(1) + ',' + bottom + ' Z');
}

// ─── Error Panel ─────────────────────────────────────────────────────────
function toggleErrorPanel() {
  const panel = document.getElementById('errorPanel');
  panel.classList.toggle('expanded');
}

function renderErrorPanel(state) {
  const panel = document.getElementById('errorPanel');
  const list = document.getElementById('errorList');
  const countBadge = document.getElementById('errorCountBadge');
  const retryBadge = document.getElementById('retryBadge');

  if (!state) { panel.classList.add('hidden'); return; }

  const errors = state.error_history || [];
  const retryInfo = state.retry_info;
  const hasContent = errors.length > 0 || retryInfo;

  if (!hasContent) {
    panel.classList.add('hidden');
    return;
  }

  panel.classList.remove('hidden');
  panel.classList.toggle('has-errors', errors.length > 0);

  // Error count badge
  if (errors.length > 0) {
    countBadge.classList.remove('hidden');
    countBadge.textContent = errors.length;
  } else {
    countBadge.classList.add('hidden');
  }

  // Retry badge
  if (retryInfo) {
    retryBadge.classList.remove('hidden');
    retryBadge.textContent = 'Retry ' + retryInfo.attempt + '/' + retryInfo.max_retries;
  } else {
    retryBadge.classList.add('hidden');
  }

  // Error list
  let html = '';
  errors.slice().reverse().forEach(function(err) {
    const catClass = (err.category === 'timeout') ? ' timeout'
      : (err.category === 'cuda_oom') ? ' cuda_oom'
      : (err.category === 'network') ? ' network' : '';
    html += '<div class="error-entry">' +
      '<span class="error-cat-tag' + catClass + '">' + esc(err.category || 'unknown') + '</span>' +
      '<span class="error-msg">' + esc(err.message || '') + '</span>' +
      '<span class="error-step">' + esc(err.step_id || '') + '</span>' +
    '</div>';
  });
  list.innerHTML = html;
}

// ─── Idle Overlay ────────────────────────────────────────────────────────
function renderIdleOverlay(state) {
  const overlay = document.getElementById('idleOverlay');
  const sub = document.getElementById('idleSub');
  const stepsDiv = document.getElementById('idleSteps');

  const isActive = state && (state.status === 'running' || state.status === 'retrying' || state.status === 'error');
  if (!state || isActive) {
    overlay.classList.add('hidden');
    return;
  }

  overlay.classList.remove('hidden');

  const completed = state.completed_steps || [];
  if (completed.length > 0) {
    sub.textContent = completed.length + ' steps completed in last run (' + state.run_id + ')';
    let html = '';
    completed.forEach(s => {
      html += '<div class="idle-step"><span class="check">&#10003;</span>' +
        esc(s.name || s.step) + ' <span style="color:var(--text-dim)">(' + fmtDuration(s.duration) + ')</span></div>';
    });
    stepsDiv.innerHTML = html;
  } else {
    sub.textContent = 'No pipeline is currently running';
    stepsDiv.innerHTML = '';
  }
}

function showDisconnected() {
  renderHeader(null);
  document.getElementById('idleOverlay').classList.remove('hidden');
  document.getElementById('idleSub').textContent = 'Cannot reach state file — is the server running?';
  document.getElementById('idleSteps').innerHTML = '';
}

// ─── Main Render ─────────────────────────────────────────────────────────
function render(state) {
  if (!state) { showDisconnected(); return; }
  renderHeader(state);
  renderClocks(state);
  renderCurrentStep(state);
  renderErrorPanel(state);
  renderTimeline(state);
  renderTrainingMetrics(state);
  renderIdleOverlay(state);
}

// ─── Utility ─────────────────────────────────────────────────────────────
function esc(s) {
  if (!s) return '';
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ─── Poll Loop ───────────────────────────────────────────────────────────
async function poll() {
  const state = await fetchState();
  render(state);
}

poll();
setInterval(poll, POLL_INTERVAL);
</script>
</body>
</html>
