{"instruction": "Create a Blueprint that prints Hello World when the game starts.", "output": "BLUEPRINT: BP_HelloWorld\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Hello World\"]\n\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_01:L01_01", "category": "print_hello"}
{"instruction": "make a bp that prints hello world on begin play.", "output": "BLUEPRINT: BP_HelloWorld\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Hello World\"]\n\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_01:L01_01", "category": "print_hello"}
{"instruction": "Create a Blueprint that calls PrintString with text Hello World on Event BeginPlay.", "output": "BLUEPRINT: BP_HelloWorld\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Hello World\"]\n\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_01:L01_01", "category": "print_hello"}
{"instruction": "Create a Blueprint for an actor that continuously rotates at 90 degrees per second on the Yaw axis.", "output": "BLUEPRINT: BP_RotatingActor\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: MakeRotator [X=0, Y=0, Z=90]\nNODE n3: MultiplyFloat\nNODE n4: AddActorLocalRotation\n\nEXEC n1.Then -> n4.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.ReturnValue -> n3.B [Rotator]\nDATA n3.ReturnValue -> n4.DeltaRotation [Rotator]", "source": "lesson:lesson_01:L01_02", "category": "rotating_actor"}
{"instruction": "bp for an actor that continuously rotates at 90 degrees per second on the yaw axis.", "output": "BLUEPRINT: BP_RotatingActor\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: MakeRotator [X=0, Y=0, Z=90]\nNODE n3: MultiplyFloat\nNODE n4: AddActorLocalRotation\n\nEXEC n1.Then -> n4.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.ReturnValue -> n3.B [Rotator]\nDATA n3.ReturnValue -> n4.DeltaRotation [Rotator]", "source": "lesson:lesson_01:L01_02", "category": "rotating_actor"}
{"instruction": "Create a Blueprint that prints Entered when another actor overlaps it and prints Exited when the overlap ends.", "output": "BLUEPRINT: BP_OverlapZone\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: PrintString [InString=\"Entered\"]\nNODE n3: Event_ActorEndOverlap\nNODE n4: PrintString [InString=\"Exited\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_03", "category": "overlap_event"}
{"instruction": "make a bp that prints entered when something overlaps it and prints exited when the overlap ends.", "output": "BLUEPRINT: BP_OverlapZone\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: PrintString [InString=\"Entered\"]\nNODE n3: Event_ActorEndOverlap\nNODE n4: PrintString [InString=\"Exited\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_03", "category": "overlap_event"}
{"instruction": "Create a Blueprint that calls PrintString with text Entered when another actor overlaps it and calls PrintString with text Exited when the overlap ends.", "output": "BLUEPRINT: BP_OverlapZone\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: PrintString [InString=\"Entered\"]\nNODE n3: Event_ActorEndOverlap\nNODE n4: PrintString [InString=\"Exited\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_03", "category": "overlap_event"}
{"instruction": "Create a Blueprint with a boolean variable IsActive. On BeginPlay, check if IsActive is true. If true, print Active. If false, print Inactive.", "output": "BLUEPRINT: BP_BranchExample\nPARENT: Actor\n\nVAR IsActive: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Branch\nNODE n3: PrintString [InString=\"Active\"]\nNODE n4: PrintString [InString=\"Inactive\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.True -> n3.Execute\nEXEC n2.False -> n4.Execute\n\nDATA n1.IsActive -> n2.Condition [Bool]", "source": "lesson:lesson_01:L01_04", "category": "branch"}
{"instruction": "bp with a bool var isactive. on beginplay, check if isactive is true. if true, print active. if false, print inactive.", "output": "BLUEPRINT: BP_BranchExample\nPARENT: Actor\n\nVAR IsActive: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Branch\nNODE n3: PrintString [InString=\"Active\"]\nNODE n4: PrintString [InString=\"Inactive\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.True -> n3.Execute\nEXEC n2.False -> n4.Execute\n\nDATA n1.IsActive -> n2.Condition [Bool]", "source": "lesson:lesson_01:L01_04", "category": "branch"}
{"instruction": "Create a Blueprint that waits 3 seconds after the game starts, then destroys itself.", "output": "BLUEPRINT: BP_TimedDestroy\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_05", "category": "delay"}
{"instruction": "make a bp that waits 3 seconds after the game starts, then destroys itself.", "output": "BLUEPRINT: BP_TimedDestroy\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_05", "category": "delay"}
{"instruction": "Create a Blueprint that uses a Delay node for 3 seconds after the game starts, then calls DestroyActor on self.", "output": "BLUEPRINT: BP_TimedDestroy\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_05", "category": "delay"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence node to first print Step 1, then print Step 2, then print Step 3.", "output": "BLUEPRINT: BP_SequenceExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: PrintString [InString=\"Step 2\"]\nNODE n5: PrintString [InString=\"Step 3\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n2.Then_2 -> n5.Execute", "source": "lesson:lesson_01:L01_06", "category": "sequence"}
{"instruction": "make a bp that on beginplay uses a sequence to first print step 1, then print step 2, then print step 3.", "output": "BLUEPRINT: BP_SequenceExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: PrintString [InString=\"Step 2\"]\nNODE n5: PrintString [InString=\"Step 3\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n2.Then_2 -> n5.Execute", "source": "lesson:lesson_01:L01_06", "category": "sequence"}
{"instruction": "Create a Blueprint that toggles an actor's visibility each time the player presses the Interact input action using a FlipFlop node.", "output": "BLUEPRINT: BP_ToggleVisibility\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetActorHiddenInGame [NewHidden=false]\nNODE n4: SetActorHiddenInGame [NewHidden=true]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_01:L01_07", "category": "flipflop"}
{"instruction": "make a bp that toggles an actor's visibility each time the player presses the interact input with flipflop.", "output": "BLUEPRINT: BP_ToggleVisibility\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetActorHiddenInGame [NewHidden=false]\nNODE n4: SetActorHiddenInGame [NewHidden=true]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_01:L01_07", "category": "flipflop"}
{"instruction": "Create a Blueprint that prints Welcome only the first time the player overlaps with the actor using a DoOnce node.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_08", "category": "doonce"}
{"instruction": "make a bp that prints welcome only the first time the player overlaps this actor with doonce.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_08", "category": "doonce"}
{"instruction": "Create a Blueprint that calls PrintString with text Welcome only the first time the player overlaps with the actor using a DoOnce node.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_08", "category": "doonce"}
{"instruction": "Create a Blueprint that on overlap, casts the other actor to a Character class. If the cast succeeds, print Player Found.", "output": "BLUEPRINT: BP_CastExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player Found\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]", "source": "lesson:lesson_01:L01_09", "category": "cast"}
{"instruction": "make a bp that on overlap, casts the other actor to a character class. if the cast succeeds, print player found.", "output": "BLUEPRINT: BP_CastExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player Found\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]", "source": "lesson:lesson_01:L01_09", "category": "cast"}
{"instruction": "Create a Blueprint with an array of Actors called TargetActors. On BeginPlay, loop through each actor in the array and destroy it.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\n\nVAR TargetActors: Array = None\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: ForEachLoop\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\n\nDATA n1.TargetActors -> n2.Array [Array]\nDATA n2.ArrayElement -> n3.Target [Actor]", "source": "lesson:lesson_01:L01_10", "category": "foreach"}
{"instruction": "bp with an array of actors called targetactors. on beginplay, loop through each actor in the array and destroy it.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\n\nVAR TargetActors: Array = None\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: ForEachLoop\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\n\nDATA n1.TargetActors -> n2.Array [Array]\nDATA n2.ArrayElement -> n3.Target [Actor]", "source": "lesson:lesson_01:L01_10", "category": "foreach"}
{"instruction": "Create a Blueprint with a Gate node. On BeginPlay, open the gate. On Tick, pass through the gate and print Ticking. On pressing the Close input action, close the gate.", "output": "BLUEPRINT: BP_GateExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: Event_Tick\nNODE n4: PrintString [InString=\"Ticking\"]\nNODE n5: Event_InputAction [ActionName=\"Close\"]\n\nEXEC n1.Then -> n2.Open\nEXEC n3.Then -> n2.Enter\nEXEC n2.Exit -> n4.Execute\nEXEC n5.Pressed -> n2.Close", "source": "lesson:lesson_01:L01_11", "category": "gate"}
{"instruction": "bp with a gate. on beginplay, open the gate. on tick, pass through the gate and print ticking. on pressing the close input, close the gate.", "output": "BLUEPRINT: BP_GateExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: Event_Tick\nNODE n4: PrintString [InString=\"Ticking\"]\nNODE n5: Event_InputAction [ActionName=\"Close\"]\n\nEXEC n1.Then -> n2.Open\nEXEC n3.Then -> n2.Enter\nEXEC n2.Exit -> n4.Execute\nEXEC n5.Pressed -> n2.Close", "source": "lesson:lesson_01:L01_11", "category": "gate"}
{"instruction": "Create a Blueprint with a custom event called OnActivate. On BeginPlay, call the custom event. The custom event prints Activated when called.", "output": "BLUEPRINT: BP_CustomEventExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=\"OnActivate\"]\nNODE n3: Event_CustomEvent [EventName=\"OnActivate\"]\nNODE n4: PrintString [InString=\"Activated\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_12", "category": "custom_event"}
{"instruction": "bp with a custom event called onactivate. on beginplay, call the custom event. the custom event prints activated when called.", "output": "BLUEPRINT: BP_CustomEventExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=\"OnActivate\"]\nNODE n3: Event_CustomEvent [EventName=\"OnActivate\"]\nNODE n4: PrintString [InString=\"Activated\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_12", "category": "custom_event"}
{"instruction": "Create a Blueprint with a custom event called OnActivate. On BeginPlay, call the custom event. The custom event calls PrintString with text Activated when called.", "output": "BLUEPRINT: BP_CustomEventExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=\"OnActivate\"]\nNODE n3: Event_CustomEvent [EventName=\"OnActivate\"]\nNODE n4: PrintString [InString=\"Activated\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_12", "category": "custom_event"}
{"instruction": "Create a Blueprint with an integer variable Score starting at 0. On overlap, add 10 to the score and print the new score.", "output": "BLUEPRINT: BP_ScoreCounter\nPARENT: Actor\n\nVAR Score: Int = 0\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetVariable [VarName=\"Score\"]\nNODE n3: AddInt\nNODE n4: SetVariable [VarName=\"Score\"]\nNODE n5: PrintString\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nDATA n4.Value -> n5.InString [String]", "source": "lesson:lesson_01:L01_13", "category": "variable_set_get"}
{"instruction": "bp with an int var score starting at 0. on overlap, add 10 to the score and print the new score.", "output": "BLUEPRINT: BP_ScoreCounter\nPARENT: Actor\n\nVAR Score: Int = 0\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetVariable [VarName=\"Score\"]\nNODE n3: AddInt\nNODE n4: SetVariable [VarName=\"Score\"]\nNODE n5: PrintString\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nDATA n4.Value -> n5.InString [String]", "source": "lesson:lesson_01:L01_13", "category": "variable_set_get"}
{"instruction": "Create a Blueprint that spawns a projectile actor at the player's location when the Fire input action is pressed.", "output": "BLUEPRINT: BP_ProjectileSpawner\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: GetActorRotation\nNODE n4: SpawnActor [ActorClass=\"BP_Projectile\"]\n\nEXEC n1.Pressed -> n4.Execute\n\nDATA n2.ReturnValue -> n4.SpawnLocation [Vector]\nDATA n3.ReturnValue -> n4.SpawnRotation [Rotator]", "source": "lesson:lesson_01:L01_14", "category": "spawn_actor"}
{"instruction": "make a bp that spawns a projectile actor at the player's location when the fire input is pressed.", "output": "BLUEPRINT: BP_ProjectileSpawner\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: GetActorRotation\nNODE n4: SpawnActor [ActorClass=\"BP_Projectile\"]\n\nEXEC n1.Pressed -> n4.Execute\n\nDATA n2.ReturnValue -> n4.SpawnLocation [Vector]\nDATA n3.ReturnValue -> n4.SpawnRotation [Rotator]", "source": "lesson:lesson_01:L01_14", "category": "spawn_actor"}
{"instruction": "Create a Blueprint that plays a sound effect when the actor is overlapped by another actor.", "output": "BLUEPRINT: BP_SoundOnOverlap\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetActorLocation\nNODE n3: PlaySound [Sound=\"OverlapSound\"]\n\nEXEC n1.Then -> n3.Execute\n\nDATA n2.ReturnValue -> n3.Location [Vector]", "source": "lesson:lesson_01:L01_15", "category": "play_sound"}
{"instruction": "make a bp that plays a sound effect when the actor is overlapped by another actor.", "output": "BLUEPRINT: BP_SoundOnOverlap\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetActorLocation\nNODE n3: PlaySound [Sound=\"OverlapSound\"]\n\nEXEC n1.Then -> n3.Execute\n\nDATA n2.ReturnValue -> n3.Location [Vector]", "source": "lesson:lesson_01:L01_15", "category": "play_sound"}
{"instruction": "Create a Blueprint that on Tick, gets the distance to another actor stored in a variable called TargetActor. If the distance is less than 500, print Close.", "output": "BLUEPRINT: BP_DistanceChecker\nPARENT: Actor\n\nVAR TargetActor: Actor = None\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetDistanceTo\nNODE n3: LessThanFloat\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Close\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\n\nDATA n1.TargetActor -> n2.OtherActor [Actor]\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "source": "lesson:lesson_01:L01_16", "category": "distance_check"}
{"instruction": "make a bp that on tick, gets the distance to another actor stored in a variable called targetactor. if the distance is less than 500, print close.", "output": "BLUEPRINT: BP_DistanceChecker\nPARENT: Actor\n\nVAR TargetActor: Actor = None\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetDistanceTo\nNODE n3: LessThanFloat\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Close\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\n\nDATA n1.TargetActor -> n2.OtherActor [Actor]\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "source": "lesson:lesson_01:L01_16", "category": "distance_check"}
{"instruction": "Create a Blueprint that prints Started on BeginPlay, prints Tick Count each frame using Event Tick, and prints Goodbye before the actor is destroyed using Event EndPlay.", "output": "BLUEPRINT: BP_LifecycleEvents\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_Tick\nNODE n4: PrintString [InString=\"Tick Count\"]\nNODE n5: Event_EndPlay\nNODE n6: PrintString [InString=\"Goodbye\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_01:L01_17", "category": "multi_event"}
{"instruction": "make a bp that prints started on beginplay, prints tick count each frame using event tick, and prints goodbye before the actor is destroyed using event endplay.", "output": "BLUEPRINT: BP_LifecycleEvents\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_Tick\nNODE n4: PrintString [InString=\"Tick Count\"]\nNODE n5: Event_EndPlay\nNODE n6: PrintString [InString=\"Goodbye\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_01:L01_17", "category": "multi_event"}
{"instruction": "Create a Blueprint that calls PrintString with text Started on BeginPlay, calls PrintString with text Tick Count every tick via Event Tick using Event Tick, and calls PrintString with text Goodbye before the actor is destroyed using Event EndPlay.", "output": "BLUEPRINT: BP_LifecycleEvents\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_Tick\nNODE n4: PrintString [InString=\"Tick Count\"]\nNODE n5: Event_EndPlay\nNODE n6: PrintString [InString=\"Goodbye\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_01:L01_17", "category": "multi_event"}
{"instruction": "Create a Blueprint with a boolean variable IsVisible starting as true. On pressing Toggle input, flip IsVisible and call SetActorHiddenInGame with the new value.", "output": "BLUEPRINT: BP_VisibilityToggle\nPARENT: Actor\n\nVAR IsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Toggle\"]\nNODE n2: GetVariable [VarName=\"IsVisible\"]\nNODE n3: NotBool\nNODE n4: SetVariable [VarName=\"IsVisible\"]\nNODE n5: SetActorHiddenInGame\n\nEXEC n1.Pressed -> n4.Execute\nEXEC n4.Then -> n5.Execute\n\nDATA n2.Value -> n3.Input [Bool]\nDATA n3.ReturnValue -> n4.Value [Bool]\nDATA n3.ReturnValue -> n5.NewHidden [Bool]", "source": "lesson:lesson_01:L01_18", "category": "set_visibility"}
{"instruction": "bp with a bool var isvisible starting as true. on pressing toggle input, flip isvisible and call setactorhiddeningame with the new value.", "output": "BLUEPRINT: BP_VisibilityToggle\nPARENT: Actor\n\nVAR IsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Toggle\"]\nNODE n2: GetVariable [VarName=\"IsVisible\"]\nNODE n3: NotBool\nNODE n4: SetVariable [VarName=\"IsVisible\"]\nNODE n5: SetActorHiddenInGame\n\nEXEC n1.Pressed -> n4.Execute\nEXEC n4.Then -> n5.Execute\n\nDATA n2.Value -> n3.Input [Bool]\nDATA n3.ReturnValue -> n4.Value [Bool]\nDATA n3.ReturnValue -> n5.NewHidden [Bool]", "source": "lesson:lesson_01:L01_18", "category": "set_visibility"}
{"instruction": "Create a Blueprint that on BeginPlay calculates the result of (5 + 3) multiplied by 2 and prints the result.", "output": "BLUEPRINT: BP_MathExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: AddFloat [A=5.0, B=3.0]\nNODE n3: MultiplyFloat [B=2.0]\nNODE n4: PrintString\n\nEXEC n1.Then -> n4.Execute\n\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_01:L01_19", "category": "math_chain"}
{"instruction": "make a bp that on beginplay calculates the result of (5 + 3) multiplied by 2 and prints the result.", "output": "BLUEPRINT: BP_MathExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: AddFloat [A=5.0, B=3.0]\nNODE n3: MultiplyFloat [B=2.0]\nNODE n4: PrintString\n\nEXEC n1.Then -> n4.Execute\n\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_01:L01_19", "category": "math_chain"}
{"instruction": "Create a Blueprint that on BeginPlay calculates the result of (5 + 3) multiplied by 2 and calls PrintString with text the result.", "output": "BLUEPRINT: BP_MathExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: AddFloat [A=5.0, B=3.0]\nNODE n3: MultiplyFloat [B=2.0]\nNODE n4: PrintString\n\nEXEC n1.Then -> n4.Execute\n\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_01:L01_19", "category": "math_chain"}
{"instruction": "Create a Blueprint that on BeginPlay prints Ready, waits 2 seconds, prints Set, waits 1 second, then prints Go.", "output": "BLUEPRINT: BP_Countdown\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Delay [Duration=2.0]\nNODE n4: PrintString [InString=\"Set\"]\nNODE n5: Delay [Duration=1.0]\nNODE n6: PrintString [InString=\"Go\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute", "source": "lesson:lesson_01:L01_20", "category": "delay_chain"}
{"instruction": "make a bp that on beginplay prints ready, waits 2 seconds, prints set, waits 1 second, then prints go.", "output": "BLUEPRINT: BP_Countdown\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Delay [Duration=2.0]\nNODE n4: PrintString [InString=\"Set\"]\nNODE n5: Delay [Duration=1.0]\nNODE n6: PrintString [InString=\"Go\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute", "source": "lesson:lesson_01:L01_20", "category": "delay_chain"}
{"instruction": "Create a Blueprint that on BeginPlay calls PrintString with text Ready, uses a Delay node for 2 seconds, calls PrintString with text Set, uses a Delay node for 1 second, then calls PrintString with text Go.", "output": "BLUEPRINT: BP_Countdown\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Delay [Duration=2.0]\nNODE n4: PrintString [InString=\"Set\"]\nNODE n5: Delay [Duration=1.0]\nNODE n6: PrintString [InString=\"Go\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute", "source": "lesson:lesson_01:L01_20", "category": "delay_chain"}
{"instruction": "Create a Blueprint with a boolean variable IsActive. On BeginPlay, use a Branch node to check IsActive. If true, print Active. If false, print Inactive.", "output": "BLUEPRINT: BP_BranchCheck\nPARENT: Actor\nVAR IsActive: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsActive]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Active\"]\nNODE n5: PrintString [InString=\"Inactive\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_02:L02_01", "category": "branch"}
{"instruction": "bp with a bool var isactive. on beginplay, use a branch to check isactive. if true, print active. if false, print inactive.", "output": "BLUEPRINT: BP_BranchCheck\nPARENT: Actor\nVAR IsActive: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsActive]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Active\"]\nNODE n5: PrintString [InString=\"Inactive\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_02:L02_01", "category": "branch"}
{"instruction": "Create a Blueprint that on overlap checks if the overlapping actor has the tag Enemy. If yes, print Danger. If no, print Safe.", "output": "BLUEPRINT: BP_TagBranch\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: ActorHasTag [Tag=\"Enemy\"]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Danger\"]\nNODE n5: PrintString [InString=\"Safe\"]\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_02:L02_02", "category": "branch"}
{"instruction": "make a bp that on overlap checks if the overlapping actor has the tag enemy. if yes, print danger. if no, print safe.", "output": "BLUEPRINT: BP_TagBranch\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: ActorHasTag [Tag=\"Enemy\"]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Danger\"]\nNODE n5: PrintString [InString=\"Safe\"]\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_02:L02_02", "category": "branch"}
{"instruction": "Create a Blueprint with an integer variable Score set to 0. On BeginPlay, set Score to 100 then print the value of Score.", "output": "BLUEPRINT: BP_SetScore\nPARENT: Actor\nVAR Score: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=Score]\nNODE n3: VariableGet [VarName=Score]\nNODE n4: PrintString\nEXEC n1.Then -> n2.Execute\nDATA 100 -> n2.Value [Int]\nEXEC n2.Then -> n4.Execute\nDATA n3.Value -> n4.InString [String]", "source": "lesson:lesson_02:L02_03", "category": "variable_set_get"}
{"instruction": "bp with an int var score set to 0. on beginplay, set score to 100 then print the value of score.", "output": "BLUEPRINT: BP_SetScore\nPARENT: Actor\nVAR Score: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=Score]\nNODE n3: VariableGet [VarName=Score]\nNODE n4: PrintString\nEXEC n1.Then -> n2.Execute\nDATA 100 -> n2.Value [Int]\nEXEC n2.Then -> n4.Execute\nDATA n3.Value -> n4.InString [String]", "source": "lesson:lesson_02:L02_03", "category": "variable_set_get"}
{"instruction": "Create a Blueprint with a float variable Health starting at 100.0. On Event AnyDamage, subtract the damage amount from Health and set the new value.", "output": "BLUEPRINT: BP_HealthTracker\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: Subtract\nNODE n4: VariableSet [VarName=Health]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]", "source": "lesson:lesson_02:L02_04", "category": "variable_set_get"}
{"instruction": "bp with a float variable health starting at 100.0. on event anydamage, subtract the damage amount from health and set the new value.", "output": "BLUEPRINT: BP_HealthTracker\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: Subtract\nNODE n4: VariableSet [VarName=Health]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]", "source": "lesson:lesson_02:L02_04", "category": "variable_set_get"}
{"instruction": "Create a Blueprint with a custom event called OnActivate. On BeginPlay, call the custom event OnActivate. The OnActivate event prints Activated.", "output": "BLUEPRINT: BP_CustomActivate\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=OnActivate]\nNODE n3: Event_Custom [EventName=OnActivate]\nNODE n4: PrintString [InString=\"Activated\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_05", "category": "custom_event"}
{"instruction": "bp with a custom event called onactivate. on beginplay, call the custom event onactivate. the onactivate event prints activated.", "output": "BLUEPRINT: BP_CustomActivate\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=OnActivate]\nNODE n3: Event_Custom [EventName=OnActivate]\nNODE n4: PrintString [InString=\"Activated\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_05", "category": "custom_event"}
{"instruction": "Create a Blueprint with a custom event called OnActivate. On BeginPlay, call the custom event OnActivate. The OnActivate event calls PrintString with text Activated.", "output": "BLUEPRINT: BP_CustomActivate\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=OnActivate]\nNODE n3: Event_Custom [EventName=OnActivate]\nNODE n4: PrintString [InString=\"Activated\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_05", "category": "custom_event"}
{"instruction": "Create a Blueprint with a custom event TakeDamage that takes a float input Amount. When TakeDamage is called, print the Amount value.", "output": "BLUEPRINT: BP_CustomDamage\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Custom [EventName=TakeDamage]\nNODE n2: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n1.Amount -> n2.InString [String]", "source": "lesson:lesson_02:L02_06", "category": "custom_event"}
{"instruction": "bp with a custom event takedamage that takes a float input amount. when takedamage is called, print the amount value.", "output": "BLUEPRINT: BP_CustomDamage\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Custom [EventName=TakeDamage]\nNODE n2: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n1.Amount -> n2.InString [String]", "source": "lesson:lesson_02:L02_06", "category": "custom_event"}
{"instruction": "Create a Blueprint with a Gate node. On BeginPlay, open the gate. When the player presses the Fire input action, the gate filters execution to print Firing.", "output": "BLUEPRINT: BP_GateExample\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: Event_InputAction [ActionName=\"Fire\"]\nNODE n4: PrintString [InString=\"Firing\"]\nEXEC n1.Then -> n2.Open\nEXEC n3.Pressed -> n2.Enter\nEXEC n2.Exit -> n4.Execute", "source": "lesson:lesson_02:L02_07", "category": "gate"}
{"instruction": "bp with a gate. on beginplay, open the gate. on pressing the fire input, the gate filters execution to print firing.", "output": "BLUEPRINT: BP_GateExample\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: Event_InputAction [ActionName=\"Fire\"]\nNODE n4: PrintString [InString=\"Firing\"]\nEXEC n1.Then -> n2.Open\nEXEC n3.Pressed -> n2.Enter\nEXEC n2.Exit -> n4.Execute", "source": "lesson:lesson_02:L02_07", "category": "gate"}
{"instruction": "Create a Blueprint where pressing Interact opens a gate and pressing Fire enters the gate to toggle visibility.", "output": "BLUEPRINT: BP_GateToggle\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: Gate\nNODE n3: Event_InputAction [ActionName=\"Fire\"]\nNODE n4: ToggleVisibility\nEXEC n1.Pressed -> n2.Open\nEXEC n3.Pressed -> n2.Enter\nEXEC n2.Exit -> n4.Execute", "source": "lesson:lesson_02:L02_08", "category": "gate"}
{"instruction": "Create a Blueprint that spawns a projectile actor at the player's location when the Fire input is pressed.", "output": "BLUEPRINT: BP_SpawnProjectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]", "source": "lesson:lesson_02:L02_09", "category": "spawn_actor"}
{"instruction": "make a bp that spawns a projectile actor at the player's location when the fire input is pressed.", "output": "BLUEPRINT: BP_SpawnProjectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]", "source": "lesson:lesson_02:L02_09", "category": "spawn_actor"}
{"instruction": "Create a Blueprint that on BeginPlay spawns 3 enemy actors using a ForEachLoop over an array.", "output": "BLUEPRINT: BP_SpawnEnemies\nPARENT: Actor\nVAR SpawnPoints: Array<Vector>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=SpawnPoints]\nNODE n3: ForEachLoop\nNODE n4: SpawnActorFromClass [ActorClass=BP_Enemy]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.SpawnTransform [Transform]", "source": "lesson:lesson_02:L02_10", "category": "spawn_actor"}
{"instruction": "make a bp that on beginplay spawns 3 enemy actors with foreachloop over an array.", "output": "BLUEPRINT: BP_SpawnEnemies\nPARENT: Actor\nVAR SpawnPoints: Array<Vector>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=SpawnPoints]\nNODE n3: ForEachLoop\nNODE n4: SpawnActorFromClass [ActorClass=BP_Enemy]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.SpawnTransform [Transform]", "source": "lesson:lesson_02:L02_10", "category": "spawn_actor"}
{"instruction": "Create a Blueprint with an array of Actors called Targets. On BeginPlay, use a ForEachLoop to iterate through Targets and call DestroyActor on each one.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: DestroyActor\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]", "source": "lesson:lesson_02:L02_11", "category": "foreach"}
{"instruction": "bp with an array of actors called targets. on beginplay, use a foreachloop to iterate through targets and call destroyactor on each one.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: DestroyActor\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]", "source": "lesson:lesson_02:L02_11", "category": "foreach"}
{"instruction": "Create a Blueprint that on BeginPlay loops through an array of strings called Messages and prints each one.", "output": "BLUEPRINT: BP_PrintAll\nPARENT: Actor\nVAR Messages: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Messages]\nNODE n3: ForEachLoop\nNODE n4: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.InString [String]", "source": "lesson:lesson_02:L02_12", "category": "foreach"}
{"instruction": "make a bp that on beginplay loops through an array of strings called messages and prints each one.", "output": "BLUEPRINT: BP_PrintAll\nPARENT: Actor\nVAR Messages: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Messages]\nNODE n3: ForEachLoop\nNODE n4: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.InString [String]", "source": "lesson:lesson_02:L02_12", "category": "foreach"}
{"instruction": "Create a Blueprint that on BeginPlay loops through an array of strings called Messages and calls PrintString with text each one.", "output": "BLUEPRINT: BP_PrintAll\nPARENT: Actor\nVAR Messages: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Messages]\nNODE n3: ForEachLoop\nNODE n4: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.InString [String]", "source": "lesson:lesson_02:L02_12", "category": "foreach"}
{"instruction": "Create a Blueprint that on Tick gets the distance to the player. If the distance is less than 500, print Close.", "output": "BLUEPRINT: BP_DistanceCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=500.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Close\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute", "source": "lesson:lesson_02:L02_13", "category": "distance_check"}
{"instruction": "make a bp that on tick gets the distance to the player. if the distance is less than 500, print close.", "output": "BLUEPRINT: BP_DistanceCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=500.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Close\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute", "source": "lesson:lesson_02:L02_13", "category": "distance_check"}
{"instruction": "Create a Blueprint that on Tick checks distance to the player. If less than 200, print Near. If more than 1000, print Far.", "output": "BLUEPRINT: BP_NearFar\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Near\"]\nNODE n7: GreaterThan [B=1000.0]\nNODE n8: Branch\nNODE n9: PrintString [InString=\"Far\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n8.Execute\nDATA n3.ReturnValue -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute", "source": "lesson:lesson_02:L02_14", "category": "distance_check"}
{"instruction": "make a bp that on tick checks distance to the player. if less than 200, print near. if more than 1000, print far.", "output": "BLUEPRINT: BP_NearFar\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Near\"]\nNODE n7: GreaterThan [B=1000.0]\nNODE n8: Branch\nNODE n9: PrintString [InString=\"Far\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n8.Execute\nDATA n3.ReturnValue -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute", "source": "lesson:lesson_02:L02_14", "category": "distance_check"}
{"instruction": "Create a Blueprint with a boolean variable IsVisible starting at true. On BeginPlay, set IsVisible to false and call SetVisibility with NewVisibility set to false.", "output": "BLUEPRINT: BP_HideOnStart\nPARENT: Actor\nVAR IsVisible: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=IsVisible]\nNODE n3: SetVisibility [NewVisibility=false]\nEXEC n1.Then -> n2.Execute\nDATA false -> n2.Value [Bool]\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_02:L02_15", "category": "set_visibility"}
{"instruction": "bp with a bool var isvisible starting at true. on beginplay, set isvisible to false and call setvisibility with newvisibility set to false.", "output": "BLUEPRINT: BP_HideOnStart\nPARENT: Actor\nVAR IsVisible: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=IsVisible]\nNODE n3: SetVisibility [NewVisibility=false]\nEXEC n1.Then -> n2.Execute\nDATA false -> n2.Value [Bool]\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_02:L02_15", "category": "set_visibility"}
{"instruction": "Create a Blueprint that toggles visibility each time the player presses Interact. Use a FlipFlop and SetVisibility nodes.", "output": "BLUEPRINT: BP_ToggleVis\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [NewVisibility=true]\nNODE n4: SetVisibility [NewVisibility=false]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_02:L02_16", "category": "set_visibility"}
{"instruction": "make a bp that toggles visibility each time the player presses interact. use a flipflop and setvisibilitys.", "output": "BLUEPRINT: BP_ToggleVis\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [NewVisibility=true]\nNODE n4: SetVisibility [NewVisibility=false]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_02:L02_16", "category": "set_visibility"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence node to first print Step 1, then print Step 2, then print Step 3.", "output": "BLUEPRINT: BP_SequenceSteps\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: PrintString [InString=\"Step 2\"]\nNODE n5: PrintString [InString=\"Step 3\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n2.Then_2 -> n5.Execute", "source": "lesson:lesson_02:L02_17", "category": "sequence"}
{"instruction": "make a bp that on beginplay uses a sequence to first print step 1, then print step 2, then print step 3.", "output": "BLUEPRINT: BP_SequenceSteps\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: PrintString [InString=\"Step 2\"]\nNODE n5: PrintString [InString=\"Step 3\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n2.Then_2 -> n5.Execute", "source": "lesson:lesson_02:L02_17", "category": "sequence"}
{"instruction": "Create a Blueprint that on Tick adds a rotation of 1.0 on the Yaw axis to make the actor spin continuously.", "output": "BLUEPRINT: BP_Spinner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalRotation [DeltaRotation=(Pitch=0.0,Yaw=1.0,Roll=0.0)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_02:L02_18", "category": "rotating_actor"}
{"instruction": "make a bp that on tick adds a rotation of 1.0 on the yaw axis to make the actor spin continuously.", "output": "BLUEPRINT: BP_Spinner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalRotation [DeltaRotation=(Pitch=0.0,Yaw=1.0,Roll=0.0)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_02:L02_18", "category": "rotating_actor"}
{"instruction": "Create a Blueprint that when another actor overlaps, prints the name of the overlapping actor using GetDisplayName.", "output": "BLUEPRINT: BP_PrintOverlapper\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetDisplayName\nNODE n3: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.InString [String]", "source": "lesson:lesson_02:L02_19", "category": "overlap_event"}
{"instruction": "make a bp that when something overlaps, prints the name of the overlapping actor using getdisplayname.", "output": "BLUEPRINT: BP_PrintOverlapper\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetDisplayName\nNODE n3: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.InString [String]", "source": "lesson:lesson_02:L02_19", "category": "overlap_event"}
{"instruction": "Create a Blueprint that when another actor overlaps, calls PrintString with text the name of the overlapping actor using GetDisplayName.", "output": "BLUEPRINT: BP_PrintOverlapper\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetDisplayName\nNODE n3: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.InString [String]", "source": "lesson:lesson_02:L02_19", "category": "overlap_event"}
{"instruction": "Create a Blueprint that plays a sound at the actor's location when BeginPlay fires. Use PlaySoundAtLocation.", "output": "BLUEPRINT: BP_PlayStartSound\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: PlaySoundAtLocation [Sound=StartSound]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Location [Vector]", "source": "lesson:lesson_02:L02_20", "category": "play_sound"}
{"instruction": "make a bp that plays a sound at the actor's location when beginplay fires. use playsoundatlocation.", "output": "BLUEPRINT: BP_PlayStartSound\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: PlaySoundAtLocation [Sound=StartSound]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Location [Vector]", "source": "lesson:lesson_02:L02_20", "category": "play_sound"}
{"instruction": "Create a Blueprint that prints Welcome only the first time the player overlaps, using a DoOnce node.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_02:L02_21", "category": "doonce"}
{"instruction": "make a bp that prints welcome only the first time the player overlaps, with doonce.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_02:L02_21", "category": "doonce"}
{"instruction": "Create a Blueprint that calls PrintString with text Welcome only the first time the player overlaps, using a DoOnce node.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_02:L02_21", "category": "doonce"}
{"instruction": "Create a Blueprint that on BeginPlay multiplies 5 times 10, adds 25, and prints the result.", "output": "BLUEPRINT: BP_MathChain\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Multiply [A=5, B=10]\nNODE n3: Add [A=0, B=25]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_02:L02_22", "category": "math_chain"}
{"instruction": "make a bp that on beginplay multiplies 5 times 10, adds 25, and prints the result.", "output": "BLUEPRINT: BP_MathChain\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Multiply [A=5, B=10]\nNODE n3: Add [A=0, B=25]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_02:L02_22", "category": "math_chain"}
{"instruction": "Create a Blueprint that on BeginPlay multiplies 5 times 10, adds 25, and calls PrintString with text the result.", "output": "BLUEPRINT: BP_MathChain\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Multiply [A=5, B=10]\nNODE n3: Add [A=0, B=25]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_02:L02_22", "category": "math_chain"}
{"instruction": "Create a Blueprint that prints Started on BeginPlay and prints Ended on EndPlay.", "output": "BLUEPRINT: BP_StartEnd\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_EndPlay\nNODE n4: PrintString [InString=\"Ended\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_23", "category": "multi_event"}
{"instruction": "make a bp that prints started on beginplay and prints ended on endplay.", "output": "BLUEPRINT: BP_StartEnd\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_EndPlay\nNODE n4: PrintString [InString=\"Ended\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_23", "category": "multi_event"}
{"instruction": "Create a Blueprint that calls PrintString with text Started on BeginPlay and calls PrintString with text Ended on EndPlay.", "output": "BLUEPRINT: BP_StartEnd\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_EndPlay\nNODE n4: PrintString [InString=\"Ended\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_23", "category": "multi_event"}
{"instruction": "Create a Blueprint with three events: BeginPlay prints Ready, pressing Jump prints Jumped, and on overlap prints Touched.", "output": "BLUEPRINT: BP_ThreeEvents\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Event_InputAction [ActionName=\"Jump\"]\nNODE n4: PrintString [InString=\"Jumped\"]\nNODE n5: Event_ActorBeginOverlap\nNODE n6: PrintString [InString=\"Touched\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Pressed -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_02:L02_24", "category": "multi_event"}
{"instruction": "bp with three events: beginplay prints ready, pressing jump prints jumped, and on overlap prints touched.", "output": "BLUEPRINT: BP_ThreeEvents\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Event_InputAction [ActionName=\"Jump\"]\nNODE n4: PrintString [InString=\"Jumped\"]\nNODE n5: Event_ActorBeginOverlap\nNODE n6: PrintString [InString=\"Touched\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Pressed -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_02:L02_24", "category": "multi_event"}
{"instruction": "Create a Blueprint with three events: BeginPlay calls PrintString with text Ready, pressing Jump calls PrintString with text Jumped, and on overlap calls PrintString with text Touched.", "output": "BLUEPRINT: BP_ThreeEvents\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Event_InputAction [ActionName=\"Jump\"]\nNODE n4: PrintString [InString=\"Jumped\"]\nNODE n5: Event_ActorBeginOverlap\nNODE n6: PrintString [InString=\"Touched\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Pressed -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_02:L02_24", "category": "multi_event"}
{"instruction": "Create a Blueprint that on BeginPlay sets a timer called SpawnTimer that calls a custom event SpawnEnemy every 5 seconds.", "output": "BLUEPRINT: BP_SpawnTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnEnemy\", Time=5.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnEnemy]\nNODE n4: PrintString [InString=\"Enemy Spawned\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_03:L03_01", "category": "timer_basic"}
{"instruction": "make a bp that on beginplay sets a timer called spawntimer that calls a custom event spawnenemy every 5 seconds.", "output": "BLUEPRINT: BP_SpawnTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnEnemy\", Time=5.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnEnemy]\nNODE n4: PrintString [InString=\"Enemy Spawned\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_03:L03_01", "category": "timer_basic"}
{"instruction": "Create a Blueprint that starts a looping timer on BeginPlay and clears it when the player presses the Stop input action.", "output": "BLUEPRINT: BP_StoppableTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"DoWork\", Time=2.0, Looping=true]\nNODE n3: Event_InputAction [ActionName=\"Stop\"]\nNODE n4: ClearTimerByFunctionName [FunctionName=\"DoWork\"]\nNODE n5: Event_Custom [EventName=DoWork]\nNODE n6: PrintString [InString=\"Working\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Pressed -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_03:L03_02", "category": "timer_clear"}
{"instruction": "make a bp that starts a looping timer on beginplay and clears it on pressing the stop input.", "output": "BLUEPRINT: BP_StoppableTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"DoWork\", Time=2.0, Looping=true]\nNODE n3: Event_InputAction [ActionName=\"Stop\"]\nNODE n4: ClearTimerByFunctionName [FunctionName=\"DoWork\"]\nNODE n5: Event_Custom [EventName=DoWork]\nNODE n6: PrintString [InString=\"Working\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Pressed -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_03:L03_02", "category": "timer_clear"}
{"instruction": "Create a Blueprint that on BeginPlay sets a one-shot timer for 10 seconds. When the timer fires, destroy the actor.", "output": "BLUEPRINT: BP_SelfDestruct\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SelfDestruct\", Time=10.0, Looping=false]\nNODE n3: Event_Custom [EventName=SelfDestruct]\nNODE n4: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_03:L03_03", "category": "timer_oneshot"}
{"instruction": "make a bp that on beginplay sets a one-shot timer for 10 seconds. when the timer fires, destroy the actor.", "output": "BLUEPRINT: BP_SelfDestruct\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SelfDestruct\", Time=10.0, Looping=false]\nNODE n3: Event_Custom [EventName=SelfDestruct]\nNODE n4: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_03:L03_03", "category": "timer_oneshot"}
{"instruction": "Create a Blueprint that on overlap starts a retriggerable delay of 3 seconds. When the delay completes, print Timeout. Each new overlap resets the timer.", "output": "BLUEPRINT: BP_RetriggerExample\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: RetriggerableDelay [Duration=3.0]\nNODE n3: PrintString [InString=\"Timeout\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_03:L03_04", "category": "retriggerable_delay"}
{"instruction": "make a bp that on overlap starts a retriggerable delay of 3 seconds. when the delay completes, print timeout. each new overlap resets the timer.", "output": "BLUEPRINT: BP_RetriggerExample\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: RetriggerableDelay [Duration=3.0]\nNODE n3: PrintString [InString=\"Timeout\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_03:L03_04", "category": "retriggerable_delay"}
{"instruction": "Create a Blueprint with a boolean variable IsActive. On BeginPlay, check IsActive. If true, set a looping timer every 2 seconds. If false, print Disabled.", "output": "BLUEPRINT: BP_ConditionalTimer\nPARENT: Actor\nVAR IsActive: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsActive]\nNODE n3: Branch\nNODE n4: SetTimerByFunctionName [FunctionName=\"Pulse\", Time=2.0, Looping=true]\nNODE n5: PrintString [InString=\"Disabled\"]\nNODE n6: Event_Custom [EventName=Pulse]\nNODE n7: PrintString [InString=\"Pulse\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_03:L03_05", "category": "timer_with_branch"}
{"instruction": "bp with a bool var isactive. on beginplay, check isactive. if true, set a looping timer every 2 seconds. if false, print disabled.", "output": "BLUEPRINT: BP_ConditionalTimer\nPARENT: Actor\nVAR IsActive: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsActive]\nNODE n3: Branch\nNODE n4: SetTimerByFunctionName [FunctionName=\"Pulse\", Time=2.0, Looping=true]\nNODE n5: PrintString [InString=\"Disabled\"]\nNODE n6: Event_Custom [EventName=Pulse]\nNODE n7: PrintString [InString=\"Pulse\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_03:L03_05", "category": "timer_with_branch"}
{"instruction": "Create a Blueprint that on BeginPlay prints Phase 1, waits 2 seconds, prints Phase 2, waits 3 seconds, prints Phase 3, waits 1 second, then destroys itself.", "output": "BLUEPRINT: BP_PhasedSequence\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Phase 1\"]\nNODE n3: Delay [Duration=2.0]\nNODE n4: PrintString [InString=\"Phase 2\"]\nNODE n5: Delay [Duration=3.0]\nNODE n6: PrintString [InString=\"Phase 3\"]\nNODE n7: Delay [Duration=1.0]\nNODE n8: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute\nEXEC n6.Then -> n7.Execute\nEXEC n7.Completed -> n8.Execute", "source": "lesson:lesson_03:L03_06", "category": "delay_sequence"}
{"instruction": "make a bp that on beginplay prints phase 1, waits 2 seconds, prints phase 2, waits 3 seconds, prints phase 3, waits 1 second, then destroys itself.", "output": "BLUEPRINT: BP_PhasedSequence\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Phase 1\"]\nNODE n3: Delay [Duration=2.0]\nNODE n4: PrintString [InString=\"Phase 2\"]\nNODE n5: Delay [Duration=3.0]\nNODE n6: PrintString [InString=\"Phase 3\"]\nNODE n7: Delay [Duration=1.0]\nNODE n8: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute\nEXEC n6.Then -> n7.Execute\nEXEC n7.Completed -> n8.Execute", "source": "lesson:lesson_03:L03_06", "category": "delay_sequence"}
{"instruction": "Create a Blueprint that on BeginPlay calls PrintString with text Phase 1, uses a Delay node for 2 seconds, calls PrintString with text Phase 2, uses a Delay node for 3 seconds, calls PrintString with text Phase 3, uses a Delay node for 1 second, then calls DestroyActor on self.", "output": "BLUEPRINT: BP_PhasedSequence\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Phase 1\"]\nNODE n3: Delay [Duration=2.0]\nNODE n4: PrintString [InString=\"Phase 2\"]\nNODE n5: Delay [Duration=3.0]\nNODE n6: PrintString [InString=\"Phase 3\"]\nNODE n7: Delay [Duration=1.0]\nNODE n8: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute\nEXEC n6.Then -> n7.Execute\nEXEC n7.Completed -> n8.Execute", "source": "lesson:lesson_03:L03_06", "category": "delay_sequence"}
{"instruction": "Create a Blueprint with an integer variable Count starting at 0. Set a looping timer every 1 second. Each time the timer fires, increment Count by 1 and print the count. When Count reaches 5, clear the timer.", "output": "BLUEPRINT: BP_CountdownTimer\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Tick\", Time=1.0, Looping=true]\nNODE n3: Event_Custom [EventName=Tick]\nNODE n4: VariableGet [VarName=Count]\nNODE n5: AddInt [B=1]\nNODE n6: VariableSet [VarName=Count]\nNODE n7: PrintString\nNODE n8: GreaterThan [B=4]\nNODE n9: Branch\nNODE n10: ClearTimerByFunctionName [FunctionName=\"Tick\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Value [Int]\nEXEC n6.Then -> n7.Execute\nDATA n6.Value -> n7.InString [String]\nEXEC n7.Then -> n9.Execute\nDATA n6.Value -> n8.A [Int]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute", "source": "lesson:lesson_03:L03_07", "category": "timer_counter"}
{"instruction": "bp with an int var count starting at 0. set a looping timer every 1 second. each time the timer fires, increment count by 1 and print the count. when count reaches 5, clear the timer.", "output": "BLUEPRINT: BP_CountdownTimer\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Tick\", Time=1.0, Looping=true]\nNODE n3: Event_Custom [EventName=Tick]\nNODE n4: VariableGet [VarName=Count]\nNODE n5: AddInt [B=1]\nNODE n6: VariableSet [VarName=Count]\nNODE n7: PrintString\nNODE n8: GreaterThan [B=4]\nNODE n9: Branch\nNODE n10: ClearTimerByFunctionName [FunctionName=\"Tick\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Value [Int]\nEXEC n6.Then -> n7.Execute\nDATA n6.Value -> n7.InString [String]\nEXEC n7.Then -> n9.Execute\nDATA n6.Value -> n8.A [Int]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute", "source": "lesson:lesson_03:L03_07", "category": "timer_counter"}
{"instruction": "Create a Blueprint that on BeginPlay hides the actor, waits 5 seconds, then makes it visible.", "output": "BLUEPRINT: BP_DelayedAppear\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetActorHiddenInGame [NewHidden=true]\nNODE n3: Delay [Duration=5.0]\nNODE n4: SetActorHiddenInGame [NewHidden=false]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute", "source": "lesson:lesson_03:L03_08", "category": "delay_with_visibility"}
{"instruction": "make a bp that on beginplay hides the actor, waits 5 seconds, then makes it visible.", "output": "BLUEPRINT: BP_DelayedAppear\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetActorHiddenInGame [NewHidden=true]\nNODE n3: Delay [Duration=5.0]\nNODE n4: SetActorHiddenInGame [NewHidden=false]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute", "source": "lesson:lesson_03:L03_08", "category": "delay_with_visibility"}
{"instruction": "Create a Blueprint that on BeginPlay hides the actor, uses a Delay node for 5 seconds, then makes it visible.", "output": "BLUEPRINT: BP_DelayedAppear\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetActorHiddenInGame [NewHidden=true]\nNODE n3: Delay [Duration=5.0]\nNODE n4: SetActorHiddenInGame [NewHidden=false]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute", "source": "lesson:lesson_03:L03_08", "category": "delay_with_visibility"}
{"instruction": "Create a Blueprint where pressing Interact toggles a timer on and off. Use a boolean variable TimerRunning to track state.", "output": "BLUEPRINT: BP_ToggleTimer\nPARENT: Actor\nVAR TimerRunning: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: VariableGet [VarName=TimerRunning]\nNODE n3: Branch\nNODE n4: ClearTimerByFunctionName [FunctionName=\"DoTick\"]\nNODE n5: VariableSet [VarName=TimerRunning]\nNODE n6: SetTimerByFunctionName [FunctionName=\"DoTick\", Time=1.0, Looping=true]\nNODE n7: VariableSet [VarName=TimerRunning]\nNODE n8: Event_Custom [EventName=DoTick]\nNODE n9: PrintString [InString=\"Tick\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA false -> n5.Value [Bool]\nEXEC n3.False -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA true -> n7.Value [Bool]\nEXEC n8.Then -> n9.Execute", "source": "lesson:lesson_03:L03_09", "category": "timer_toggle"}
{"instruction": "create a blueprint where pressing interact toggles a timer on and off. use a bool var timerrunning to track state.", "output": "BLUEPRINT: BP_ToggleTimer\nPARENT: Actor\nVAR TimerRunning: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: VariableGet [VarName=TimerRunning]\nNODE n3: Branch\nNODE n4: ClearTimerByFunctionName [FunctionName=\"DoTick\"]\nNODE n5: VariableSet [VarName=TimerRunning]\nNODE n6: SetTimerByFunctionName [FunctionName=\"DoTick\", Time=1.0, Looping=true]\nNODE n7: VariableSet [VarName=TimerRunning]\nNODE n8: Event_Custom [EventName=DoTick]\nNODE n9: PrintString [InString=\"Tick\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA false -> n5.Value [Bool]\nEXEC n3.False -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA true -> n7.Value [Bool]\nEXEC n8.Then -> n9.Execute", "source": "lesson:lesson_03:L03_09", "category": "timer_toggle"}
{"instruction": "Create a Blueprint that when overlapped, prints Entered, waits 2 seconds, then prints Welcome. Use a DoOnce so this only happens the first time.", "output": "BLUEPRINT: BP_DelayedWelcome\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Entered\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Welcome\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_03:L03_10", "category": "delay_overlap"}
{"instruction": "make a bp that when overlapped, prints entered, waits 2 seconds, then prints welcome. use a doonce so this only happens the first time.", "output": "BLUEPRINT: BP_DelayedWelcome\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Entered\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Welcome\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_03:L03_10", "category": "delay_overlap"}
{"instruction": "Create a Blueprint that when overlapped, calls PrintString with text Entered, uses a Delay node for 2 seconds, then calls PrintString with text Welcome. Use a DoOnce so this only happens the first time.", "output": "BLUEPRINT: BP_DelayedWelcome\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Entered\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Welcome\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_03:L03_10", "category": "delay_overlap"}
{"instruction": "Create a Blueprint that on BeginPlay sets a looping timer every 3 seconds. Each time the timer fires, spawn an actor of class BP_Coin at the actor's location.", "output": "BLUEPRINT: BP_CoinSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnCoin\", Time=3.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnCoin]\nNODE n4: GetActorLocation\nNODE n5: SpawnActorFromClass [ActorClass=BP_Coin]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]", "source": "lesson:lesson_03:L03_11", "category": "timer_spawner"}
{"instruction": "make a bp that on beginplay sets a looping timer every 3 seconds. each time the timer fires, spawn an actor of class bp_coin at the actor's location.", "output": "BLUEPRINT: BP_CoinSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnCoin\", Time=3.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnCoin]\nNODE n4: GetActorLocation\nNODE n5: SpawnActorFromClass [ActorClass=BP_Coin]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]", "source": "lesson:lesson_03:L03_11", "category": "timer_spawner"}
{"instruction": "Create a Blueprint that on BeginPlay checks a boolean IsFast. If true, wait 1 second then print Done. If false, wait 5 seconds then print Done.", "output": "BLUEPRINT: BP_ConditionalDelay\nPARENT: Actor\nVAR IsFast: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsFast]\nNODE n3: Branch\nNODE n4: Delay [Duration=1.0]\nNODE n5: Delay [Duration=5.0]\nNODE n6: PrintString [InString=\"Done\"]\nNODE n7: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute\nEXEC n4.Completed -> n6.Execute\nEXEC n5.Completed -> n7.Execute", "source": "lesson:lesson_03:L03_12", "category": "delay_chain_branch"}
{"instruction": "make a bp that on beginplay checks a boolean isfast. if true, wait 1 second then print done. if false, wait 5 seconds then print done.", "output": "BLUEPRINT: BP_ConditionalDelay\nPARENT: Actor\nVAR IsFast: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsFast]\nNODE n3: Branch\nNODE n4: Delay [Duration=1.0]\nNODE n5: Delay [Duration=5.0]\nNODE n6: PrintString [InString=\"Done\"]\nNODE n7: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute\nEXEC n4.Completed -> n6.Execute\nEXEC n5.Completed -> n7.Execute", "source": "lesson:lesson_03:L03_12", "category": "delay_chain_branch"}
{"instruction": "Create a Blueprint with a float variable Health at 50.0. On BeginPlay start a looping timer every 2 seconds. Each tick add 5 to Health and print the value. When Health reaches 100 or more, clear the timer and print Full Health.", "output": "BLUEPRINT: BP_HealthRegen\nPARENT: Actor\nVAR Health: Float = 50.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Regen\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=Regen]\nNODE n4: VariableGet [VarName=Health]\nNODE n5: AddFloat [B=5.0]\nNODE n6: VariableSet [VarName=Health]\nNODE n7: PrintString\nNODE n8: GreaterThan [B=99.9]\nNODE n9: Branch\nNODE n10: ClearTimerByFunctionName [FunctionName=\"Regen\"]\nNODE n11: PrintString [InString=\"Full Health\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n7.Execute\nDATA n6.Value -> n7.InString [String]\nEXEC n7.Then -> n9.Execute\nDATA n6.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute\nEXEC n10.Then -> n11.Execute", "source": "lesson:lesson_03:L03_13", "category": "timer_health_regen"}
{"instruction": "bp with a float variable health at 50.0. on beginplay start a looping timer every 2 seconds. each tick add 5 to health and print the value. when health reaches 100 or more, clear the timer and print full health.", "output": "BLUEPRINT: BP_HealthRegen\nPARENT: Actor\nVAR Health: Float = 50.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Regen\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=Regen]\nNODE n4: VariableGet [VarName=Health]\nNODE n5: AddFloat [B=5.0]\nNODE n6: VariableSet [VarName=Health]\nNODE n7: PrintString\nNODE n8: GreaterThan [B=99.9]\nNODE n9: Branch\nNODE n10: ClearTimerByFunctionName [FunctionName=\"Regen\"]\nNODE n11: PrintString [InString=\"Full Health\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n7.Execute\nDATA n6.Value -> n7.InString [String]\nEXEC n7.Then -> n9.Execute\nDATA n6.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute\nEXEC n10.Then -> n11.Execute", "source": "lesson:lesson_03:L03_13", "category": "timer_health_regen"}
{"instruction": "Create a Blueprint that when the player presses Interact, prints Action then starts a retriggerable delay of 2 seconds. When the delay completes print Idle. Each press resets the delay.", "output": "BLUEPRINT: BP_IdleDetector\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: PrintString [InString=\"Action\"]\nNODE n3: RetriggerableDelay [Duration=2.0]\nNODE n4: PrintString [InString=\"Idle\"]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute", "source": "lesson:lesson_03:L03_14", "category": "retriggerable_interaction"}
{"instruction": "make a bp that on pressing interact, prints action then starts a retriggerable delay of 2 seconds. when the delay completes print idle. each press resets the delay.", "output": "BLUEPRINT: BP_IdleDetector\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: PrintString [InString=\"Action\"]\nNODE n3: RetriggerableDelay [Duration=2.0]\nNODE n4: PrintString [InString=\"Idle\"]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute", "source": "lesson:lesson_03:L03_14", "category": "retriggerable_interaction"}
{"instruction": "Create a Blueprint that when the player presses Interact, calls PrintString with text Action then starts a retriggerable delay of 2 seconds. When the delay completes print Idle. Each press resets the delay.", "output": "BLUEPRINT: BP_IdleDetector\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: PrintString [InString=\"Action\"]\nNODE n3: RetriggerableDelay [Duration=2.0]\nNODE n4: PrintString [InString=\"Idle\"]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute", "source": "lesson:lesson_03:L03_14", "category": "retriggerable_interaction"}
{"instruction": "Create a Blueprint that on BeginPlay starts a looping timer every 4 seconds. Each time the timer fires, play a sound at the actor's location.", "output": "BLUEPRINT: BP_RepeatingSound\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"PlayBeep\", Time=4.0, Looping=true]\nNODE n3: Event_Custom [EventName=PlayBeep]\nNODE n4: GetActorLocation\nNODE n5: PlaySoundAtLocation [Sound=BeepSound]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Location [Vector]", "source": "lesson:lesson_03:L03_15", "category": "timer_with_sound"}
{"instruction": "make a bp that on beginplay starts a looping timer every 4 seconds. each time the timer fires, play a sound at the actor's location.", "output": "BLUEPRINT: BP_RepeatingSound\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"PlayBeep\", Time=4.0, Looping=true]\nNODE n3: Event_Custom [EventName=PlayBeep]\nNODE n4: GetActorLocation\nNODE n5: PlaySoundAtLocation [Sound=BeepSound]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Location [Vector]", "source": "lesson:lesson_03:L03_15", "category": "timer_with_sound"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence node. The first output prints Spawned. The second output waits 10 seconds then calls DestroyActor.", "output": "BLUEPRINT: BP_TimedLife\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Spawned\"]\nNODE n4: Delay [Duration=10.0]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_03:L03_16", "category": "delay_destroy_sequence"}
{"instruction": "make a bp that on beginplay uses a sequence. the first output prints spawned. the second output waits 10 seconds then calls destroyactor.", "output": "BLUEPRINT: BP_TimedLife\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Spawned\"]\nNODE n4: Delay [Duration=10.0]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_03:L03_16", "category": "delay_destroy_sequence"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence node. The first output calls PrintString with text Spawned. The second output uses a Delay node for 10 seconds then calls DestroyActor.", "output": "BLUEPRINT: BP_TimedLife\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Spawned\"]\nNODE n4: Delay [Duration=10.0]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_03:L03_16", "category": "delay_destroy_sequence"}
{"instruction": "Create a Blueprint with a Gate node. On BeginPlay, open the gate and start a looping timer. The timer enters the gate. The gate exit prints Pulse. Pressing Stop closes the gate.", "output": "BLUEPRINT: BP_GatedTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"TimerTick\", Time=1.0, Looping=true]\nNODE n4: Event_Custom [EventName=TimerTick]\nNODE n5: PrintString [InString=\"Pulse\"]\nNODE n6: Event_InputAction [ActionName=\"Stop\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n6.Pressed -> n2.Close", "source": "lesson:lesson_03:L03_17", "category": "timer_with_gate"}
{"instruction": "bp with a gate. on beginplay, open the gate and start a looping timer. the timer enters the gate. the gate exit prints pulse. pressing stop closes the gate.", "output": "BLUEPRINT: BP_GatedTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"TimerTick\", Time=1.0, Looping=true]\nNODE n4: Event_Custom [EventName=TimerTick]\nNODE n5: PrintString [InString=\"Pulse\"]\nNODE n6: Event_InputAction [ActionName=\"Stop\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n6.Pressed -> n2.Close", "source": "lesson:lesson_03:L03_17", "category": "timer_with_gate"}
{"instruction": "Create a Blueprint with a Gate node. On BeginPlay, open the gate and start a looping timer. The timer enters the gate. The gate exit calls PrintString with text Pulse. Pressing Stop closes the gate.", "output": "BLUEPRINT: BP_GatedTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"TimerTick\", Time=1.0, Looping=true]\nNODE n4: Event_Custom [EventName=TimerTick]\nNODE n5: PrintString [InString=\"Pulse\"]\nNODE n6: Event_InputAction [ActionName=\"Stop\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n6.Pressed -> n2.Close", "source": "lesson:lesson_03:L03_17", "category": "timer_with_gate"}
{"instruction": "Create a Blueprint where pressing Interact uses a FlipFlop. On the A output, wait 1 second then print On. On the B output, wait 1 second then print Off.", "output": "BLUEPRINT: BP_DelayedToggle\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: Delay [Duration=1.0]\nNODE n4: PrintString [InString=\"On\"]\nNODE n5: Delay [Duration=1.0]\nNODE n6: PrintString [InString=\"Off\"]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n2.B -> n5.Execute\nEXEC n5.Completed -> n6.Execute", "source": "lesson:lesson_03:L03_18", "category": "delay_flipflop"}
{"instruction": "Create a Blueprint that starts a 5-second self-destruct timer on BeginPlay. If the player overlaps the actor before the timer fires, clear the timer and print Saved.", "output": "BLUEPRINT: BP_DefuseBomb\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Explode\", Time=5.0, Looping=false]\nNODE n3: Event_Custom [EventName=Explode]\nNODE n4: DestroyActor\nNODE n5: Event_ActorBeginOverlap\nNODE n6: ClearTimerByFunctionName [FunctionName=\"Explode\"]\nNODE n7: PrintString [InString=\"Saved\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_03:L03_19", "category": "timer_overlap_clear"}
{"instruction": "make a bp that starts a 5-second self-destruct timer on beginplay. if the player overlaps the actor before the timer fires, clear the timer and print saved.", "output": "BLUEPRINT: BP_DefuseBomb\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Explode\", Time=5.0, Looping=false]\nNODE n3: Event_Custom [EventName=Explode]\nNODE n4: DestroyActor\nNODE n5: Event_ActorBeginOverlap\nNODE n6: ClearTimerByFunctionName [FunctionName=\"Explode\"]\nNODE n7: PrintString [InString=\"Saved\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_03:L03_19", "category": "timer_overlap_clear"}
{"instruction": "Create a Blueprint that on BeginPlay prints Initializing and waits 3 seconds then prints Ready. On Tick prints Running. On EndPlay prints Shutting Down.", "output": "BLUEPRINT: BP_LifecycleDelayed\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Initializing\"]\nNODE n3: Delay [Duration=3.0]\nNODE n4: PrintString [InString=\"Ready\"]\nNODE n5: Event_Tick\nNODE n6: PrintString [InString=\"Running\"]\nNODE n7: Event_EndPlay\nNODE n8: PrintString [InString=\"Shutting Down\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_03:L03_20", "category": "delay_multi_event"}
{"instruction": "make a bp that on beginplay prints initializing and waits 3 seconds then prints ready. on tick prints running. on endplay prints shutting down.", "output": "BLUEPRINT: BP_LifecycleDelayed\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Initializing\"]\nNODE n3: Delay [Duration=3.0]\nNODE n4: PrintString [InString=\"Ready\"]\nNODE n5: Event_Tick\nNODE n6: PrintString [InString=\"Running\"]\nNODE n7: Event_EndPlay\nNODE n8: PrintString [InString=\"Shutting Down\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_03:L03_20", "category": "delay_multi_event"}
{"instruction": "Create a Blueprint that on BeginPlay calls PrintString with text Initializing and uses a Delay node for 3 seconds then calls PrintString with text Ready. On Tick calls PrintString with text Running. On EndPlay calls PrintString with text Shutting Down.", "output": "BLUEPRINT: BP_LifecycleDelayed\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Initializing\"]\nNODE n3: Delay [Duration=3.0]\nNODE n4: PrintString [InString=\"Ready\"]\nNODE n5: Event_Tick\nNODE n6: PrintString [InString=\"Running\"]\nNODE n7: Event_EndPlay\nNODE n8: PrintString [InString=\"Shutting Down\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_03:L03_20", "category": "delay_multi_event"}
{"instruction": "Create a Blueprint that on BeginPlay adds an upward impulse of 1000 units to launch the actor into the air.", "output": "BLUEPRINT: BP_Launcher\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: AddImpulse [Impulse=(X=0,Y=0,Z=1000)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_04:L04_01", "category": "physics_impulse"}
{"instruction": "make a bp that on beginplay adds an upward impulse of 1000 units to launch the actor into the air.", "output": "BLUEPRINT: BP_Launcher\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: AddImpulse [Impulse=(X=0,Y=0,Z=1000)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_04:L04_01", "category": "physics_impulse"}
{"instruction": "Create a Blueprint that on Tick adds a constant forward force of 500 units to the actor.", "output": "BLUEPRINT: BP_ConstantPush\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorForwardVector\nNODE n3: MultiplyFloat [B=500.0]\nNODE n4: AddForce\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.A [Vector]\nDATA n3.ReturnValue -> n4.Force [Vector]", "source": "lesson:lesson_04:L04_02", "category": "physics_force"}
{"instruction": "make a bp that on tick adds a constant forward force of 500 units to the actor.", "output": "BLUEPRINT: BP_ConstantPush\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorForwardVector\nNODE n3: MultiplyFloat [B=500.0]\nNODE n4: AddForce\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.A [Vector]\nDATA n3.ReturnValue -> n4.Force [Vector]", "source": "lesson:lesson_04:L04_02", "category": "physics_force"}
{"instruction": "Create a Blueprint that pressing Interact toggles physics simulation on and off using SetSimulatePhysics.", "output": "BLUEPRINT: BP_PhysicsToggle\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetSimulatePhysics [Simulate=true]\nNODE n4: SetSimulatePhysics [Simulate=false]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_04:L04_03", "category": "physics_toggle"}
{"instruction": "make a bp that pressing interact toggles physics simulation on and off using setsimulatephysics.", "output": "BLUEPRINT: BP_PhysicsToggle\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetSimulatePhysics [Simulate=true]\nNODE n4: SetSimulatePhysics [Simulate=false]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_04:L04_03", "category": "physics_toggle"}
{"instruction": "Create a Blueprint that on Tick moves the actor forward by 2 units per frame using AddActorLocalOffset.", "output": "BLUEPRINT: BP_SlowMover\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalOffset [DeltaLocation=(X=2.0,Y=0,Z=0)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_04:L04_04", "category": "movement_offset"}
{"instruction": "make a bp that on tick moves the actor forward by 2 units per frame using addactorlocaloffset.", "output": "BLUEPRINT: BP_SlowMover\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalOffset [DeltaLocation=(X=2.0,Y=0,Z=0)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_04:L04_04", "category": "movement_offset"}
{"instruction": "Create a Blueprint that on overlap teleports the overlapping actor to location (0, 0, 500) using SetActorLocation.", "output": "BLUEPRINT: BP_Teleporter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: MakeVector [X=0, Y=0, Z=500]\nNODE n3: SetActorLocation\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n3.Target [Actor]\nDATA n2.ReturnValue -> n3.NewLocation [Vector]", "source": "lesson:lesson_04:L04_05", "category": "movement_teleport"}
{"instruction": "make a bp that on overlap teleports the overlapping actor to location (0, 0, 500) using setactorlocation.", "output": "BLUEPRINT: BP_Teleporter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: MakeVector [X=0, Y=0, Z=500]\nNODE n3: SetActorLocation\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n3.Target [Actor]\nDATA n2.ReturnValue -> n3.NewLocation [Vector]", "source": "lesson:lesson_04:L04_05", "category": "movement_teleport"}
{"instruction": "Create a Blueprint that when overlapped, enables physics on itself and adds an upward impulse of 2000.", "output": "BLUEPRINT: BP_OverlapLaunch\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: AddImpulse [Impulse=(X=0,Y=0,Z=2000)]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_04:L04_06", "category": "physics_overlap_launch"}
{"instruction": "make a bp that when overlapped, enables physics on itself and adds an upward impulse of 2000.", "output": "BLUEPRINT: BP_OverlapLaunch\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: AddImpulse [Impulse=(X=0,Y=0,Z=2000)]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_04:L04_06", "category": "physics_overlap_launch"}
{"instruction": "Create a Blueprint with a vector variable TargetLocation. On Tick, lerp the actor's position toward TargetLocation at alpha 0.05.", "output": "BLUEPRINT: BP_SmoothMover\nPARENT: Actor\nVAR TargetLocation: Vector\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: VariableGet [VarName=TargetLocation]\nNODE n4: Lerp [Alpha=0.05]\nNODE n5: SetActorLocation\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n4.A [Vector]\nDATA n3.Value -> n4.B [Vector]\nDATA n4.ReturnValue -> n5.NewLocation [Vector]", "source": "lesson:lesson_04:L04_07", "category": "movement_lerp"}
{"instruction": "bp with a vector variable targetlocation. on tick, lerp the actor's position toward targetlocation at alpha 0.05.", "output": "BLUEPRINT: BP_SmoothMover\nPARENT: Actor\nVAR TargetLocation: Vector\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: VariableGet [VarName=TargetLocation]\nNODE n4: Lerp [Alpha=0.05]\nNODE n5: SetActorLocation\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n4.A [Vector]\nDATA n3.Value -> n4.B [Vector]\nDATA n4.ReturnValue -> n5.NewLocation [Vector]", "source": "lesson:lesson_04:L04_07", "category": "movement_lerp"}
{"instruction": "Create a Blueprint that on Tick reads the MoveForward input axis value and moves the actor forward by that amount using AddActorLocalOffset.", "output": "BLUEPRINT: BP_InputMover\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetInputAxisValue [AxisName=\"MoveForward\"]\nNODE n3: MakeVector [Y=0, Z=0]\nNODE n4: AddActorLocalOffset\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.X [Float]\nDATA n3.ReturnValue -> n4.DeltaLocation [Vector]", "source": "lesson:lesson_04:L04_08", "category": "movement_input"}
{"instruction": "make a bp that on tick reads the moveforward input axis value and moves the actor forward by that amount using addactorlocaloffset.", "output": "BLUEPRINT: BP_InputMover\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetInputAxisValue [AxisName=\"MoveForward\"]\nNODE n3: MakeVector [Y=0, Z=0]\nNODE n4: AddActorLocalOffset\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.X [Float]\nDATA n3.ReturnValue -> n4.DeltaLocation [Vector]", "source": "lesson:lesson_04:L04_08", "category": "movement_input"}
{"instruction": "Create a Blueprint that on Hit adds an impulse in the opposite direction of the hit normal multiplied by 500.", "output": "BLUEPRINT: BP_Bouncer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Hit\nNODE n2: MultiplyFloat [B=-500.0]\nNODE n3: AddImpulse\nEXEC n1.Then -> n3.Execute\nDATA n1.HitNormal -> n2.A [Vector]\nDATA n2.ReturnValue -> n3.Impulse [Vector]", "source": "lesson:lesson_04:L04_09", "category": "physics_bounce"}
{"instruction": "make a bp that on hit adds an impulse in the opposite direction of the hit normal multiplied by 500.", "output": "BLUEPRINT: BP_Bouncer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Hit\nNODE n2: MultiplyFloat [B=-500.0]\nNODE n3: AddImpulse\nEXEC n1.Then -> n3.Execute\nDATA n1.HitNormal -> n2.A [Vector]\nDATA n2.ReturnValue -> n3.Impulse [Vector]", "source": "lesson:lesson_04:L04_09", "category": "physics_bounce"}
{"instruction": "Create a Blueprint with two vector variables PointA and PointB and a boolean AtA starting true. On Tick, if AtA is true move toward PointA, otherwise move toward PointB. When distance to target is less than 50, flip AtA.", "output": "BLUEPRINT: BP_Patrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR AtA: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=AtA]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=PointA]\nNODE n5: VariableGet [VarName=PointB]\nNODE n6: GetActorLocation\nNODE n7: Lerp [Alpha=0.02]\nNODE n8: Lerp [Alpha=0.02]\nNODE n9: SetActorLocation\nNODE n10: SetActorLocation\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n9.Execute\nEXEC n3.False -> n10.Execute\nDATA n6.ReturnValue -> n7.A [Vector]\nDATA n4.Value -> n7.B [Vector]\nDATA n7.ReturnValue -> n9.NewLocation [Vector]\nDATA n6.ReturnValue -> n8.A [Vector]\nDATA n5.Value -> n8.B [Vector]\nDATA n8.ReturnValue -> n10.NewLocation [Vector]", "source": "lesson:lesson_04:L04_10", "category": "movement_patrol"}
{"instruction": "bp with two vector variables pointa and pointb and a boolean ata starting true. on tick, if ata is true move toward pointa, otherwise move toward pointb. when distance to target is less than 50, flip ata.", "output": "BLUEPRINT: BP_Patrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR AtA: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=AtA]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=PointA]\nNODE n5: VariableGet [VarName=PointB]\nNODE n6: GetActorLocation\nNODE n7: Lerp [Alpha=0.02]\nNODE n8: Lerp [Alpha=0.02]\nNODE n9: SetActorLocation\nNODE n10: SetActorLocation\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n9.Execute\nEXEC n3.False -> n10.Execute\nDATA n6.ReturnValue -> n7.A [Vector]\nDATA n4.Value -> n7.B [Vector]\nDATA n7.ReturnValue -> n9.NewLocation [Vector]\nDATA n6.ReturnValue -> n8.A [Vector]\nDATA n5.Value -> n8.B [Vector]\nDATA n8.ReturnValue -> n10.NewLocation [Vector]", "source": "lesson:lesson_04:L04_10", "category": "movement_patrol"}
{"instruction": "Create a Blueprint that on BeginPlay waits 3 seconds, then enables physics simulation and prints Physics Enabled.", "output": "BLUEPRINT: BP_DelayedPhysics\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: SetSimulatePhysics [Simulate=true]\nNODE n4: PrintString [InString=\"Physics Enabled\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_04:L04_11", "category": "physics_delayed"}
{"instruction": "make a bp that on beginplay waits 3 seconds, then enables physics simulation and prints physics enabled.", "output": "BLUEPRINT: BP_DelayedPhysics\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: SetSimulatePhysics [Simulate=true]\nNODE n4: PrintString [InString=\"Physics Enabled\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_04:L04_11", "category": "physics_delayed"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Delay node for 3 seconds, then enables physics simulation and calls PrintString with text Physics Enabled.", "output": "BLUEPRINT: BP_DelayedPhysics\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: SetSimulatePhysics [Simulate=true]\nNODE n4: PrintString [InString=\"Physics Enabled\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_04:L04_11", "category": "physics_delayed"}
{"instruction": "Create a Blueprint that on Tick rotates 1 degree on Yaw and moves forward 1 unit. This makes the actor move in a circle.", "output": "BLUEPRINT: BP_CircleMover\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=1.0,Roll=0)]\nNODE n3: AddActorLocalOffset [DeltaLocation=(X=1.0,Y=0,Z=0)]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_04:L04_12", "category": "movement_rotate_and_move"}
{"instruction": "make a bp that on tick rotates 1 degree on yaw and moves forward 1 unit. this makes the actor move in a circle.", "output": "BLUEPRINT: BP_CircleMover\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=1.0,Roll=0)]\nNODE n3: AddActorLocalOffset [DeltaLocation=(X=1.0,Y=0,Z=0)]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_04:L04_12", "category": "movement_rotate_and_move"}
{"instruction": "Create a Blueprint with a boolean IsHeavy. On overlap, if IsHeavy add force of 5000 upward, else add force of 1000 upward.", "output": "BLUEPRINT: BP_ConditionalForce\nPARENT: Actor\nVAR IsHeavy: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=IsHeavy]\nNODE n3: Branch\nNODE n4: AddImpulse [Impulse=(X=0,Y=0,Z=5000)]\nNODE n5: AddImpulse [Impulse=(X=0,Y=0,Z=1000)]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_04:L04_13", "category": "physics_conditional_force"}
{"instruction": "bp with a boolean isheavy. on overlap, if isheavy add force of 5000 upward, else add force of 1000 upward.", "output": "BLUEPRINT: BP_ConditionalForce\nPARENT: Actor\nVAR IsHeavy: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=IsHeavy]\nNODE n3: Branch\nNODE n4: AddImpulse [Impulse=(X=0,Y=0,Z=5000)]\nNODE n5: AddImpulse [Impulse=(X=0,Y=0,Z=1000)]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_04:L04_13", "category": "physics_conditional_force"}
{"instruction": "Create a Blueprint with a float variable Speed set to 5.0. On Tick, multiply DeltaSeconds by Speed and move the actor forward by that amount.", "output": "BLUEPRINT: BP_VariableSpeed\nPARENT: Actor\nVAR Speed: Float = 5.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Speed]\nNODE n3: MultiplyFloat\nNODE n4: MakeVector [Y=0, Z=0]\nNODE n5: AddActorLocalOffset\nEXEC n1.Then -> n5.Execute\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.Value -> n3.B [Float]\nDATA n3.ReturnValue -> n4.X [Float]\nDATA n4.ReturnValue -> n5.DeltaLocation [Vector]", "source": "lesson:lesson_04:L04_14", "category": "movement_speed_variable"}
{"instruction": "bp with a float variable speed set to 5.0. on tick, multiply deltaseconds by speed and move the actor forward by that amount.", "output": "BLUEPRINT: BP_VariableSpeed\nPARENT: Actor\nVAR Speed: Float = 5.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Speed]\nNODE n3: MultiplyFloat\nNODE n4: MakeVector [Y=0, Z=0]\nNODE n5: AddActorLocalOffset\nEXEC n1.Then -> n5.Execute\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.Value -> n3.B [Float]\nDATA n3.ReturnValue -> n4.X [Float]\nDATA n4.ReturnValue -> n5.DeltaLocation [Vector]", "source": "lesson:lesson_04:L04_14", "category": "movement_speed_variable"}
{"instruction": "Create a Blueprint that on overlap adds a downward force of 3000 to the overlapping actor every tick while they remain overlapped. On end overlap, stop.", "output": "BLUEPRINT: BP_GravityZone\nPARENT: Actor\nVAR IsOverlapping: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableSet [VarName=IsOverlapping]\nNODE n3: Event_ActorEndOverlap\nNODE n4: VariableSet [VarName=IsOverlapping]\nEXEC n1.Then -> n2.Execute\nDATA true -> n2.Value [Bool]\nEXEC n3.Then -> n4.Execute\nDATA false -> n4.Value [Bool]", "source": "lesson:lesson_04:L04_15", "category": "physics_gravity_zone"}
{"instruction": "make a bp that on overlap adds a downward force of 3000 to the overlapping actor every tick while they remain overlapped. on end overlap, stop.", "output": "BLUEPRINT: BP_GravityZone\nPARENT: Actor\nVAR IsOverlapping: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableSet [VarName=IsOverlapping]\nNODE n3: Event_ActorEndOverlap\nNODE n4: VariableSet [VarName=IsOverlapping]\nEXEC n1.Then -> n2.Execute\nDATA true -> n2.Value [Bool]\nEXEC n3.Then -> n4.Execute\nDATA false -> n4.Value [Bool]", "source": "lesson:lesson_04:L04_15", "category": "physics_gravity_zone"}
{"instruction": "Create a Blueprint that on Tick gets the actor location. If the Z position is below 0, set it to 0 using SetActorLocation. Print Clamped when this happens.", "output": "BLUEPRINT: BP_FloorClamp\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: BreakVector\nNODE n4: LessThan [B=0.0]\nNODE n5: Branch\nNODE n6: MakeVector [Z=0.0]\nNODE n7: SetActorLocation\nNODE n8: PrintString [InString=\"Clamped\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.Input [Vector]\nDATA n3.Z -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n3.X -> n6.X [Float]\nDATA n3.Y -> n6.Y [Float]\nDATA n6.ReturnValue -> n7.NewLocation [Vector]\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_04:L04_16", "category": "movement_clamp"}
{"instruction": "make a bp that on tick gets the actor location. if the z position is below 0, set it to 0 using setactorlocation. print clamped when this happens.", "output": "BLUEPRINT: BP_FloorClamp\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: BreakVector\nNODE n4: LessThan [B=0.0]\nNODE n5: Branch\nNODE n6: MakeVector [Z=0.0]\nNODE n7: SetActorLocation\nNODE n8: PrintString [InString=\"Clamped\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.Input [Vector]\nDATA n3.Z -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n3.X -> n6.X [Float]\nDATA n3.Y -> n6.Y [Float]\nDATA n6.ReturnValue -> n7.NewLocation [Vector]\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_04:L04_16", "category": "movement_clamp"}
{"instruction": "Create a Blueprint where pressing Fire uses a MultiGate with 3 outputs. Output 0 adds impulse right, output 1 adds impulse left, output 2 adds impulse up.", "output": "BLUEPRINT: BP_MultiImpulse\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: MultiGate\nNODE n3: AddImpulse [Impulse=(X=0,Y=500,Z=0)]\nNODE n4: AddImpulse [Impulse=(X=0,Y=-500,Z=0)]\nNODE n5: AddImpulse [Impulse=(X=0,Y=0,Z=500)]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Out_0 -> n3.Execute\nEXEC n2.Out_1 -> n4.Execute\nEXEC n2.Out_2 -> n5.Execute", "source": "lesson:lesson_04:L04_17", "category": "physics_multigate"}
{"instruction": "Create a Blueprint that on Tick moves the actor up and down using a sine wave. Get game time, apply sine, multiply by 100, set the Z location.", "output": "BLUEPRINT: BP_SineWave\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetGameTimeInSeconds\nNODE n3: Sin\nNODE n4: MultiplyFloat [B=100.0]\nNODE n5: GetActorLocation\nNODE n6: BreakVector\nNODE n7: MakeVector\nNODE n8: SetActorLocation\nEXEC n1.Then -> n8.Execute\nDATA n2.ReturnValue -> n3.Input [Float]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n5.ReturnValue -> n6.Input [Vector]\nDATA n6.X -> n7.X [Float]\nDATA n6.Y -> n7.Y [Float]\nDATA n4.ReturnValue -> n7.Z [Float]\nDATA n7.ReturnValue -> n8.NewLocation [Vector]", "source": "lesson:lesson_04:L04_18", "category": "movement_sine_wave"}
{"instruction": "make a bp that on tick moves the actor up and down with sine wave. get game time, apply sine, multiply by 100, set the z location.", "output": "BLUEPRINT: BP_SineWave\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetGameTimeInSeconds\nNODE n3: Sin\nNODE n4: MultiplyFloat [B=100.0]\nNODE n5: GetActorLocation\nNODE n6: BreakVector\nNODE n7: MakeVector\nNODE n8: SetActorLocation\nEXEC n1.Then -> n8.Execute\nDATA n2.ReturnValue -> n3.Input [Float]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n5.ReturnValue -> n6.Input [Vector]\nDATA n6.X -> n7.X [Float]\nDATA n6.Y -> n7.Y [Float]\nDATA n4.ReturnValue -> n7.Z [Float]\nDATA n7.ReturnValue -> n8.NewLocation [Vector]", "source": "lesson:lesson_04:L04_18", "category": "movement_sine_wave"}
{"instruction": "Create a Blueprint that on BeginPlay enables physics and adds a forward impulse of 3000. After 5 seconds, destroy itself.", "output": "BLUEPRINT: BP_Projectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: GetActorForwardVector\nNODE n4: MultiplyFloat [B=3000.0]\nNODE n5: AddImpulse\nNODE n6: Delay [Duration=5.0]\nNODE n7: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.A [Vector]\nDATA n4.ReturnValue -> n5.Impulse [Vector]\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "source": "lesson:lesson_04:L04_19", "category": "physics_projectile"}
{"instruction": "make a bp that on beginplay enables physics and adds a forward impulse of 3000. after 5 seconds, destroy itself.", "output": "BLUEPRINT: BP_Projectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: GetActorForwardVector\nNODE n4: MultiplyFloat [B=3000.0]\nNODE n5: AddImpulse\nNODE n6: Delay [Duration=5.0]\nNODE n7: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.A [Vector]\nDATA n4.ReturnValue -> n5.Impulse [Vector]\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "source": "lesson:lesson_04:L04_19", "category": "physics_projectile"}
{"instruction": "Create a Blueprint with a float variable Speed at 100. On Tick, multiply Speed by DeltaSeconds, move actor forward by that amount. On pressing SpeedUp, add 50 to Speed.", "output": "BLUEPRINT: BP_Accelerator\nPARENT: Actor\nVAR Speed: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Speed]\nNODE n3: MultiplyFloat\nNODE n4: MakeVector [Y=0, Z=0]\nNODE n5: AddActorLocalOffset\nNODE n6: Event_InputAction [ActionName=\"SpeedUp\"]\nNODE n7: VariableGet [VarName=Speed]\nNODE n8: AddFloat [B=50.0]\nNODE n9: VariableSet [VarName=Speed]\nEXEC n1.Then -> n5.Execute\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.Value -> n3.B [Float]\nDATA n3.ReturnValue -> n4.X [Float]\nDATA n4.ReturnValue -> n5.DeltaLocation [Vector]\nEXEC n6.Pressed -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Value [Float]", "source": "lesson:lesson_04:L04_20", "category": "movement_scale_speed"}
{"instruction": "bp with a float variable speed at 100. on tick, multiply speed by deltaseconds, move actor forward by that amount. on pressing speedup, add 50 to speed.", "output": "BLUEPRINT: BP_Accelerator\nPARENT: Actor\nVAR Speed: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Speed]\nNODE n3: MultiplyFloat\nNODE n4: MakeVector [Y=0, Z=0]\nNODE n5: AddActorLocalOffset\nNODE n6: Event_InputAction [ActionName=\"SpeedUp\"]\nNODE n7: VariableGet [VarName=Speed]\nNODE n8: AddFloat [B=50.0]\nNODE n9: VariableSet [VarName=Speed]\nEXEC n1.Then -> n5.Execute\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.Value -> n3.B [Float]\nDATA n3.ReturnValue -> n4.X [Float]\nDATA n4.ReturnValue -> n5.DeltaLocation [Vector]\nEXEC n6.Pressed -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Value [Float]", "source": "lesson:lesson_04:L04_20", "category": "movement_scale_speed"}
{"instruction": "Create a Blueprint with an actor variable Target. On BeginPlay, check if Target is valid. If valid, print Target Found. If not, print No Target.", "output": "BLUEPRINT: BP_ValidCheck\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Target Found\"]\nNODE n6: PrintString [InString=\"No Target\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_05:L05_01", "category": "isvalid_basic"}
{"instruction": "bp with an actor variable target. on beginplay, check if target is valid. if valid, print target found. if not, print no target.", "output": "BLUEPRINT: BP_ValidCheck\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Target Found\"]\nNODE n6: PrintString [InString=\"No Target\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_05:L05_01", "category": "isvalid_basic"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If cast succeeds, print Player. If cast fails, print Not A Player.", "output": "BLUEPRINT: BP_SafeCast\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player\"]\nNODE n4: PrintString [InString=\"Not A Player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute", "source": "lesson:lesson_05:L05_02", "category": "isvalid_cast"}
{"instruction": "make a bp that on overlap casts to character. if cast succeeds, print player. if cast fails, print not a player.", "output": "BLUEPRINT: BP_SafeCast\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player\"]\nNODE n4: PrintString [InString=\"Not A Player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute", "source": "lesson:lesson_05:L05_02", "category": "isvalid_cast"}
{"instruction": "Create a Blueprint with an actor variable Target. On pressing Fire, check if Target is valid. If valid, destroy Target. If not, print Nothing To Destroy.", "output": "BLUEPRINT: BP_SafeDestroy\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: DestroyActor\nNODE n6: PrintString [InString=\"Nothing To Destroy\"]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.Value -> n5.Target [Actor]\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_05:L05_03", "category": "isvalid_destroy"}
{"instruction": "bp with an actor variable target. on pressing fire, check if target is valid. if valid, destroy target. if not, print nothing to destroy.", "output": "BLUEPRINT: BP_SafeDestroy\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: DestroyActor\nNODE n6: PrintString [InString=\"Nothing To Destroy\"]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.Value -> n5.Target [Actor]\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_05:L05_03", "category": "isvalid_destroy"}
{"instruction": "Create a Blueprint that on overlap, casts to Pawn. If the cast succeeds and the pawn is valid, get its location and print it.", "output": "BLUEPRINT: BP_PawnDetector\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetActorLocation\nNODE n6: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n2.AsCharacter -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n6.Execute\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_05:L05_04", "category": "isvalid_overlap_cast"}
{"instruction": "make a bp that on overlap, casts to pawn. if the cast succeeds and the pawn is valid, get its location and print it.", "output": "BLUEPRINT: BP_PawnDetector\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetActorLocation\nNODE n6: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n2.AsCharacter -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n6.Execute\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_05:L05_04", "category": "isvalid_overlap_cast"}
{"instruction": "Create a Blueprint that starts a timer on BeginPlay. The timer checks if a variable Target is valid. If valid, get distance to target and print it. If not valid, print Searching.", "output": "BLUEPRINT: BP_TargetTracker\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"CheckTarget\", Time=1.0, Looping=true]\nNODE n3: Event_Custom [EventName=CheckTarget]\nNODE n4: VariableGet [VarName=Target]\nNODE n5: IsValid\nNODE n6: Branch\nNODE n7: GetDistanceTo\nNODE n8: PrintString\nNODE n9: PrintString [InString=\"Searching\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.Input [Object]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n8.Execute\nDATA n4.Value -> n7.OtherActor [Actor]\nDATA n7.ReturnValue -> n8.InString [String]\nEXEC n6.False -> n9.Execute", "source": "lesson:lesson_05:L05_05", "category": "isvalid_timer_check"}
{"instruction": "make a bp that starts a timer on beginplay. the timer checks if a variable target is valid. if valid, get distance to target and print it. if not valid, print searching.", "output": "BLUEPRINT: BP_TargetTracker\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"CheckTarget\", Time=1.0, Looping=true]\nNODE n3: Event_Custom [EventName=CheckTarget]\nNODE n4: VariableGet [VarName=Target]\nNODE n5: IsValid\nNODE n6: Branch\nNODE n7: GetDistanceTo\nNODE n8: PrintString\nNODE n9: PrintString [InString=\"Searching\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.Input [Object]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n8.Execute\nDATA n4.Value -> n7.OtherActor [Actor]\nDATA n7.ReturnValue -> n8.InString [String]\nEXEC n6.False -> n9.Execute", "source": "lesson:lesson_05:L05_05", "category": "isvalid_timer_check"}
{"instruction": "Create a Blueprint with an array variable Items. On BeginPlay, loop through Items with ForEachLoop. For each item, check IsValid before printing its name.", "output": "BLUEPRINT: BP_SafeArrayLoop\nPARENT: Actor\nVAR Items: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Items]\nNODE n3: ForEachLoop\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: GetDisplayName\nNODE n7: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n3.ArrayElement -> n6.Target [Actor]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_05:L05_06", "category": "isvalid_array"}
{"instruction": "bp with an array variable items. on beginplay, loop through items with foreachloop. for each item, check isvalid before printing its name.", "output": "BLUEPRINT: BP_SafeArrayLoop\nPARENT: Actor\nVAR Items: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Items]\nNODE n3: ForEachLoop\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: GetDisplayName\nNODE n7: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n3.ArrayElement -> n6.Target [Actor]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_05:L05_06", "category": "isvalid_array"}
{"instruction": "Create a Blueprint that on pressing Fire spawns an actor. Check if spawn was valid. If yes print Spawned. If no print Spawn Failed.", "output": "BLUEPRINT: BP_SafeSpawn\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Spawned\"]\nNODE n7: PrintString [InString=\"Spawn Failed\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_05:L05_07", "category": "isvalid_spawn_check"}
{"instruction": "make a bp that on pressing fire spawns an actor. check if spawn was valid. if yes print spawned. if no print spawn failed.", "output": "BLUEPRINT: BP_SafeSpawn\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Spawned\"]\nNODE n7: PrintString [InString=\"Spawn Failed\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_05:L05_07", "category": "isvalid_spawn_check"}
{"instruction": "Create a Blueprint that on BeginPlay gets the player character. Check if valid. If valid, print the player's location.", "output": "BLUEPRINT: BP_FindPlayer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetActorLocation\nNODE n6: PrintString\nNODE n7: PrintString [InString=\"No Player\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n6.Execute\nDATA n2.ReturnValue -> n5.Target [Actor]\nDATA n5.ReturnValue -> n6.InString [String]\nEXEC n4.False -> n7.Execute", "source": "lesson:lesson_05:L05_08", "category": "isvalid_get_player"}
{"instruction": "make a bp that on beginplay gets the player character. check if valid. if valid, print the player's location.", "output": "BLUEPRINT: BP_FindPlayer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetActorLocation\nNODE n6: PrintString\nNODE n7: PrintString [InString=\"No Player\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n6.Execute\nDATA n2.ReturnValue -> n5.Target [Actor]\nDATA n5.ReturnValue -> n6.InString [String]\nEXEC n4.False -> n7.Execute", "source": "lesson:lesson_05:L05_08", "category": "isvalid_get_player"}
{"instruction": "Create a Blueprint with an actor variable Enemy. On Tick, check if Enemy is valid. If valid and distance less than 300, print Danger.", "output": "BLUEPRINT: BP_EnemyProximity\nPARENT: Actor\nVAR Enemy: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Enemy]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=300.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Danger\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.Value -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute", "source": "lesson:lesson_05:L05_09", "category": "isvalid_before_distance"}
{"instruction": "bp with an actor variable enemy. on tick, check if enemy is valid. if valid and distance less than 300, print danger.", "output": "BLUEPRINT: BP_EnemyProximity\nPARENT: Actor\nVAR Enemy: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Enemy]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=300.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Danger\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.Value -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute", "source": "lesson:lesson_05:L05_09", "category": "isvalid_before_distance"}
{"instruction": "Create a Blueprint that on overlap uses DoOnce, then casts to Character. On success print First Player Contact.", "output": "BLUEPRINT: BP_FirstContact\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: CastToCharacter\nNODE n4: PrintString [InString=\"First Player Contact\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nDATA n1.OtherActor -> n3.Object [Actor]\nEXEC n3.CastSucceeded -> n4.Execute", "source": "lesson:lesson_05:L05_10", "category": "isvalid_doonce_cast"}
{"instruction": "make a bp that on overlap uses doonce, then casts to character. on success print first player contact.", "output": "BLUEPRINT: BP_FirstContact\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: CastToCharacter\nNODE n4: PrintString [InString=\"First Player Contact\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nDATA n1.OtherActor -> n3.Object [Actor]\nEXEC n3.CastSucceeded -> n4.Execute", "source": "lesson:lesson_05:L05_10", "category": "isvalid_doonce_cast"}
{"instruction": "Create a Blueprint that on overlap casts the other actor to PlayerController. If success, print Controller Found.", "output": "BLUEPRINT: BP_ControllerCast\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToPlayerController\nNODE n3: PrintString [InString=\"Controller Found\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute", "source": "lesson:lesson_05:L05_11", "category": "cast_to_controller"}
{"instruction": "make a bp that on overlap casts the other actor to playercontroller. if success, print controller found.", "output": "BLUEPRINT: BP_ControllerCast\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToPlayerController\nNODE n3: PrintString [InString=\"Controller Found\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute", "source": "lesson:lesson_05:L05_11", "category": "cast_to_controller"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence. First output checks if variable A is valid. Second output checks if variable B is valid. Print the status of each.", "output": "BLUEPRINT: BP_MultiValidCheck\nPARENT: Actor\nVAR A: Actor = None\nVAR B: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: VariableGet [VarName=A]\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: PrintString [InString=\"A Valid\"]\nNODE n7: PrintString [InString=\"A Invalid\"]\nNODE n8: VariableGet [VarName=B]\nNODE n9: IsValid\nNODE n10: Branch\nNODE n11: PrintString [InString=\"B Valid\"]\nNODE n12: PrintString [InString=\"B Invalid\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n5.Execute\nDATA n3.Value -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute\nEXEC n2.Then_1 -> n10.Execute\nDATA n8.Value -> n9.Input [Object]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n11.Execute\nEXEC n10.False -> n12.Execute", "source": "lesson:lesson_05:L05_12", "category": "isvalid_sequence_checks"}
{"instruction": "make a bp that on beginplay uses a sequence. first output checks if variable a is valid. second output checks if variable b is valid. print the status of each.", "output": "BLUEPRINT: BP_MultiValidCheck\nPARENT: Actor\nVAR A: Actor = None\nVAR B: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: VariableGet [VarName=A]\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: PrintString [InString=\"A Valid\"]\nNODE n7: PrintString [InString=\"A Invalid\"]\nNODE n8: VariableGet [VarName=B]\nNODE n9: IsValid\nNODE n10: Branch\nNODE n11: PrintString [InString=\"B Valid\"]\nNODE n12: PrintString [InString=\"B Invalid\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n5.Execute\nDATA n3.Value -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute\nEXEC n2.Then_1 -> n10.Execute\nDATA n8.Value -> n9.Input [Object]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n11.Execute\nEXEC n10.False -> n12.Execute", "source": "lesson:lesson_05:L05_12", "category": "isvalid_sequence_checks"}
{"instruction": "Create a Blueprint that on BeginPlay spawns an actor, checks if valid, and if so stores it in a variable SpawnedActor.", "output": "BLUEPRINT: BP_SpawnAndStore\nPARENT: Actor\nVAR SpawnedActor: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Item]\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: VariableSet [VarName=SpawnedActor]\nNODE n7: PrintString [InString=\"Stored\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA n3.ReturnValue -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_05:L05_13", "category": "isvalid_set_after_spawn"}
{"instruction": "make a bp that on beginplay spawns an actor, checks if valid, and if so stores it in a variable spawnedactor.", "output": "BLUEPRINT: BP_SpawnAndStore\nPARENT: Actor\nVAR SpawnedActor: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Item]\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: VariableSet [VarName=SpawnedActor]\nNODE n7: PrintString [InString=\"Stored\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA n3.ReturnValue -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_05:L05_13", "category": "isvalid_set_after_spawn"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If cast succeeds, store the character in a variable LastPlayer and print Saved Player.", "output": "BLUEPRINT: BP_SavePlayer\nPARENT: Actor\nVAR LastPlayer: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableSet [VarName=LastPlayer]\nNODE n4: PrintString [InString=\"Saved Player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nDATA n2.AsCharacter -> n3.Value [Actor]\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_05:L05_14", "category": "cast_with_variable"}
{"instruction": "make a bp that on overlap casts to character. if cast succeeds, store the character in a variable lastplayer and print saved player.", "output": "BLUEPRINT: BP_SavePlayer\nPARENT: Actor\nVAR LastPlayer: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableSet [VarName=LastPlayer]\nNODE n4: PrintString [InString=\"Saved Player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nDATA n2.AsCharacter -> n3.Value [Actor]\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_05:L05_14", "category": "cast_with_variable"}
{"instruction": "Create a Blueprint that on pressing Fire checks if variable Target is valid. If valid, destroy Target and set Target to None. Print the result either way.", "output": "BLUEPRINT: BP_CleanDestroy\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: DestroyActor\nNODE n6: VariableSet [VarName=Target]\nNODE n7: PrintString [InString=\"Destroyed\"]\nNODE n8: PrintString [InString=\"No Target\"]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.Value -> n5.Target [Actor]\nEXEC n5.Then -> n6.Execute\nDATA None -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute\nEXEC n4.False -> n8.Execute", "source": "lesson:lesson_05:L05_15", "category": "isvalid_conditional_destroy"}
{"instruction": "make a bp that on pressing fire checks if variable target is valid. if valid, destroy target and set target to none. print the result either way.", "output": "BLUEPRINT: BP_CleanDestroy\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: DestroyActor\nNODE n6: VariableSet [VarName=Target]\nNODE n7: PrintString [InString=\"Destroyed\"]\nNODE n8: PrintString [InString=\"No Target\"]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.Value -> n5.Target [Actor]\nEXEC n5.Then -> n6.Execute\nDATA None -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute\nEXEC n4.False -> n8.Execute", "source": "lesson:lesson_05:L05_15", "category": "isvalid_conditional_destroy"}
{"instruction": "Create a Blueprint with a Gate. On BeginPlay check if variable Controller is valid. If valid, open the gate. On Tick, enter the gate. Gate exit prints Active.", "output": "BLUEPRINT: BP_ValidGate\nPARENT: Actor\nVAR Controller: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Controller]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: Gate\nNODE n6: Event_Tick\nNODE n7: PrintString [InString=\"Active\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Open\nEXEC n6.Then -> n5.Enter\nEXEC n5.Exit -> n7.Execute", "source": "lesson:lesson_05:L05_16", "category": "isvalid_gate_pattern"}
{"instruction": "bp with a gate. on beginplay check if variable controller is valid. if valid, open the gate. on tick, enter the gate. gate exit prints active.", "output": "BLUEPRINT: BP_ValidGate\nPARENT: Actor\nVAR Controller: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Controller]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: Gate\nNODE n6: Event_Tick\nNODE n7: PrintString [InString=\"Active\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Open\nEXEC n6.Then -> n5.Enter\nEXEC n5.Exit -> n7.Execute", "source": "lesson:lesson_05:L05_16", "category": "isvalid_gate_pattern"}
{"instruction": "Create a Blueprint with a Gate. On BeginPlay check if variable Controller is valid. If valid, open the gate. On Tick, enter the gate. Gate exit calls PrintString with text Active.", "output": "BLUEPRINT: BP_ValidGate\nPARENT: Actor\nVAR Controller: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Controller]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: Gate\nNODE n6: Event_Tick\nNODE n7: PrintString [InString=\"Active\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Open\nEXEC n6.Then -> n5.Enter\nEXEC n5.Exit -> n7.Execute", "source": "lesson:lesson_05:L05_16", "category": "isvalid_gate_pattern"}
{"instruction": "Create a Blueprint that on overlap first tries CastToCharacter. If that fails, try CastToPawn. If both fail, print Unknown Actor.", "output": "BLUEPRINT: BP_FallbackCast\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Character\"]\nNODE n4: CastToPawn\nNODE n5: PrintString [InString=\"Pawn\"]\nNODE n6: PrintString [InString=\"Unknown Actor\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute\nDATA n1.OtherActor -> n4.Object [Actor]\nEXEC n4.CastSucceeded -> n5.Execute\nEXEC n4.CastFailed -> n6.Execute", "source": "lesson:lesson_05:L05_17", "category": "isvalid_multi_cast"}
{"instruction": "make a bp that on overlap first tries casttocharacter. if that fails, try casttopawn. if both fail, print unknown actor.", "output": "BLUEPRINT: BP_FallbackCast\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Character\"]\nNODE n4: CastToPawn\nNODE n5: PrintString [InString=\"Pawn\"]\nNODE n6: PrintString [InString=\"Unknown Actor\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute\nDATA n1.OtherActor -> n4.Object [Actor]\nEXEC n4.CastSucceeded -> n5.Execute\nEXEC n4.CastFailed -> n6.Execute", "source": "lesson:lesson_05:L05_17", "category": "isvalid_multi_cast"}
{"instruction": "Create a Blueprint with an actor array Enemies. On pressing Fire, loop through Enemies, check each is valid, and destroy valid ones. Print how many were destroyed.", "output": "BLUEPRINT: BP_DestroyValid\nPARENT: Actor\nVAR Enemies: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Enemies]\nNODE n3: ForEachLoop\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: DestroyActor\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA n3.ArrayElement -> n6.Target [Actor]", "source": "lesson:lesson_05:L05_18", "category": "isvalid_foreach_destroy"}
{"instruction": "bp with an actor array enemies. on pressing fire, loop through enemies, check each is valid, and destroy valid ones. print how many were destroyed.", "output": "BLUEPRINT: BP_DestroyValid\nPARENT: Actor\nVAR Enemies: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Enemies]\nNODE n3: ForEachLoop\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: DestroyActor\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA n3.ArrayElement -> n6.Target [Actor]", "source": "lesson:lesson_05:L05_18", "category": "isvalid_foreach_destroy"}
{"instruction": "Create a Blueprint that on Tick gets the player pawn, checks if valid, then gets distance. If distance less than 500 and player is valid, print Alert.", "output": "BLUEPRINT: BP_SafeAlert\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=500.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Alert\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute", "source": "lesson:lesson_05:L05_19", "category": "isvalid_safe_distance"}
{"instruction": "make a bp that on tick gets the player pawn, checks if valid, then gets distance. if distance less than 500 and player is valid, print alert.", "output": "BLUEPRINT: BP_SafeAlert\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=500.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Alert\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute", "source": "lesson:lesson_05:L05_19", "category": "isvalid_safe_distance"}
{"instruction": "Create a Blueprint that on BeginPlay gets player pawn, validates it, casts to Character, and if all checks pass stores it in a variable Player and prints Connected.", "output": "BLUEPRINT: BP_FullValidation\nPARENT: Actor\nVAR Player: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: CastToCharacter\nNODE n6: VariableSet [VarName=Player]\nNODE n7: PrintString [InString=\"Connected\"]\nNODE n8: PrintString [InString=\"No Player Found\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.ReturnValue -> n5.Object [Actor]\nEXEC n5.CastSucceeded -> n6.Execute\nDATA n5.AsCharacter -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute\nEXEC n4.False -> n8.Execute", "source": "lesson:lesson_05:L05_20", "category": "isvalid_complete_pattern"}
{"instruction": "make a bp that on beginplay gets player pawn, validates it, casts to character, and if all checks pass stores it in a variable player and prints connected.", "output": "BLUEPRINT: BP_FullValidation\nPARENT: Actor\nVAR Player: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: CastToCharacter\nNODE n6: VariableSet [VarName=Player]\nNODE n7: PrintString [InString=\"Connected\"]\nNODE n8: PrintString [InString=\"No Player Found\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.ReturnValue -> n5.Object [Actor]\nEXEC n5.CastSucceeded -> n6.Execute\nDATA n5.AsCharacter -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute\nEXEC n4.False -> n8.Execute", "source": "lesson:lesson_05:L05_20", "category": "isvalid_complete_pattern"}
{"instruction": "Create a Blueprint that on BeginPlay gets player pawn, validates it, casts to Character, and if all checks pass stores it in a variable Player and calls PrintString with text Connected.", "output": "BLUEPRINT: BP_FullValidation\nPARENT: Actor\nVAR Player: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: CastToCharacter\nNODE n6: VariableSet [VarName=Player]\nNODE n7: PrintString [InString=\"Connected\"]\nNODE n8: PrintString [InString=\"No Player Found\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.ReturnValue -> n5.Object [Actor]\nEXEC n5.CastSucceeded -> n6.Execute\nDATA n5.AsCharacter -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute\nEXEC n4.False -> n8.Execute", "source": "lesson:lesson_05:L05_20", "category": "isvalid_complete_pattern"}
{"instruction": "Create a Blueprint that on BeginPlay runs a ForLoop from 0 to 9 and prints the index each iteration.", "output": "BLUEPRINT: BP_ForLoopPrint\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]", "source": "lesson:lesson_06:L06_01", "category": "forloop_basic"}
{"instruction": "make a bp that on beginplay runs a forloop from 0 to 9 and prints the index each iteration.", "output": "BLUEPRINT: BP_ForLoopPrint\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]", "source": "lesson:lesson_06:L06_01", "category": "forloop_basic"}
{"instruction": "Create a Blueprint that on BeginPlay runs a ForLoop from 0 to 9 and calls PrintString with text the index each iteration.", "output": "BLUEPRINT: BP_ForLoopPrint\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]", "source": "lesson:lesson_06:L06_01", "category": "forloop_basic"}
{"instruction": "Create a Blueprint that on BeginPlay uses a ForLoop 0 to 4 to spawn 5 actors in a row, each 200 units apart on the X axis.", "output": "BLUEPRINT: BP_RowSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=4]\nNODE n3: MultiplyFloat [B=200.0]\nNODE n4: MakeVector [Y=0, Z=0]\nNODE n5: SpawnActorFromClass [ActorClass=BP_Item]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n5.Execute\nDATA n2.Index -> n3.A [Float]\nDATA n3.ReturnValue -> n4.X [Float]\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]", "source": "lesson:lesson_06:L06_02", "category": "forloop_spawn"}
{"instruction": "make a bp that on beginplay uses a forloop 0 to 4 to spawn 5 actors in a row, each 200 units apart on the x axis.", "output": "BLUEPRINT: BP_RowSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=4]\nNODE n3: MultiplyFloat [B=200.0]\nNODE n4: MakeVector [Y=0, Z=0]\nNODE n5: SpawnActorFromClass [ActorClass=BP_Item]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n5.Execute\nDATA n2.Index -> n3.A [Float]\nDATA n3.ReturnValue -> n4.X [Float]\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]", "source": "lesson:lesson_06:L06_02", "category": "forloop_spawn"}
{"instruction": "Create a Blueprint with integer Total at 0. On BeginPlay use ForLoop 1 to 10 to sum all numbers. After completion print the total.", "output": "BLUEPRINT: BP_SumLoop\nPARENT: Actor\nVAR Total: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=10]\nNODE n3: VariableGet [VarName=Total]\nNODE n4: AddInt\nNODE n5: VariableSet [VarName=Total]\nNODE n6: VariableGet [VarName=Total]\nNODE n7: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n5.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n2.Index -> n4.B [Int]\nDATA n4.ReturnValue -> n5.Value [Int]\nEXEC n2.Completed -> n7.Execute\nDATA n6.Value -> n7.InString [String]", "source": "lesson:lesson_06:L06_03", "category": "forloop_sum"}
{"instruction": "bp with integer total at 0. on beginplay use forloop 1 to 10 to sum all numbers. after completion print the total.", "output": "BLUEPRINT: BP_SumLoop\nPARENT: Actor\nVAR Total: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=10]\nNODE n3: VariableGet [VarName=Total]\nNODE n4: AddInt\nNODE n5: VariableSet [VarName=Total]\nNODE n6: VariableGet [VarName=Total]\nNODE n7: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n5.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n2.Index -> n4.B [Int]\nDATA n4.ReturnValue -> n5.Value [Int]\nEXEC n2.Completed -> n7.Execute\nDATA n6.Value -> n7.InString [String]", "source": "lesson:lesson_06:L06_03", "category": "forloop_sum"}
{"instruction": "Create a Blueprint with integer Count at 0. On BeginPlay use a WhileLoop while Count less than 5 to increment and print Count.", "output": "BLUEPRINT: BP_WhileCount\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Count]\nNODE n4: LessThan [B=5]\nNODE n5: VariableGet [VarName=Count]\nNODE n6: AddInt [B=1]\nNODE n7: VariableSet [VarName=Count]\nNODE n8: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n7.Execute\nDATA n5.Value -> n6.A [Int]\nDATA n6.ReturnValue -> n7.Value [Int]\nEXEC n7.Then -> n8.Execute\nDATA n7.Value -> n8.InString [String]", "source": "lesson:lesson_06:L06_04", "category": "whileloop_basic"}
{"instruction": "bp with integer count at 0. on beginplay use a whileloop while count less than 5 to increment and print count.", "output": "BLUEPRINT: BP_WhileCount\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Count]\nNODE n4: LessThan [B=5]\nNODE n5: VariableGet [VarName=Count]\nNODE n6: AddInt [B=1]\nNODE n7: VariableSet [VarName=Count]\nNODE n8: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n7.Execute\nDATA n5.Value -> n6.A [Int]\nDATA n6.ReturnValue -> n7.Value [Int]\nEXEC n7.Then -> n8.Execute\nDATA n7.Value -> n8.InString [String]", "source": "lesson:lesson_06:L06_04", "category": "whileloop_basic"}
{"instruction": "Create a Blueprint that loops 0 to 19. For each index check if even using modulo. If even print the index.", "output": "BLUEPRINT: BP_EvenPrinter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=19]\nNODE n3: Modulo [B=2]\nNODE n4: EqualEqual [B=0]\nNODE n5: Branch\nNODE n6: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n5.Execute\nDATA n2.Index -> n3.A [Int]\nDATA n3.ReturnValue -> n4.A [Int]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA n2.Index -> n6.InString [String]", "source": "lesson:lesson_06:L06_05", "category": "forloop_even"}
{"instruction": "make a bp that loops 0 to 19. for each index check if even using modulo. if even print the index.", "output": "BLUEPRINT: BP_EvenPrinter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=19]\nNODE n3: Modulo [B=2]\nNODE n4: EqualEqual [B=0]\nNODE n5: Branch\nNODE n6: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n5.Execute\nDATA n2.Index -> n3.A [Int]\nDATA n3.ReturnValue -> n4.A [Int]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA n2.Index -> n6.InString [String]", "source": "lesson:lesson_06:L06_05", "category": "forloop_even"}
{"instruction": "Create a Blueprint with actor array Targets. On pressing Fire, ForEachLoop destroys all targets then prints All Destroyed.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: DestroyActor\nNODE n5: PrintString [InString=\"All Destroyed\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]\nEXEC n3.Completed -> n5.Execute", "source": "lesson:lesson_06:L06_06", "category": "foreach_destroy"}
{"instruction": "bp with actor array targets. on pressing fire, foreachloop destroys all targets then prints all destroyed.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: DestroyActor\nNODE n5: PrintString [InString=\"All Destroyed\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]\nEXEC n3.Completed -> n5.Execute", "source": "lesson:lesson_06:L06_06", "category": "foreach_destroy"}
{"instruction": "Create a Blueprint with actor array Targets. On pressing Fire, ForEachLoop destroys all targets then calls PrintString with text All Destroyed.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: DestroyActor\nNODE n5: PrintString [InString=\"All Destroyed\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]\nEXEC n3.Completed -> n5.Execute", "source": "lesson:lesson_06:L06_06", "category": "foreach_destroy"}
{"instruction": "Create a Blueprint that on BeginPlay uses two nested ForLoops 0 to 2 to spawn actors in a 3x3 grid with 100 unit spacing.", "output": "BLUEPRINT: BP_GridSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=2]\nNODE n3: ForLoop [FirstIndex=0, LastIndex=2]\nNODE n4: MultiplyFloat [B=100.0]\nNODE n5: MultiplyFloat [B=100.0]\nNODE n6: MakeVector [Z=0]\nNODE n7: SpawnActorFromClass [ActorClass=BP_Tile]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nEXEC n3.LoopBody -> n7.Execute\nDATA n2.Index -> n4.A [Float]\nDATA n3.Index -> n5.A [Float]\nDATA n4.ReturnValue -> n6.X [Float]\nDATA n5.ReturnValue -> n6.Y [Float]\nDATA n6.ReturnValue -> n7.SpawnTransform [Transform]", "source": "lesson:lesson_06:L06_07", "category": "forloop_grid"}
{"instruction": "make a bp that on beginplay uses two nested forloops 0 to 2 to spawn actors in a 3x3 grid with 100 unit spacing.", "output": "BLUEPRINT: BP_GridSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=2]\nNODE n3: ForLoop [FirstIndex=0, LastIndex=2]\nNODE n4: MultiplyFloat [B=100.0]\nNODE n5: MultiplyFloat [B=100.0]\nNODE n6: MakeVector [Z=0]\nNODE n7: SpawnActorFromClass [ActorClass=BP_Tile]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nEXEC n3.LoopBody -> n7.Execute\nDATA n2.Index -> n4.A [Float]\nDATA n3.Index -> n5.A [Float]\nDATA n4.ReturnValue -> n6.X [Float]\nDATA n5.ReturnValue -> n6.Y [Float]\nDATA n6.ReturnValue -> n7.SpawnTransform [Transform]", "source": "lesson:lesson_06:L06_07", "category": "forloop_grid"}
{"instruction": "Create a Blueprint that on BeginPlay runs ForLoop 1 to 3 printing each index. After the loop waits 2 seconds then prints Done.", "output": "BLUEPRINT: BP_LoopThenWait\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=3]\nNODE n3: PrintString\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_06:L06_08", "category": "forloop_delay_after"}
{"instruction": "make a bp that on beginplay runs forloop 1 to 3 printing each index. after the loop waits 2 seconds then prints done.", "output": "BLUEPRINT: BP_LoopThenWait\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=3]\nNODE n3: PrintString\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_06:L06_08", "category": "forloop_delay_after"}
{"instruction": "Create a Blueprint that on BeginPlay runs ForLoop 1 to 3 printing each index. After the loop uses a Delay node for 2 seconds then calls PrintString with text Done.", "output": "BLUEPRINT: BP_LoopThenWait\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=3]\nNODE n3: PrintString\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_06:L06_08", "category": "forloop_delay_after"}
{"instruction": "Create a Blueprint with actor array AllActors. On BeginPlay loop through all. For each check distance less than 500 and print name of nearby ones.", "output": "BLUEPRINT: BP_NearbyFilter\nPARENT: Actor\nVAR AllActors: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=AllActors]\nNODE n3: ForEachLoop\nNODE n4: GetDistanceTo\nNODE n5: LessThan [B=500.0]\nNODE n6: Branch\nNODE n7: GetDisplayName\nNODE n8: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n6.Execute\nDATA n3.ArrayElement -> n4.OtherActor [Actor]\nDATA n4.ReturnValue -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n8.Execute\nDATA n3.ArrayElement -> n7.Target [Actor]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:lesson_06:L06_09", "category": "foreach_filter"}
{"instruction": "bp with actor array allactors. on beginplay loop through all. for each check distance less than 500 and print name of nearby ones.", "output": "BLUEPRINT: BP_NearbyFilter\nPARENT: Actor\nVAR AllActors: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=AllActors]\nNODE n3: ForEachLoop\nNODE n4: GetDistanceTo\nNODE n5: LessThan [B=500.0]\nNODE n6: Branch\nNODE n7: GetDisplayName\nNODE n8: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n6.Execute\nDATA n3.ArrayElement -> n4.OtherActor [Actor]\nDATA n4.ReturnValue -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n8.Execute\nDATA n3.ArrayElement -> n7.Target [Actor]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:lesson_06:L06_09", "category": "foreach_filter"}
{"instruction": "Create a Blueprint that on BeginPlay uses ForLoop from 10 down to 1 printing each number. After loop prints Liftoff.", "output": "BLUEPRINT: BP_Countdown\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=10, LastIndex=1]\nNODE n3: PrintString\nNODE n4: PrintString [InString=\"Liftoff\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute", "source": "lesson:lesson_06:L06_10", "category": "forloop_countdown"}
{"instruction": "make a bp that on beginplay uses forloop from 10 down to 1 printing each number. after loop prints liftoff.", "output": "BLUEPRINT: BP_Countdown\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=10, LastIndex=1]\nNODE n3: PrintString\nNODE n4: PrintString [InString=\"Liftoff\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute", "source": "lesson:lesson_06:L06_10", "category": "forloop_countdown"}
{"instruction": "Create a Blueprint that on BeginPlay uses ForLoop from 10 down to 1 printing each number. After loop calls PrintString with text Liftoff.", "output": "BLUEPRINT: BP_Countdown\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=10, LastIndex=1]\nNODE n3: PrintString\nNODE n4: PrintString [InString=\"Liftoff\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute", "source": "lesson:lesson_06:L06_10", "category": "forloop_countdown"}
{"instruction": "Create a Blueprint with actor array Lights. On pressing Toggle loop through all and call ToggleVisibility on each.", "output": "BLUEPRINT: BP_ToggleLights\nPARENT: Actor\nVAR Lights: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Toggle\"]\nNODE n2: VariableGet [VarName=Lights]\nNODE n3: ForEachLoop\nNODE n4: ToggleVisibility\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]", "source": "lesson:lesson_06:L06_11", "category": "foreach_toggle_vis"}
{"instruction": "bp with actor array lights. on pressing toggle loop through all and call togglevisibility on each.", "output": "BLUEPRINT: BP_ToggleLights\nPARENT: Actor\nVAR Lights: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Toggle\"]\nNODE n2: VariableGet [VarName=Lights]\nNODE n3: ForEachLoop\nNODE n4: ToggleVisibility\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]", "source": "lesson:lesson_06:L06_11", "category": "foreach_toggle_vis"}
{"instruction": "Create a Blueprint with float Value at 1000. Use WhileLoop to keep halving Value while greater than 1. Print the final value.", "output": "BLUEPRINT: BP_HalveLoop\nPARENT: Actor\nVAR Value: Float = 1000.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Value]\nNODE n4: GreaterThan [B=1.0]\nNODE n5: VariableGet [VarName=Value]\nNODE n6: DivideFloat [B=2.0]\nNODE n7: VariableSet [VarName=Value]\nNODE n8: VariableGet [VarName=Value]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n2.Completed -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:lesson_06:L06_12", "category": "whileloop_halving"}
{"instruction": "bp with float value at 1000. use whileloop to keep halving value while greater than 1. print the final value.", "output": "BLUEPRINT: BP_HalveLoop\nPARENT: Actor\nVAR Value: Float = 1000.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Value]\nNODE n4: GreaterThan [B=1.0]\nNODE n5: VariableGet [VarName=Value]\nNODE n6: DivideFloat [B=2.0]\nNODE n7: VariableSet [VarName=Value]\nNODE n8: VariableGet [VarName=Value]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n2.Completed -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:lesson_06:L06_12", "category": "whileloop_halving"}
{"instruction": "Create a Blueprint that on BeginPlay loops 10 times. Each iteration generates random X and Y within 1000 units and spawns an actor there.", "output": "BLUEPRINT: BP_RandomSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: RandomFloat [Min=-1000, Max=1000]\nNODE n4: RandomFloat [Min=-1000, Max=1000]\nNODE n5: MakeVector [Z=0]\nNODE n6: SpawnActorFromClass [ActorClass=BP_Item]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n6.Execute\nDATA n3.ReturnValue -> n5.X [Float]\nDATA n4.ReturnValue -> n5.Y [Float]\nDATA n5.ReturnValue -> n6.SpawnTransform [Transform]", "source": "lesson:lesson_06:L06_13", "category": "forloop_random_spawn"}
{"instruction": "make a bp that on beginplay loops 10 times. each iteration generates random x and y within 1000 units and spawns an actor there.", "output": "BLUEPRINT: BP_RandomSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: RandomFloat [Min=-1000, Max=1000]\nNODE n4: RandomFloat [Min=-1000, Max=1000]\nNODE n5: MakeVector [Z=0]\nNODE n6: SpawnActorFromClass [ActorClass=BP_Item]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n6.Execute\nDATA n3.ReturnValue -> n5.X [Float]\nDATA n4.ReturnValue -> n5.Y [Float]\nDATA n5.ReturnValue -> n6.SpawnTransform [Transform]", "source": "lesson:lesson_06:L06_13", "category": "forloop_random_spawn"}
{"instruction": "Create a Blueprint with float array Values and float MaxVal at 0. Loop through Values tracking maximum. After loop print max.", "output": "BLUEPRINT: BP_FindMax\nPARENT: Actor\nVAR Values: Array<Float>\nVAR MaxVal: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Values]\nNODE n3: ForEachLoop\nNODE n4: VariableGet [VarName=MaxVal]\nNODE n5: Max\nNODE n6: VariableSet [VarName=MaxVal]\nNODE n7: VariableGet [VarName=MaxVal]\nNODE n8: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n6.Execute\nDATA n3.ArrayElement -> n5.A [Float]\nDATA n4.Value -> n5.B [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n3.Completed -> n8.Execute\nDATA n7.Value -> n8.InString [String]", "source": "lesson:lesson_06:L06_14", "category": "foreach_max"}
{"instruction": "bp with float array values and float maxval at 0. loop through values tracking maximum. after loop print max.", "output": "BLUEPRINT: BP_FindMax\nPARENT: Actor\nVAR Values: Array<Float>\nVAR MaxVal: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Values]\nNODE n3: ForEachLoop\nNODE n4: VariableGet [VarName=MaxVal]\nNODE n5: Max\nNODE n6: VariableSet [VarName=MaxVal]\nNODE n7: VariableGet [VarName=MaxVal]\nNODE n8: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n6.Execute\nDATA n3.ArrayElement -> n5.A [Float]\nDATA n4.Value -> n5.B [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n3.Completed -> n8.Execute\nDATA n7.Value -> n8.InString [String]", "source": "lesson:lesson_06:L06_14", "category": "foreach_max"}
{"instruction": "Create a Blueprint with float Health at 100. Use WhileLoop while Health > 0. Each iteration subtract random 1-20 and print Health.", "output": "BLUEPRINT: BP_DamageLoop\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Health]\nNODE n4: GreaterThan [B=0.0]\nNODE n5: VariableGet [VarName=Health]\nNODE n6: RandomFloat [Min=1, Max=20]\nNODE n7: SubtractFloat\nNODE n8: VariableSet [VarName=Health]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n8.Execute\nDATA n5.Value -> n7.A [Float]\nDATA n6.ReturnValue -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:lesson_06:L06_15", "category": "whileloop_damage"}
{"instruction": "bp with float health at 100. use whileloop while health > 0. each iteration subtract random 1-20 and print health.", "output": "BLUEPRINT: BP_DamageLoop\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Health]\nNODE n4: GreaterThan [B=0.0]\nNODE n5: VariableGet [VarName=Health]\nNODE n6: RandomFloat [Min=1, Max=20]\nNODE n7: SubtractFloat\nNODE n8: VariableSet [VarName=Health]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n8.Execute\nDATA n5.Value -> n7.A [Float]\nDATA n6.ReturnValue -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:lesson_06:L06_15", "category": "whileloop_damage"}
{"instruction": "Create a Blueprint with actor array Targets. Loop through finding the closest one. Print the closest actor name.", "output": "BLUEPRINT: BP_FindClosest\nPARENT: Actor\nVAR Targets: Array<Actor>\nVAR ClosestDist: Float = 999999.0\nVAR ClosestActor: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: GetDistanceTo\nNODE n5: VariableGet [VarName=ClosestDist]\nNODE n6: LessThan\nNODE n7: Branch\nNODE n8: VariableSet [VarName=ClosestDist]\nNODE n9: VariableSet [VarName=ClosestActor]\nNODE n10: VariableGet [VarName=ClosestActor]\nNODE n11: GetDisplayName\nNODE n12: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n7.Execute\nDATA n3.ArrayElement -> n4.OtherActor [Actor]\nDATA n4.ReturnValue -> n6.A [Float]\nDATA n5.Value -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nDATA n4.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n3.ArrayElement -> n9.Value [Actor]\nEXEC n3.Completed -> n12.Execute\nDATA n10.Value -> n11.Target [Actor]\nDATA n11.ReturnValue -> n12.InString [String]", "source": "lesson:lesson_06:L06_16", "category": "foreach_closest"}
{"instruction": "bp with actor array targets. loop through finding the closest one. print the closest actor name.", "output": "BLUEPRINT: BP_FindClosest\nPARENT: Actor\nVAR Targets: Array<Actor>\nVAR ClosestDist: Float = 999999.0\nVAR ClosestActor: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: GetDistanceTo\nNODE n5: VariableGet [VarName=ClosestDist]\nNODE n6: LessThan\nNODE n7: Branch\nNODE n8: VariableSet [VarName=ClosestDist]\nNODE n9: VariableSet [VarName=ClosestActor]\nNODE n10: VariableGet [VarName=ClosestActor]\nNODE n11: GetDisplayName\nNODE n12: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n7.Execute\nDATA n3.ArrayElement -> n4.OtherActor [Actor]\nDATA n4.ReturnValue -> n6.A [Float]\nDATA n5.Value -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nDATA n4.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n3.ArrayElement -> n9.Value [Actor]\nEXEC n3.Completed -> n12.Execute\nDATA n10.Value -> n11.Target [Actor]\nDATA n11.ReturnValue -> n12.InString [String]", "source": "lesson:lesson_06:L06_16", "category": "foreach_closest"}
{"instruction": "Create a Blueprint that on BeginPlay uses Sequence. First output runs ForLoop 0-4 printing each. Second output prints Loop Done.", "output": "BLUEPRINT: BP_SequenceLoop\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: ForLoop [FirstIndex=0, LastIndex=4]\nNODE n4: PrintString\nNODE n5: PrintString [InString=\"Loop Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.Index -> n4.InString [String]\nEXEC n2.Then_1 -> n5.Execute", "source": "lesson:lesson_06:L06_17", "category": "forloop_sequence"}
{"instruction": "make a bp that on beginplay uses sequence. first output runs forloop 0-4 printing each. second output prints loop done.", "output": "BLUEPRINT: BP_SequenceLoop\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: ForLoop [FirstIndex=0, LastIndex=4]\nNODE n4: PrintString\nNODE n5: PrintString [InString=\"Loop Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.Index -> n4.InString [String]\nEXEC n2.Then_1 -> n5.Execute", "source": "lesson:lesson_06:L06_17", "category": "forloop_sequence"}
{"instruction": "Create a Blueprint that on BeginPlay uses Sequence. First output runs ForLoop 0-4 printing each. Second output calls PrintString with text Loop Done.", "output": "BLUEPRINT: BP_SequenceLoop\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: ForLoop [FirstIndex=0, LastIndex=4]\nNODE n4: PrintString\nNODE n5: PrintString [InString=\"Loop Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.Index -> n4.InString [String]\nEXEC n2.Then_1 -> n5.Execute", "source": "lesson:lesson_06:L06_17", "category": "forloop_sequence"}
{"instruction": "Create a Blueprint with string array Messages. On overlap use DoOnce then ForEachLoop to print all messages once.", "output": "BLUEPRINT: BP_OneTimeMessages\nPARENT: Actor\nVAR Messages: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: VariableGet [VarName=Messages]\nNODE n4: ForEachLoop\nNODE n5: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n4.Execute\nDATA n3.Value -> n4.Array [Array]\nEXEC n4.LoopBody -> n5.Execute\nDATA n4.ArrayElement -> n5.InString [String]", "source": "lesson:lesson_06:L06_18", "category": "foreach_doonce"}
{"instruction": "bp with string array messages. on overlap use doonce then foreachloop to print all messages once.", "output": "BLUEPRINT: BP_OneTimeMessages\nPARENT: Actor\nVAR Messages: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: VariableGet [VarName=Messages]\nNODE n4: ForEachLoop\nNODE n5: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n4.Execute\nDATA n3.Value -> n4.Array [Array]\nEXEC n4.LoopBody -> n5.Execute\nDATA n4.ArrayElement -> n5.InString [String]", "source": "lesson:lesson_06:L06_18", "category": "foreach_doonce"}
{"instruction": "Create a Blueprint with actor array Enemies. On BeginPlay loop through enemies and print each one's display name.", "output": "BLUEPRINT: BP_ListEnemies\nPARENT: Actor\nVAR Enemies: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Enemies]\nNODE n3: ForEachLoop\nNODE n4: GetDisplayName\nNODE n5: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_06:L06_19", "category": "forloop_health_bars"}
{"instruction": "bp with actor array enemies. on beginplay loop through enemies and print each one's display name.", "output": "BLUEPRINT: BP_ListEnemies\nPARENT: Actor\nVAR Enemies: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Enemies]\nNODE n3: ForEachLoop\nNODE n4: GetDisplayName\nNODE n5: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_06:L06_19", "category": "forloop_health_bars"}
{"instruction": "Create a Blueprint that on BeginPlay runs ForLoop 0 to 9. Prints the index. After completion prints Total: 10 and destroys self.", "output": "BLUEPRINT: BP_CountAndDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: PrintString\nNODE n4: PrintString [InString=\"Total: 10\"]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute", "source": "lesson:lesson_06:L06_20", "category": "forloop_complete"}
{"instruction": "make a bp that on beginplay runs forloop 0 to 9. prints the index. after completion prints total: 10 and destroys self.", "output": "BLUEPRINT: BP_CountAndDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: PrintString\nNODE n4: PrintString [InString=\"Total: 10\"]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute", "source": "lesson:lesson_06:L06_20", "category": "forloop_complete"}
{"instruction": "Create a Blueprint that on BeginPlay runs ForLoop 0 to 9. Prints the index. After completion calls PrintString with text Total: 10 and destroys self.", "output": "BLUEPRINT: BP_CountAndDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: PrintString\nNODE n4: PrintString [InString=\"Total: 10\"]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute", "source": "lesson:lesson_06:L06_20", "category": "forloop_complete"}
{"instruction": "Create a Blueprint with a string variable PlayerName set to Hero. On BeginPlay print Welcome followed by the player name.", "output": "BLUEPRINT: BP_WelcomeName\nPARENT: Actor\nVAR PlayerName: String = \"Hero\"\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=PlayerName]\nNODE n3: Concatenate [A=\"Welcome \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_01", "category": "string_concat"}
{"instruction": "bp with a string variable playername set to hero. on beginplay print welcome followed by the player name.", "output": "BLUEPRINT: BP_WelcomeName\nPARENT: Actor\nVAR PlayerName: String = \"Hero\"\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=PlayerName]\nNODE n3: Concatenate [A=\"Welcome \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_01", "category": "string_concat"}
{"instruction": "Create a Blueprint with an integer variable Score at 0. On overlap add 10 to Score and print Score: followed by the value.", "output": "BLUEPRINT: BP_ScoreDisplay\nPARENT: Actor\nVAR Score: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=Score]\nNODE n3: AddInt [B=10]\nNODE n4: VariableSet [VarName=Score]\nNODE n5: Concatenate [A=\"Score: \"]\nNODE n6: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_02", "category": "string_score"}
{"instruction": "bp with an int var score at 0. on overlap add 10 to score and print score: followed by the value.", "output": "BLUEPRINT: BP_ScoreDisplay\nPARENT: Actor\nVAR Score: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=Score]\nNODE n3: AddInt [B=10]\nNODE n4: VariableSet [VarName=Score]\nNODE n5: Concatenate [A=\"Score: \"]\nNODE n6: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_02", "category": "string_score"}
{"instruction": "Create a Blueprint with float Health at 100. On AnyDamage subtract damage, print Health: followed by the new value.", "output": "BLUEPRINT: BP_HealthDisplay\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: VariableSet [VarName=Health]\nNODE n5: Concatenate [A=\"Health: \"]\nNODE n6: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_03", "category": "string_health"}
{"instruction": "bp with float health at 100. on anydamage subtract damage, print health: followed by the new value.", "output": "BLUEPRINT: BP_HealthDisplay\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: VariableSet [VarName=Health]\nNODE n5: Concatenate [A=\"Health: \"]\nNODE n6: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_03", "category": "string_health"}
{"instruction": "Create a Blueprint that on Tick gets actor location, breaks it into components, and prints the vector as a string.", "output": "BLUEPRINT: BP_LocationDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.InString [String]", "source": "lesson:lesson_07:L07_04", "category": "debug_location"}
{"instruction": "make a bp that on tick gets actor location, breaks it into components, and prints the vector as a string.", "output": "BLUEPRINT: BP_LocationDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.InString [String]", "source": "lesson:lesson_07:L07_04", "category": "debug_location"}
{"instruction": "Create a Blueprint that on Tick gets actor location, breaks it into components, and calls PrintString with text the vector as a string.", "output": "BLUEPRINT: BP_LocationDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.InString [String]", "source": "lesson:lesson_07:L07_04", "category": "debug_location"}
{"instruction": "Create a Blueprint that on overlap gets the display name of the overlapping actor and prints Overlapped by: followed by the name.", "output": "BLUEPRINT: BP_NameOverlap\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetDisplayName\nNODE n3: Concatenate [A=\"Overlapped by: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_05", "category": "string_overlap_name"}
{"instruction": "make a bp that on overlap gets the display name of the overlapping actor and prints overlapped by: followed by the name.", "output": "BLUEPRINT: BP_NameOverlap\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetDisplayName\nNODE n3: Concatenate [A=\"Overlapped by: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_05", "category": "string_overlap_name"}
{"instruction": "Create a Blueprint that on overlap gets the display name of the overlapping actor and calls PrintString with text Overlapped by: followed by the name.", "output": "BLUEPRINT: BP_NameOverlap\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetDisplayName\nNODE n3: Concatenate [A=\"Overlapped by: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_05", "category": "string_overlap_name"}
{"instruction": "Create a Blueprint that on Tick gets distance to the player pawn and prints Distance: followed by the value.", "output": "BLUEPRINT: BP_DistDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: Concatenate [A=\"Distance: \"]\nNODE n5: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_07:L07_06", "category": "debug_distance"}
{"instruction": "make a bp that on tick gets distance to the player pawn and prints distance: followed by the value.", "output": "BLUEPRINT: BP_DistDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: Concatenate [A=\"Distance: \"]\nNODE n5: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_07:L07_06", "category": "debug_distance"}
{"instruction": "Create a Blueprint that on Tick gets distance to the player pawn and calls PrintString with text Distance: followed by the value.", "output": "BLUEPRINT: BP_DistDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: Concatenate [A=\"Distance: \"]\nNODE n5: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_07:L07_06", "category": "debug_distance"}
{"instruction": "Create a Blueprint with integer Count at 0. On overlap increment Count and print Overlap Count: followed by the number.", "output": "BLUEPRINT: BP_OverlapCounter\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=Count]\nNODE n3: AddInt [B=1]\nNODE n4: VariableSet [VarName=Count]\nNODE n5: Concatenate [A=\"Overlap Count: \"]\nNODE n6: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_07", "category": "string_counter"}
{"instruction": "bp with integer count at 0. on overlap increment count and print overlap count: followed by the number.", "output": "BLUEPRINT: BP_OverlapCounter\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=Count]\nNODE n3: AddInt [B=1]\nNODE n4: VariableSet [VarName=Count]\nNODE n5: Concatenate [A=\"Overlap Count: \"]\nNODE n6: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_07", "category": "string_counter"}
{"instruction": "Create a Blueprint that on Tick calculates FPS by dividing 1 by DeltaSeconds and prints FPS: followed by the value.", "output": "BLUEPRINT: BP_FPSCounter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: DivideFloat [A=1.0]\nNODE n3: Concatenate [A=\"FPS: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n1.DeltaSeconds -> n2.B [Float]\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_08", "category": "debug_fps"}
{"instruction": "make a bp that on tick calculates fps by dividing 1 by deltaseconds and prints fps: followed by the value.", "output": "BLUEPRINT: BP_FPSCounter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: DivideFloat [A=1.0]\nNODE n3: Concatenate [A=\"FPS: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n1.DeltaSeconds -> n2.B [Float]\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_08", "category": "debug_fps"}
{"instruction": "Create a Blueprint that on Tick calculates FPS by dividing 1 by DeltaSeconds and calls PrintString with text FPS: followed by the value.", "output": "BLUEPRINT: BP_FPSCounter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: DivideFloat [A=1.0]\nNODE n3: Concatenate [A=\"FPS: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n1.DeltaSeconds -> n2.B [Float]\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_08", "category": "debug_fps"}
{"instruction": "Create a Blueprint that starts a 3-second timer on BeginPlay. Print Timer Started. When it fires print Timer Fired at: followed by game time.", "output": "BLUEPRINT: BP_TimerLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=3.0, Looping=false]\nNODE n3: PrintString [InString=\"Timer Started\"]\nNODE n4: Event_Custom [EventName=OnTimer]\nNODE n5: GetGameTimeInSeconds\nNODE n6: Concatenate [A=\"Timer Fired at: \"]\nNODE n7: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n4.Then -> n7.Execute\nDATA n5.ReturnValue -> n6.B [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_07:L07_09", "category": "string_timer_log"}
{"instruction": "make a bp that starts a 3-second timer on beginplay. print timer started. when it fires print timer fired at: followed by game time.", "output": "BLUEPRINT: BP_TimerLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=3.0, Looping=false]\nNODE n3: PrintString [InString=\"Timer Started\"]\nNODE n4: Event_Custom [EventName=OnTimer]\nNODE n5: GetGameTimeInSeconds\nNODE n6: Concatenate [A=\"Timer Fired at: \"]\nNODE n7: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n4.Then -> n7.Execute\nDATA n5.ReturnValue -> n6.B [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_07:L07_09", "category": "string_timer_log"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If success print Player: followed by display name. If fail print Not a player.", "output": "BLUEPRINT: BP_CastLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetDisplayName\nNODE n4: Concatenate [A=\"Player: \"]\nNODE n5: PrintString\nNODE n6: PrintString [InString=\"Not a player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n5.Execute\nDATA n2.AsCharacter -> n3.Target [Actor]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]\nEXEC n2.CastFailed -> n6.Execute", "source": "lesson:lesson_07:L07_10", "category": "string_cast_result"}
{"instruction": "make a bp that on overlap casts to character. if success print player: followed by display name. if fail print not a player.", "output": "BLUEPRINT: BP_CastLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetDisplayName\nNODE n4: Concatenate [A=\"Player: \"]\nNODE n5: PrintString\nNODE n6: PrintString [InString=\"Not a player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n5.Execute\nDATA n2.AsCharacter -> n3.Target [Actor]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]\nEXEC n2.CastFailed -> n6.Execute", "source": "lesson:lesson_07:L07_10", "category": "string_cast_result"}
{"instruction": "Create a Blueprint with string Name set to Player and int Level set to 1. On BeginPlay print the name followed by Level: and the number.", "output": "BLUEPRINT: BP_PlayerInfo\nPARENT: Actor\nVAR Name: String = \"Player\"\nVAR Level: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Name]\nNODE n3: VariableGet [VarName=Level]\nNODE n4: Concatenate [B=\" Level: \"]\nNODE n5: Concatenate\nNODE n6: PrintString\nEXEC n1.Then -> n6.Execute\nDATA n2.Value -> n4.A [String]\nDATA n3.Value -> n5.B [String]\nDATA n4.ReturnValue -> n5.A [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_11", "category": "string_multi_var"}
{"instruction": "bp with string name set to player and int level set to 1. on beginplay print the name followed by level: and the number.", "output": "BLUEPRINT: BP_PlayerInfo\nPARENT: Actor\nVAR Name: String = \"Player\"\nVAR Level: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Name]\nNODE n3: VariableGet [VarName=Level]\nNODE n4: Concatenate [B=\" Level: \"]\nNODE n5: Concatenate\nNODE n6: PrintString\nEXEC n1.Then -> n6.Execute\nDATA n2.Value -> n4.A [String]\nDATA n3.Value -> n5.B [String]\nDATA n4.ReturnValue -> n5.A [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_11", "category": "string_multi_var"}
{"instruction": "Create a Blueprint that on pressing Fire spawns an actor, gets its location, and prints Spawned at: followed by the location.", "output": "BLUEPRINT: BP_SpawnLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: GetActorLocation\nNODE n5: Concatenate [A=\"Spawned at: \"]\nNODE n6: PrintString\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n6.Execute\nDATA n3.ReturnValue -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_12", "category": "debug_spawn_log"}
{"instruction": "make a bp that on pressing fire spawns an actor, gets its location, and prints spawned at: followed by the location.", "output": "BLUEPRINT: BP_SpawnLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: GetActorLocation\nNODE n5: Concatenate [A=\"Spawned at: \"]\nNODE n6: PrintString\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n6.Execute\nDATA n3.ReturnValue -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_12", "category": "debug_spawn_log"}
{"instruction": "Create a Blueprint that on pressing Fire spawns an actor, gets its location, and calls PrintString with text Spawned at: followed by the location.", "output": "BLUEPRINT: BP_SpawnLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: GetActorLocation\nNODE n5: Concatenate [A=\"Spawned at: \"]\nNODE n6: PrintString\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n6.Execute\nDATA n3.ReturnValue -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_12", "category": "debug_spawn_log"}
{"instruction": "Create a Blueprint that on BeginPlay runs a ForLoop 1 to 5. Each iteration prints Item followed by the index number.", "output": "BLUEPRINT: BP_IndexPrinter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=5]\nNODE n3: Concatenate [A=\"Item \"]\nNODE n4: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n4.Execute\nDATA n2.Index -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_13", "category": "string_loop_index"}
{"instruction": "make a bp that on beginplay runs a forloop 1 to 5. each iteration prints item followed by the index number.", "output": "BLUEPRINT: BP_IndexPrinter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=5]\nNODE n3: Concatenate [A=\"Item \"]\nNODE n4: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n4.Execute\nDATA n2.Index -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_13", "category": "string_loop_index"}
{"instruction": "Create a Blueprint that on BeginPlay runs a ForLoop 1 to 5. Each iteration calls PrintString with text Item followed by the index number.", "output": "BLUEPRINT: BP_IndexPrinter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=5]\nNODE n3: Concatenate [A=\"Item \"]\nNODE n4: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n4.Execute\nDATA n2.Index -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_13", "category": "string_loop_index"}
{"instruction": "Create a Blueprint with bool IsReady. On BeginPlay branch on IsReady. True path prints Path: Ready. False path prints Path: Not Ready.", "output": "BLUEPRINT: BP_PathDebug\nPARENT: Actor\nVAR IsReady: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsReady]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Path: Ready\"]\nNODE n5: PrintString [InString=\"Path: Not Ready\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_07:L07_14", "category": "debug_branch_path"}
{"instruction": "bp with bool isready. on beginplay branch on isready. true path prints path: ready. false path prints path: not ready.", "output": "BLUEPRINT: BP_PathDebug\nPARENT: Actor\nVAR IsReady: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsReady]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Path: Ready\"]\nNODE n5: PrintString [InString=\"Path: Not Ready\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_07:L07_14", "category": "debug_branch_path"}
{"instruction": "Create a Blueprint with bool IsReady. On BeginPlay branch on IsReady. True path calls PrintString with text Path: Ready. False path calls PrintString with text Path: Not Ready.", "output": "BLUEPRINT: BP_PathDebug\nPARENT: Actor\nVAR IsReady: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsReady]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Path: Ready\"]\nNODE n5: PrintString [InString=\"Path: Not Ready\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_07:L07_14", "category": "debug_branch_path"}
{"instruction": "Create a Blueprint that on AnyDamage prints Took X damage, Health: Y where X is damage amount and Y is remaining health.", "output": "BLUEPRINT: BP_DamageLog\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: VariableSet [VarName=Health]\nNODE n5: Concatenate [A=\"Took \"]\nNODE n6: Concatenate [B=\" damage\"]\nNODE n7: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n7.Execute\nDATA n1.Damage -> n5.B [String]\nDATA n5.ReturnValue -> n6.A [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_07:L07_15", "category": "string_damage_log"}
{"instruction": "make a bp that on anydamage prints took x damage, health: y where x is damage amount and y is remaining health.", "output": "BLUEPRINT: BP_DamageLog\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: VariableSet [VarName=Health]\nNODE n5: Concatenate [A=\"Took \"]\nNODE n6: Concatenate [B=\" damage\"]\nNODE n7: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n7.Execute\nDATA n1.Damage -> n5.B [String]\nDATA n5.ReturnValue -> n6.A [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_07:L07_15", "category": "string_damage_log"}
{"instruction": "Create a Blueprint that on AnyDamage calls PrintString with text Took X damage, Health: Y where X is damage amount and Y is remaining health.", "output": "BLUEPRINT: BP_DamageLog\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: VariableSet [VarName=Health]\nNODE n5: Concatenate [A=\"Took \"]\nNODE n6: Concatenate [B=\" damage\"]\nNODE n7: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n7.Execute\nDATA n1.Damage -> n5.B [String]\nDATA n5.ReturnValue -> n6.A [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_07:L07_15", "category": "string_damage_log"}
{"instruction": "Create a Blueprint with an actor array Items. On BeginPlay print Item Count: followed by the array length.", "output": "BLUEPRINT: BP_ArrayCount\nPARENT: Actor\nVAR Items: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Items]\nNODE n3: ArrayLength\nNODE n4: Concatenate [A=\"Item Count: \"]\nNODE n5: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.Array [Array]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_07:L07_16", "category": "debug_array_count"}
{"instruction": "bp with an actor array items. on beginplay print item count: followed by the array length.", "output": "BLUEPRINT: BP_ArrayCount\nPARENT: Actor\nVAR Items: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Items]\nNODE n3: ArrayLength\nNODE n4: Concatenate [A=\"Item Count: \"]\nNODE n5: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.Array [Array]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_07:L07_16", "category": "debug_array_count"}
{"instruction": "Create a Blueprint that on BeginPlay gets game time in seconds and prints Game started at: followed by the time.", "output": "BLUEPRINT: BP_TimeDisplay\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetGameTimeInSeconds\nNODE n3: Concatenate [A=\"Game started at: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_17", "category": "string_time_display"}
{"instruction": "make a bp that on beginplay gets game time in seconds and prints game started at: followed by the time.", "output": "BLUEPRINT: BP_TimeDisplay\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetGameTimeInSeconds\nNODE n3: Concatenate [A=\"Game started at: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_17", "category": "string_time_display"}
{"instruction": "Create a Blueprint that on BeginPlay gets game time in seconds and calls PrintString with text Game started at: followed by the time.", "output": "BLUEPRINT: BP_TimeDisplay\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetGameTimeInSeconds\nNODE n3: Concatenate [A=\"Game started at: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_17", "category": "string_time_display"}
{"instruction": "Create a Blueprint with a Gate. When the gate opens print Gate: Open. When it closes print Gate: Closed. On Tick enter the gate, exit prints Active.", "output": "BLUEPRINT: BP_GateDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: PrintString [InString=\"Gate: Open\"]\nNODE n4: Event_InputAction [ActionName=\"Close\"]\nNODE n5: PrintString [InString=\"Gate: Closed\"]\nNODE n6: Event_Tick\nNODE n7: PrintString [InString=\"Active\"]\nEXEC n1.Pressed -> n2.Open\nEXEC n1.Pressed -> n3.Execute\nEXEC n4.Pressed -> n2.Close\nEXEC n4.Pressed -> n5.Execute\nEXEC n6.Then -> n2.Enter\nEXEC n2.Exit -> n7.Execute", "source": "lesson:lesson_07:L07_18", "category": "debug_gate_status"}
{"instruction": "bp with a gate. when the gate opens print gate: open. when it closes print gate: closed. on tick enter the gate, exit prints active.", "output": "BLUEPRINT: BP_GateDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: PrintString [InString=\"Gate: Open\"]\nNODE n4: Event_InputAction [ActionName=\"Close\"]\nNODE n5: PrintString [InString=\"Gate: Closed\"]\nNODE n6: Event_Tick\nNODE n7: PrintString [InString=\"Active\"]\nEXEC n1.Pressed -> n2.Open\nEXEC n1.Pressed -> n3.Execute\nEXEC n4.Pressed -> n2.Close\nEXEC n4.Pressed -> n5.Execute\nEXEC n6.Then -> n2.Enter\nEXEC n2.Exit -> n7.Execute", "source": "lesson:lesson_07:L07_18", "category": "debug_gate_status"}
{"instruction": "Create a Blueprint with a Gate. When the gate opens print Gate: Open. When it closes print Gate: Closed. On Tick enter the gate, exit calls PrintString with text Active.", "output": "BLUEPRINT: BP_GateDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: PrintString [InString=\"Gate: Open\"]\nNODE n4: Event_InputAction [ActionName=\"Close\"]\nNODE n5: PrintString [InString=\"Gate: Closed\"]\nNODE n6: Event_Tick\nNODE n7: PrintString [InString=\"Active\"]\nEXEC n1.Pressed -> n2.Open\nEXEC n1.Pressed -> n3.Execute\nEXEC n4.Pressed -> n2.Close\nEXEC n4.Pressed -> n5.Execute\nEXEC n6.Then -> n2.Enter\nEXEC n2.Exit -> n7.Execute", "source": "lesson:lesson_07:L07_18", "category": "debug_gate_status"}
{"instruction": "Create a Blueprint that on BeginPlay generates a random integer 1-100 and prints Random number: followed by the value.", "output": "BLUEPRINT: BP_RandomLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: RandomInteger [Min=1, Max=100]\nNODE n3: Concatenate [A=\"Random number: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_19", "category": "string_random_log"}
{"instruction": "make a bp that on beginplay generates a random integer 1-100 and prints random number: followed by the value.", "output": "BLUEPRINT: BP_RandomLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: RandomInteger [Min=1, Max=100]\nNODE n3: Concatenate [A=\"Random number: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_19", "category": "string_random_log"}
{"instruction": "Create a Blueprint that on BeginPlay generates a random integer 1-100 and calls PrintString with text Random number: followed by the value.", "output": "BLUEPRINT: BP_RandomLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: RandomInteger [Min=1, Max=100]\nNODE n3: Concatenate [A=\"Random number: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_19", "category": "string_random_log"}
{"instruction": "Create a Blueprint that on BeginPlay prints BEGIN at: with game time. On EndPlay prints END at: with game time.", "output": "BLUEPRINT: BP_LifecycleLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetGameTimeInSeconds\nNODE n3: Concatenate [A=\"BEGIN at: \"]\nNODE n4: PrintString\nNODE n5: Event_EndPlay\nNODE n6: GetGameTimeInSeconds\nNODE n7: Concatenate [A=\"END at: \"]\nNODE n8: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]\nEXEC n5.Then -> n8.Execute\nDATA n6.ReturnValue -> n7.B [String]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:lesson_07:L07_20", "category": "debug_lifecycle"}
{"instruction": "make a bp that on beginplay prints begin at: with game time. on endplay prints end at: with game time.", "output": "BLUEPRINT: BP_LifecycleLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetGameTimeInSeconds\nNODE n3: Concatenate [A=\"BEGIN at: \"]\nNODE n4: PrintString\nNODE n5: Event_EndPlay\nNODE n6: GetGameTimeInSeconds\nNODE n7: Concatenate [A=\"END at: \"]\nNODE n8: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]\nEXEC n5.Then -> n8.Execute\nDATA n6.ReturnValue -> n7.B [String]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:lesson_07:L07_20", "category": "debug_lifecycle"}
{"instruction": "Create a Blueprint that on BeginPlay calls PrintString with text BEGIN at: with game time. On EndPlay calls PrintString with text END at: with game time.", "output": "BLUEPRINT: BP_LifecycleLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetGameTimeInSeconds\nNODE n3: Concatenate [A=\"BEGIN at: \"]\nNODE n4: PrintString\nNODE n5: Event_EndPlay\nNODE n6: GetGameTimeInSeconds\nNODE n7: Concatenate [A=\"END at: \"]\nNODE n8: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]\nEXEC n5.Then -> n8.Execute\nDATA n6.ReturnValue -> n7.B [String]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:lesson_07:L07_20", "category": "debug_lifecycle"}
{"instruction": "Create a Blueprint that on BeginPlay creates a widget of class WBP_HUD and adds it to the viewport.", "output": "BLUEPRINT: BP_ShowHUD\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]", "source": "lesson:lesson_08:L08_01", "category": "ui_create_basic"}
{"instruction": "make a bp that on beginplay creates a widget of class wbp_hud and adds it to the viewport.", "output": "BLUEPRINT: BP_ShowHUD\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]", "source": "lesson:lesson_08:L08_01", "category": "ui_create_basic"}
{"instruction": "Create a Blueprint with a widget variable HUDWidget. On pressing Escape, remove it from the viewport.", "output": "BLUEPRINT: BP_RemoveHUD\nPARENT: Actor\nVAR HUDWidget: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Escape\"]\nNODE n2: VariableGet [VarName=HUDWidget]\nNODE n3: RemoveFromParent\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Target [Widget]", "source": "lesson:lesson_08:L08_02", "category": "ui_remove"}
{"instruction": "bp with a widget variable hudwidget. on pressing escape, remove it from the viewport.", "output": "BLUEPRINT: BP_RemoveHUD\nPARENT: Actor\nVAR HUDWidget: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Escape\"]\nNODE n2: VariableGet [VarName=HUDWidget]\nNODE n3: RemoveFromParent\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Target [Widget]", "source": "lesson:lesson_08:L08_02", "category": "ui_remove"}
{"instruction": "Create a Blueprint with a widget variable MenuWidget and bool MenuOpen. On pressing Menu, toggle: if open remove widget and set false, if closed create widget and set true.", "output": "BLUEPRINT: BP_ToggleMenu\nPARENT: Actor\nVAR MenuWidget: Widget = None\nVAR MenuOpen: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Menu\"]\nNODE n2: VariableGet [VarName=MenuOpen]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=MenuWidget]\nNODE n5: RemoveFromParent\nNODE n6: VariableSet [VarName=MenuOpen]\nNODE n7: CreateWidget [WidgetClass=WBP_Menu]\nNODE n8: AddToViewport\nNODE n9: VariableSet [VarName=MenuWidget]\nNODE n10: VariableSet [VarName=MenuOpen]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute\nDATA false -> n6.Value [Bool]\nEXEC n3.False -> n7.Execute\nEXEC n7.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Target [Widget]\nEXEC n8.Then -> n9.Execute\nDATA n7.ReturnValue -> n9.Value [Widget]\nEXEC n9.Then -> n10.Execute\nDATA true -> n10.Value [Bool]", "source": "lesson:lesson_08:L08_03", "category": "ui_toggle"}
{"instruction": "bp with a widget variable menuwidget and bool menuopen. on pressing menu, toggle: if open remove widget and set false, if closed create widget and set true.", "output": "BLUEPRINT: BP_ToggleMenu\nPARENT: Actor\nVAR MenuWidget: Widget = None\nVAR MenuOpen: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Menu\"]\nNODE n2: VariableGet [VarName=MenuOpen]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=MenuWidget]\nNODE n5: RemoveFromParent\nNODE n6: VariableSet [VarName=MenuOpen]\nNODE n7: CreateWidget [WidgetClass=WBP_Menu]\nNODE n8: AddToViewport\nNODE n9: VariableSet [VarName=MenuWidget]\nNODE n10: VariableSet [VarName=MenuOpen]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute\nDATA false -> n6.Value [Bool]\nEXEC n3.False -> n7.Execute\nEXEC n7.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Target [Widget]\nEXEC n8.Then -> n9.Execute\nDATA n7.ReturnValue -> n9.Value [Widget]\nEXEC n9.Then -> n10.Execute\nDATA true -> n10.Value [Bool]", "source": "lesson:lesson_08:L08_03", "category": "ui_toggle"}
{"instruction": "Create a Blueprint that on BeginPlay waits 3 seconds, then creates a widget WBP_Welcome and adds it to viewport. After 5 more seconds, remove it.", "output": "BLUEPRINT: BP_TimedWidget\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: CreateWidget [WidgetClass=WBP_Welcome]\nNODE n4: AddToViewport\nNODE n5: Delay [Duration=5.0]\nNODE n6: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute\nDATA n3.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_04", "category": "ui_delayed"}
{"instruction": "make a bp that on beginplay waits 3 seconds, then creates a widget wbp_welcome and adds it to viewport. after 5 more seconds, remove it.", "output": "BLUEPRINT: BP_TimedWidget\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: CreateWidget [WidgetClass=WBP_Welcome]\nNODE n4: AddToViewport\nNODE n5: Delay [Duration=5.0]\nNODE n6: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute\nDATA n3.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_04", "category": "ui_delayed"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Delay node for 3 seconds, then creates a widget WBP_Welcome and adds it to viewport. After 5 more seconds, remove it.", "output": "BLUEPRINT: BP_TimedWidget\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: CreateWidget [WidgetClass=WBP_Welcome]\nNODE n4: AddToViewport\nNODE n5: Delay [Duration=5.0]\nNODE n6: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute\nDATA n3.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_04", "category": "ui_delayed"}
{"instruction": "Create a Blueprint that on overlap creates a widget WBP_Tooltip and adds to viewport. On end overlap, remove it.", "output": "BLUEPRINT: BP_OverlapTooltip\nPARENT: Actor\nVAR TooltipWidget: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CreateWidget [WidgetClass=WBP_Tooltip]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=TooltipWidget]\nNODE n5: Event_ActorEndOverlap\nNODE n6: VariableGet [VarName=TooltipWidget]\nNODE n7: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n7.Execute\nDATA n6.Value -> n7.Target [Widget]", "source": "lesson:lesson_08:L08_05", "category": "ui_overlap_show"}
{"instruction": "make a bp that on overlap creates a widget wbp_tooltip and adds to viewport. on end overlap, remove it.", "output": "BLUEPRINT: BP_OverlapTooltip\nPARENT: Actor\nVAR TooltipWidget: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CreateWidget [WidgetClass=WBP_Tooltip]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=TooltipWidget]\nNODE n5: Event_ActorEndOverlap\nNODE n6: VariableGet [VarName=TooltipWidget]\nNODE n7: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n7.Execute\nDATA n6.Value -> n7.Target [Widget]", "source": "lesson:lesson_08:L08_05", "category": "ui_overlap_show"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If the cast succeeds, create widget WBP_PlayerHUD and add to viewport.", "output": "BLUEPRINT: BP_PlayerHUD\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: CreateWidget [WidgetClass=WBP_PlayerHUD]\nNODE n4: AddToViewport\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]", "source": "lesson:lesson_08:L08_06", "category": "ui_with_cast"}
{"instruction": "make a bp that on overlap casts to character. if the cast succeeds, create widget wbp_playerhud and add to viewport.", "output": "BLUEPRINT: BP_PlayerHUD\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: CreateWidget [WidgetClass=WBP_PlayerHUD]\nNODE n4: AddToViewport\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]", "source": "lesson:lesson_08:L08_06", "category": "ui_with_cast"}
{"instruction": "Create a Blueprint that on overlap uses DoOnce, creates widget WBP_Tutorial and adds to viewport.", "output": "BLUEPRINT: BP_TutorialPopup\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: CreateWidget [WidgetClass=WBP_Tutorial]\nNODE n4: AddToViewport\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]", "source": "lesson:lesson_08:L08_07", "category": "ui_doonce"}
{"instruction": "make a bp that on overlap uses doonce, creates widget wbp_tutorial and adds to viewport.", "output": "BLUEPRINT: BP_TutorialPopup\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: CreateWidget [WidgetClass=WBP_Tutorial]\nNODE n4: AddToViewport\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]", "source": "lesson:lesson_08:L08_07", "category": "ui_doonce"}
{"instruction": "Create a Blueprint with bool ShowHUD. On BeginPlay, if ShowHUD is true create WBP_HUD and add to viewport. If false, print HUD Disabled.", "output": "BLUEPRINT: BP_ConditionalHUD\nPARENT: Actor\nVAR ShowHUD: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=ShowHUD]\nNODE n3: Branch\nNODE n4: CreateWidget [WidgetClass=WBP_HUD]\nNODE n5: AddToViewport\nNODE n6: PrintString [InString=\"HUD Disabled\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n3.False -> n6.Execute", "source": "lesson:lesson_08:L08_08", "category": "ui_branch_show"}
{"instruction": "bp with bool showhud. on beginplay, if showhud is true create wbp_hud and add to viewport. if false, print hud disabled.", "output": "BLUEPRINT: BP_ConditionalHUD\nPARENT: Actor\nVAR ShowHUD: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=ShowHUD]\nNODE n3: Branch\nNODE n4: CreateWidget [WidgetClass=WBP_HUD]\nNODE n5: AddToViewport\nNODE n6: PrintString [InString=\"HUD Disabled\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n3.False -> n6.Execute", "source": "lesson:lesson_08:L08_08", "category": "ui_branch_show"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence. First output creates WBP_Background and adds to viewport. Second output creates WBP_Foreground and adds to viewport.", "output": "BLUEPRINT: BP_LayeredUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: CreateWidget [WidgetClass=WBP_Background]\nNODE n4: AddToViewport\nNODE n5: CreateWidget [WidgetClass=WBP_Foreground]\nNODE n6: AddToViewport\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n2.Then_1 -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_09", "category": "ui_sequence_multi"}
{"instruction": "make a bp that on beginplay uses a sequence. first output creates wbp_background and adds to viewport. second output creates wbp_foreground and adds to viewport.", "output": "BLUEPRINT: BP_LayeredUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: CreateWidget [WidgetClass=WBP_Background]\nNODE n4: AddToViewport\nNODE n5: CreateWidget [WidgetClass=WBP_Foreground]\nNODE n6: AddToViewport\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n2.Then_1 -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_09", "category": "ui_sequence_multi"}
{"instruction": "Create a Blueprint with widget variable CurrentUI. On pressing Close, check if CurrentUI is valid. If valid, remove from parent and set to None.", "output": "BLUEPRINT: BP_SafeRemoveUI\nPARENT: Actor\nVAR CurrentUI: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Close\"]\nNODE n2: VariableGet [VarName=CurrentUI]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: RemoveFromParent\nNODE n6: VariableSet [VarName=CurrentUI]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.Value -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute\nDATA None -> n6.Value [Widget]", "source": "lesson:lesson_08:L08_10", "category": "ui_valid_remove"}
{"instruction": "bp with widget variable currentui. on pressing close, check if currentui is valid. if valid, remove from parent and set to none.", "output": "BLUEPRINT: BP_SafeRemoveUI\nPARENT: Actor\nVAR CurrentUI: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Close\"]\nNODE n2: VariableGet [VarName=CurrentUI]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: RemoveFromParent\nNODE n6: VariableSet [VarName=CurrentUI]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.Value -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute\nDATA None -> n6.Value [Widget]", "source": "lesson:lesson_08:L08_10", "category": "ui_valid_remove"}
{"instruction": "Create a Blueprint that on BeginPlay sets a 5-second timer. When it fires, create WBP_Alert and add to viewport. Print Alert Shown.", "output": "BLUEPRINT: BP_TimedAlert\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"ShowAlert\", Time=5.0, Looping=false]\nNODE n3: Event_Custom [EventName=ShowAlert]\nNODE n4: CreateWidget [WidgetClass=WBP_Alert]\nNODE n5: AddToViewport\nNODE n6: PrintString [InString=\"Alert Shown\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_08:L08_11", "category": "ui_timer_show"}
{"instruction": "make a bp that on beginplay sets a 5-second timer. when it fires, create wbp_alert and add to viewport. print alert shown.", "output": "BLUEPRINT: BP_TimedAlert\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"ShowAlert\", Time=5.0, Looping=false]\nNODE n3: Event_Custom [EventName=ShowAlert]\nNODE n4: CreateWidget [WidgetClass=WBP_Alert]\nNODE n5: AddToViewport\nNODE n6: PrintString [InString=\"Alert Shown\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_08:L08_11", "category": "ui_timer_show"}
{"instruction": "Create a Blueprint with two widget variables ScreenA and ScreenB. On pressing Swap, use FlipFlop. A shows ScreenA and hides ScreenB. B does the opposite.", "output": "BLUEPRINT: BP_SwapScreens\nPARENT: Actor\nVAR ScreenA: Widget = None\nVAR ScreenB: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Swap\"]\nNODE n2: FlipFlop\nNODE n3: VariableGet [VarName=ScreenA]\nNODE n4: AddToViewport\nNODE n5: VariableGet [VarName=ScreenB]\nNODE n6: RemoveFromParent\nNODE n7: VariableGet [VarName=ScreenB]\nNODE n8: AddToViewport\nNODE n9: VariableGet [VarName=ScreenA]\nNODE n10: RemoveFromParent\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n4.Execute\nDATA n3.Value -> n4.Target [Widget]\nEXEC n4.Then -> n6.Execute\nDATA n5.Value -> n6.Target [Widget]\nEXEC n2.B -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]\nEXEC n8.Then -> n10.Execute\nDATA n9.Value -> n10.Target [Widget]", "source": "lesson:lesson_08:L08_12", "category": "ui_flipflop_swap"}
{"instruction": "bp with two widget variables screena and screenb. on pressing swap, use flipflop. a shows screena and hides screenb. b does the opposite.", "output": "BLUEPRINT: BP_SwapScreens\nPARENT: Actor\nVAR ScreenA: Widget = None\nVAR ScreenB: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Swap\"]\nNODE n2: FlipFlop\nNODE n3: VariableGet [VarName=ScreenA]\nNODE n4: AddToViewport\nNODE n5: VariableGet [VarName=ScreenB]\nNODE n6: RemoveFromParent\nNODE n7: VariableGet [VarName=ScreenB]\nNODE n8: AddToViewport\nNODE n9: VariableGet [VarName=ScreenA]\nNODE n10: RemoveFromParent\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n4.Execute\nDATA n3.Value -> n4.Target [Widget]\nEXEC n4.Then -> n6.Execute\nDATA n5.Value -> n6.Target [Widget]\nEXEC n2.B -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]\nEXEC n8.Then -> n10.Execute\nDATA n9.Value -> n10.Target [Widget]", "source": "lesson:lesson_08:L08_12", "category": "ui_flipflop_swap"}
{"instruction": "Create a Blueprint that on Tick checks distance to player. If less than 300, create and show WBP_Interact widget using DoOnce.", "output": "BLUEPRINT: BP_ProximityUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=300.0]\nNODE n5: Branch\nNODE n6: DoOnce\nNODE n7: CreateWidget [WidgetClass=WBP_Interact]\nNODE n8: AddToViewport\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.Completed -> n7.Execute\nEXEC n7.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Target [Widget]", "source": "lesson:lesson_08:L08_13", "category": "ui_distance_trigger"}
{"instruction": "make a bp that on tick checks distance to player. if less than 300, create and show wbp_interact widget using doonce.", "output": "BLUEPRINT: BP_ProximityUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=300.0]\nNODE n5: Branch\nNODE n6: DoOnce\nNODE n7: CreateWidget [WidgetClass=WBP_Interact]\nNODE n8: AddToViewport\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.Completed -> n7.Execute\nEXEC n7.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Target [Widget]", "source": "lesson:lesson_08:L08_13", "category": "ui_distance_trigger"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_HUD, stores it in variable MyHUD, and adds to viewport. Print HUD Ready.", "output": "BLUEPRINT: BP_StoredHUD\nPARENT: Actor\nVAR MyHUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: VariableSet [VarName=MyHUD]\nNODE n4: AddToViewport\nNODE n5: PrintString [InString=\"HUD Ready\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute", "source": "lesson:lesson_08:L08_14", "category": "ui_create_store"}
{"instruction": "make a bp that on beginplay creates wbp_hud, stores it in variable myhud, and adds to viewport. print hud ready.", "output": "BLUEPRINT: BP_StoredHUD\nPARENT: Actor\nVAR MyHUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: VariableSet [VarName=MyHUD]\nNODE n4: AddToViewport\nNODE n5: PrintString [InString=\"HUD Ready\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute", "source": "lesson:lesson_08:L08_14", "category": "ui_create_store"}
{"instruction": "Create a Blueprint that creates WBP_HUD on BeginPlay. On EndPlay, check if widget is valid and remove it.", "output": "BLUEPRINT: BP_CleanupUI\nPARENT: Actor\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_EndPlay\nNODE n6: VariableGet [VarName=HUD]\nNODE n7: IsValid\nNODE n8: Branch\nNODE n9: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.Input [Object]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA n6.Value -> n9.Target [Widget]", "source": "lesson:lesson_08:L08_15", "category": "ui_endplay_cleanup"}
{"instruction": "make a bp that creates wbp_hud on beginplay. on endplay, check if widget is valid and remove it.", "output": "BLUEPRINT: BP_CleanupUI\nPARENT: Actor\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_EndPlay\nNODE n6: VariableGet [VarName=HUD]\nNODE n7: IsValid\nNODE n8: Branch\nNODE n9: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.Input [Object]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA n6.Value -> n9.Target [Widget]", "source": "lesson:lesson_08:L08_15", "category": "ui_endplay_cleanup"}
{"instruction": "Create a Blueprint with a Gate. Opening the gate creates and shows WBP_Panel. Closing the gate removes it.", "output": "BLUEPRINT: BP_GatedUI\nPARENT: Actor\nVAR Panel: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Panel]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Panel]\nNODE n6: Event_InputAction [ActionName=\"Close\"]\nNODE n7: VariableGet [VarName=Panel]\nNODE n8: RemoveFromParent\nEXEC n1.Pressed -> n2.Open\nEXEC n2.Exit -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n6.Pressed -> n2.Close\nEXEC n6.Pressed -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]", "source": "lesson:lesson_08:L08_16", "category": "ui_gate_controlled"}
{"instruction": "bp with a gate. opening the gate creates and shows wbp_panel. closing the gate removes it.", "output": "BLUEPRINT: BP_GatedUI\nPARENT: Actor\nVAR Panel: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Panel]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Panel]\nNODE n6: Event_InputAction [ActionName=\"Close\"]\nNODE n7: VariableGet [VarName=Panel]\nNODE n8: RemoveFromParent\nEXEC n1.Pressed -> n2.Open\nEXEC n2.Exit -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n6.Pressed -> n2.Close\nEXEC n6.Pressed -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]", "source": "lesson:lesson_08:L08_16", "category": "ui_gate_controlled"}
{"instruction": "Create a Blueprint with a string array MenuItems. On BeginPlay, loop through MenuItems and print each item name. After loop, create WBP_Menu and add to viewport.", "output": "BLUEPRINT: BP_DynamicMenu\nPARENT: Actor\nVAR MenuItems: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=MenuItems]\nNODE n3: ForEachLoop\nNODE n4: PrintString\nNODE n5: CreateWidget [WidgetClass=WBP_Menu]\nNODE n6: AddToViewport\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.InString [String]\nEXEC n3.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_17", "category": "ui_foreach_create"}
{"instruction": "bp with a string array menuitems. on beginplay, loop through menuitems and print each item name. after loop, create wbp_menu and add to viewport.", "output": "BLUEPRINT: BP_DynamicMenu\nPARENT: Actor\nVAR MenuItems: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=MenuItems]\nNODE n3: ForEachLoop\nNODE n4: PrintString\nNODE n5: CreateWidget [WidgetClass=WBP_Menu]\nNODE n6: AddToViewport\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.InString [String]\nEXEC n3.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_17", "category": "ui_foreach_create"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_Dialog and adds to viewport. On pressing Confirm, remove the dialog and print Confirmed.", "output": "BLUEPRINT: BP_Dialog\nPARENT: Actor\nVAR Dialog: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_Dialog]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=Dialog]\nNODE n5: Event_InputAction [ActionName=\"Confirm\"]\nNODE n6: VariableGet [VarName=Dialog]\nNODE n7: RemoveFromParent\nNODE n8: PrintString [InString=\"Confirmed\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Pressed -> n7.Execute\nDATA n6.Value -> n7.Target [Widget]\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_08:L08_18", "category": "ui_input_close"}
{"instruction": "make a bp that on beginplay creates wbp_dialog and adds to viewport. on pressing confirm, remove the dialog and print confirmed.", "output": "BLUEPRINT: BP_Dialog\nPARENT: Actor\nVAR Dialog: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_Dialog]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=Dialog]\nNODE n5: Event_InputAction [ActionName=\"Confirm\"]\nNODE n6: VariableGet [VarName=Dialog]\nNODE n7: RemoveFromParent\nNODE n8: PrintString [InString=\"Confirmed\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Pressed -> n7.Execute\nDATA n6.Value -> n7.Target [Widget]\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_08:L08_18", "category": "ui_input_close"}
{"instruction": "Create a Blueprint where pressing Next uses MultiGate with 3 outputs. Each output creates a different widget: WBP_Page1, WBP_Page2, WBP_Page3 and adds to viewport.", "output": "BLUEPRINT: BP_PagedUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Next\"]\nNODE n2: MultiGate\nNODE n3: CreateWidget [WidgetClass=WBP_Page1]\nNODE n4: AddToViewport\nNODE n5: CreateWidget [WidgetClass=WBP_Page2]\nNODE n6: AddToViewport\nNODE n7: CreateWidget [WidgetClass=WBP_Page3]\nNODE n8: AddToViewport\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Out_0 -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n2.Out_1 -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]\nEXEC n2.Out_2 -> n7.Execute\nEXEC n7.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Target [Widget]", "source": "lesson:lesson_08:L08_19", "category": "ui_multigate"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_Loading and adds to viewport. After 3 seconds, remove loading widget, create WBP_MainMenu, and add to viewport. Print Ready.", "output": "BLUEPRINT: BP_LoadingFlow\nPARENT: Actor\nVAR LoadingWidget: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_Loading]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=LoadingWidget]\nNODE n5: Delay [Duration=3.0]\nNODE n6: VariableGet [VarName=LoadingWidget]\nNODE n7: RemoveFromParent\nNODE n8: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n9: AddToViewport\nNODE n10: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n7.Execute\nDATA n6.Value -> n7.Target [Widget]\nEXEC n7.Then -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Target [Widget]\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_08:L08_20", "category": "ui_complete_flow"}
{"instruction": "make a bp that on beginplay creates wbp_loading and adds to viewport. after 3 seconds, remove loading widget, create wbp_mainmenu, and add to viewport. print ready.", "output": "BLUEPRINT: BP_LoadingFlow\nPARENT: Actor\nVAR LoadingWidget: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_Loading]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=LoadingWidget]\nNODE n5: Delay [Duration=3.0]\nNODE n6: VariableGet [VarName=LoadingWidget]\nNODE n7: RemoveFromParent\nNODE n8: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n9: AddToViewport\nNODE n10: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n7.Execute\nDATA n6.Value -> n7.Target [Widget]\nEXEC n7.Then -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Target [Widget]\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_08:L08_20", "category": "ui_complete_flow"}
{"instruction": "Create a Blueprint with bool IsAlive and bool HasWeapon. On BeginPlay check IsAlive. If true, check HasWeapon. If has weapon print Armed. If no weapon print Unarmed. If not alive print Dead.", "output": "BLUEPRINT: BP_NestedCheck\nPARENT: Actor\nVAR IsAlive: Bool = true\nVAR HasWeapon: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsAlive]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=HasWeapon]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Armed\"]\nNODE n7: PrintString [InString=\"Unarmed\"]\nNODE n8: PrintString [InString=\"Dead\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute\nEXEC n3.False -> n8.Execute", "source": "lesson:lesson_09:L09_01", "category": "nested_branch_basic"}
{"instruction": "bp with bool isalive and bool hasweapon. on beginplay check isalive. if true, check hasweapon. if has weapon print armed. if no weapon print unarmed. if not alive print dead.", "output": "BLUEPRINT: BP_NestedCheck\nPARENT: Actor\nVAR IsAlive: Bool = true\nVAR HasWeapon: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsAlive]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=HasWeapon]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Armed\"]\nNODE n7: PrintString [InString=\"Unarmed\"]\nNODE n8: PrintString [InString=\"Dead\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute\nEXEC n3.False -> n8.Execute", "source": "lesson:lesson_09:L09_01", "category": "nested_branch_basic"}
{"instruction": "Create a Blueprint with float Health. On BeginPlay if Health > 75 print Healthy. Else if Health > 25 print Wounded. Else print Critical.", "output": "BLUEPRINT: BP_HealthStatus\nPARENT: Actor\nVAR Health: Float = 50.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Health]\nNODE n3: GreaterThan [B=75.0]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Healthy\"]\nNODE n6: GreaterThan [B=25.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Wounded\"]\nNODE n9: PrintString [InString=\"Critical\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n7.Execute\nDATA n2.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute", "source": "lesson:lesson_09:L09_02", "category": "nested_branch_three"}
{"instruction": "bp with float health. on beginplay if health > 75 print healthy. else if health > 25 print wounded. else print critical.", "output": "BLUEPRINT: BP_HealthStatus\nPARENT: Actor\nVAR Health: Float = 50.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Health]\nNODE n3: GreaterThan [B=75.0]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Healthy\"]\nNODE n6: GreaterThan [B=25.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Wounded\"]\nNODE n9: PrintString [InString=\"Critical\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n7.Execute\nDATA n2.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute", "source": "lesson:lesson_09:L09_02", "category": "nested_branch_three"}
{"instruction": "Create a Blueprint with integer Level. On BeginPlay use Switch on Int. Case 1 prints Easy. Case 2 prints Medium. Case 3 prints Hard. Default prints Unknown.", "output": "BLUEPRINT: BP_DifficultySwitch\nPARENT: Actor\nVAR Level: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Level]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Easy\"]\nNODE n5: PrintString [InString=\"Medium\"]\nNODE n6: PrintString [InString=\"Hard\"]\nNODE n7: PrintString [InString=\"Unknown\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute\nEXEC n3.Default -> n7.Execute", "source": "lesson:lesson_09:L09_03", "category": "switch_int"}
{"instruction": "bp with integer level. on beginplay use switch on int. case 1 prints easy. case 2 prints medium. case 3 prints hard. default prints unknown.", "output": "BLUEPRINT: BP_DifficultySwitch\nPARENT: Actor\nVAR Level: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Level]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Easy\"]\nNODE n5: PrintString [InString=\"Medium\"]\nNODE n6: PrintString [InString=\"Hard\"]\nNODE n7: PrintString [InString=\"Unknown\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute\nEXEC n3.Default -> n7.Execute", "source": "lesson:lesson_09:L09_03", "category": "switch_int"}
{"instruction": "Create a Blueprint with integer Level. On BeginPlay use Switch on Int. Case 1 calls PrintString with text Easy. Case 2 calls PrintString with text Medium. Case 3 calls PrintString with text Hard. Default calls PrintString with text Unknown.", "output": "BLUEPRINT: BP_DifficultySwitch\nPARENT: Actor\nVAR Level: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Level]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Easy\"]\nNODE n5: PrintString [InString=\"Medium\"]\nNODE n6: PrintString [InString=\"Hard\"]\nNODE n7: PrintString [InString=\"Unknown\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute\nEXEC n3.Default -> n7.Execute", "source": "lesson:lesson_09:L09_03", "category": "switch_int"}
{"instruction": "Create a Blueprint with string Command. On BeginPlay use Switch on String. If Attack print Attacking. If Defend print Defending. If Heal print Healing. Default print Idle.", "output": "BLUEPRINT: BP_CommandSwitch\nPARENT: Actor\nVAR Command: String = \"Attack\"\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Command]\nNODE n3: SwitchOnString\nNODE n4: PrintString [InString=\"Attacking\"]\nNODE n5: PrintString [InString=\"Defending\"]\nNODE n6: PrintString [InString=\"Healing\"]\nNODE n7: PrintString [InString=\"Idle\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [String]\nEXEC n3.Case_Attack -> n4.Execute\nEXEC n3.Case_Defend -> n5.Execute\nEXEC n3.Case_Heal -> n6.Execute\nEXEC n3.Default -> n7.Execute", "source": "lesson:lesson_09:L09_04", "category": "switch_string"}
{"instruction": "bp with string command. on beginplay use switch on string. if attack print attacking. if defend print defending. if heal print healing. default print idle.", "output": "BLUEPRINT: BP_CommandSwitch\nPARENT: Actor\nVAR Command: String = \"Attack\"\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Command]\nNODE n3: SwitchOnString\nNODE n4: PrintString [InString=\"Attacking\"]\nNODE n5: PrintString [InString=\"Defending\"]\nNODE n6: PrintString [InString=\"Healing\"]\nNODE n7: PrintString [InString=\"Idle\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [String]\nEXEC n3.Case_Attack -> n4.Execute\nEXEC n3.Case_Defend -> n5.Execute\nEXEC n3.Case_Heal -> n6.Execute\nEXEC n3.Default -> n7.Execute", "source": "lesson:lesson_09:L09_04", "category": "switch_string"}
{"instruction": "Create a Blueprint with bool HasKey and bool DoorUnlocked. On overlap, if HasKey AND DoorUnlocked print Enter. Else print Blocked.", "output": "BLUEPRINT: BP_DoorCheck\nPARENT: Actor\nVAR HasKey: Bool = true\nVAR DoorUnlocked: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=HasKey]\nNODE n3: VariableGet [VarName=DoorUnlocked]\nNODE n4: BooleanAND\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Enter\"]\nNODE n7: PrintString [InString=\"Blocked\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n4.A [Bool]\nDATA n3.Value -> n4.B [Bool]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_09:L09_05", "category": "branch_and_or"}
{"instruction": "bp with bool haskey and bool doorunlocked. on overlap, if haskey and doorunlocked print enter. else print blocked.", "output": "BLUEPRINT: BP_DoorCheck\nPARENT: Actor\nVAR HasKey: Bool = true\nVAR DoorUnlocked: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=HasKey]\nNODE n3: VariableGet [VarName=DoorUnlocked]\nNODE n4: BooleanAND\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Enter\"]\nNODE n7: PrintString [InString=\"Blocked\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n4.A [Bool]\nDATA n3.Value -> n4.B [Bool]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_09:L09_05", "category": "branch_and_or"}
{"instruction": "Create a Blueprint with bool IsInvisible. On Tick, if NOT IsInvisible, print Visible.", "output": "BLUEPRINT: BP_VisCheck\nPARENT: Actor\nVAR IsInvisible: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=IsInvisible]\nNODE n3: NOT\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Visible\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Bool]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute", "source": "lesson:lesson_09:L09_06", "category": "branch_not"}
{"instruction": "bp with bool isinvisible. on tick, if not isinvisible, print visible.", "output": "BLUEPRINT: BP_VisCheck\nPARENT: Actor\nVAR IsInvisible: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=IsInvisible]\nNODE n3: NOT\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Visible\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Bool]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute", "source": "lesson:lesson_09:L09_06", "category": "branch_not"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If cast succeeds check distance less than 200. If close print Too Close. If far print In Range. If cast fails print Not Player.", "output": "BLUEPRINT: BP_RangeCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Too Close\"]\nNODE n7: PrintString [InString=\"In Range\"]\nNODE n8: PrintString [InString=\"Not Player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n5.Execute\nDATA n2.AsCharacter -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute\nEXEC n2.CastFailed -> n8.Execute", "source": "lesson:lesson_09:L09_07", "category": "nested_overlap_cast"}
{"instruction": "make a bp that on overlap casts to character. if cast succeeds check distance less than 200. if close print too close. if far print in range. if cast fails print not player.", "output": "BLUEPRINT: BP_RangeCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Too Close\"]\nNODE n7: PrintString [InString=\"In Range\"]\nNODE n8: PrintString [InString=\"Not Player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n5.Execute\nDATA n2.AsCharacter -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute\nEXEC n2.CastFailed -> n8.Execute", "source": "lesson:lesson_09:L09_07", "category": "nested_overlap_cast"}
{"instruction": "Create a Blueprint with float PlayerHealth and float EnemyHealth. On BeginPlay if PlayerHealth greater than EnemyHealth print Advantage. Else print Disadvantage.", "output": "BLUEPRINT: BP_HealthCompare\nPARENT: Actor\nVAR PlayerHealth: Float = 80.0\nVAR EnemyHealth: Float = 60.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=PlayerHealth]\nNODE n3: VariableGet [VarName=EnemyHealth]\nNODE n4: GreaterThan\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Advantage\"]\nNODE n7: PrintString [InString=\"Disadvantage\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n4.A [Float]\nDATA n3.Value -> n4.B [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_09:L09_08", "category": "branch_compare_vars"}
{"instruction": "bp with float playerhealth and float enemyhealth. on beginplay if playerhealth greater than enemyhealth print advantage. else print disadvantage.", "output": "BLUEPRINT: BP_HealthCompare\nPARENT: Actor\nVAR PlayerHealth: Float = 80.0\nVAR EnemyHealth: Float = 60.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=PlayerHealth]\nNODE n3: VariableGet [VarName=EnemyHealth]\nNODE n4: GreaterThan\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Advantage\"]\nNODE n7: PrintString [InString=\"Disadvantage\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n4.A [Float]\nDATA n3.Value -> n4.B [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_09:L09_08", "category": "branch_compare_vars"}
{"instruction": "Create a Blueprint with integer WeaponSlot. On pressing Fire, switch on WeaponSlot. Case 1 prints Sword. Case 2 prints Bow. Case 3 prints Staff.", "output": "BLUEPRINT: BP_WeaponSelect\nPARENT: Actor\nVAR WeaponSlot: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=WeaponSlot]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Sword\"]\nNODE n5: PrintString [InString=\"Bow\"]\nNODE n6: PrintString [InString=\"Staff\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute", "source": "lesson:lesson_09:L09_09", "category": "switch_int_action"}
{"instruction": "bp with integer weaponslot. on pressing fire, switch on weaponslot. case 1 prints sword. case 2 prints bow. case 3 prints staff.", "output": "BLUEPRINT: BP_WeaponSelect\nPARENT: Actor\nVAR WeaponSlot: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=WeaponSlot]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Sword\"]\nNODE n5: PrintString [InString=\"Bow\"]\nNODE n6: PrintString [InString=\"Staff\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute", "source": "lesson:lesson_09:L09_09", "category": "switch_int_action"}
{"instruction": "Create a Blueprint with integer WeaponSlot. On pressing Fire, switch on WeaponSlot. Case 1 calls PrintString with text Sword. Case 2 calls PrintString with text Bow. Case 3 calls PrintString with text Staff.", "output": "BLUEPRINT: BP_WeaponSelect\nPARENT: Actor\nVAR WeaponSlot: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=WeaponSlot]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Sword\"]\nNODE n5: PrintString [InString=\"Bow\"]\nNODE n6: PrintString [InString=\"Staff\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute", "source": "lesson:lesson_09:L09_09", "category": "switch_int_action"}
{"instruction": "Create a Blueprint with float Health at 100. Start a looping timer every 2 seconds. Each tick subtract 10. If Health > 50 print OK. Else if Health > 0 print Warning. Else clear timer and print Dead.", "output": "BLUEPRINT: BP_HealthDrain\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Drain\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=Drain]\nNODE n4: VariableGet [VarName=Health]\nNODE n5: SubtractFloat [B=10.0]\nNODE n6: VariableSet [VarName=Health]\nNODE n7: GreaterThan [B=50.0]\nNODE n8: Branch\nNODE n9: PrintString [InString=\"OK\"]\nNODE n10: GreaterThan [B=0.0]\nNODE n11: Branch\nNODE n12: PrintString [InString=\"Warning\"]\nNODE n13: ClearTimerByFunctionName [FunctionName=\"Drain\"]\nNODE n14: PrintString [InString=\"Dead\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nEXEC n8.False -> n11.Execute\nDATA n6.Value -> n10.A [Float]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute\nEXEC n11.False -> n13.Execute\nEXEC n13.Then -> n14.Execute", "source": "lesson:lesson_09:L09_10", "category": "nested_timer_branch"}
{"instruction": "bp with float health at 100. start a looping timer every 2 seconds. each tick subtract 10. if health > 50 print ok. else if health > 0 print warning. else clear timer and print dead.", "output": "BLUEPRINT: BP_HealthDrain\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Drain\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=Drain]\nNODE n4: VariableGet [VarName=Health]\nNODE n5: SubtractFloat [B=10.0]\nNODE n6: VariableSet [VarName=Health]\nNODE n7: GreaterThan [B=50.0]\nNODE n8: Branch\nNODE n9: PrintString [InString=\"OK\"]\nNODE n10: GreaterThan [B=0.0]\nNODE n11: Branch\nNODE n12: PrintString [InString=\"Warning\"]\nNODE n13: ClearTimerByFunctionName [FunctionName=\"Drain\"]\nNODE n14: PrintString [InString=\"Dead\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nEXEC n8.False -> n11.Execute\nDATA n6.Value -> n10.A [Float]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute\nEXEC n11.False -> n13.Execute\nEXEC n13.Then -> n14.Execute", "source": "lesson:lesson_09:L09_10", "category": "nested_timer_branch"}
{"instruction": "Create a Blueprint with integer Score. On BeginPlay if Score equals 100 print Perfect. Else print Try Again.", "output": "BLUEPRINT: BP_ScoreCheck\nPARENT: Actor\nVAR Score: Int = 100\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Score]\nNODE n3: EqualEqual [B=100]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Perfect\"]\nNODE n6: PrintString [InString=\"Try Again\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_09:L09_11", "category": "branch_equal"}
{"instruction": "bp with integer score. on beginplay if score equals 100 print perfect. else print try again.", "output": "BLUEPRINT: BP_ScoreCheck\nPARENT: Actor\nVAR Score: Int = 100\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Score]\nNODE n3: EqualEqual [B=100]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Perfect\"]\nNODE n6: PrintString [InString=\"Try Again\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_09:L09_11", "category": "branch_equal"}
{"instruction": "Create a Blueprint with bool A, bool B, bool C. On BeginPlay check A. If true check B. If B true check C. If all three true print All True. Each false branch prints the failing variable name.", "output": "BLUEPRINT: BP_TripleCheck\nPARENT: Actor\nVAR A: Bool = true\nVAR B: Bool = true\nVAR C: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=A]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=B]\nNODE n5: Branch\nNODE n6: VariableGet [VarName=C]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"All True\"]\nNODE n9: PrintString [InString=\"C Failed\"]\nNODE n10: PrintString [InString=\"B Failed\"]\nNODE n11: PrintString [InString=\"A Failed\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n6.Value -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\nEXEC n5.False -> n10.Execute\nEXEC n3.False -> n11.Execute", "source": "lesson:lesson_09:L09_12", "category": "nested_three_vars"}
{"instruction": "bp with bool a, bool b, bool c. on beginplay check a. if true check b. if b true check c. if all three true print all true. each false branch prints the failing variable name.", "output": "BLUEPRINT: BP_TripleCheck\nPARENT: Actor\nVAR A: Bool = true\nVAR B: Bool = true\nVAR C: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=A]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=B]\nNODE n5: Branch\nNODE n6: VariableGet [VarName=C]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"All True\"]\nNODE n9: PrintString [InString=\"C Failed\"]\nNODE n10: PrintString [InString=\"B Failed\"]\nNODE n11: PrintString [InString=\"A Failed\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n6.Value -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\nEXEC n5.False -> n10.Execute\nEXEC n3.False -> n11.Execute", "source": "lesson:lesson_09:L09_12", "category": "nested_three_vars"}
{"instruction": "Create a Blueprint with bool A, bool B, bool C. On BeginPlay check A. If true check B. If B true check C. If all three true print All True. Each false branch calls PrintString with text the failing variable name.", "output": "BLUEPRINT: BP_TripleCheck\nPARENT: Actor\nVAR A: Bool = true\nVAR B: Bool = true\nVAR C: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=A]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=B]\nNODE n5: Branch\nNODE n6: VariableGet [VarName=C]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"All True\"]\nNODE n9: PrintString [InString=\"C Failed\"]\nNODE n10: PrintString [InString=\"B Failed\"]\nNODE n11: PrintString [InString=\"A Failed\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n6.Value -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\nEXEC n5.False -> n10.Execute\nEXEC n3.False -> n11.Execute", "source": "lesson:lesson_09:L09_12", "category": "nested_three_vars"}
{"instruction": "Create a Blueprint with integer Mode. On BeginPlay switch on Mode. Case 1 sets a 1-second looping timer. Case 2 sets a 5-second looping timer. The timer prints Tick.", "output": "BLUEPRINT: BP_ModeTimer\nPARENT: Actor\nVAR Mode: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Mode]\nNODE n3: SwitchOnInt\nNODE n4: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=1.0, Looping=true]\nNODE n5: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=5.0, Looping=true]\nNODE n6: Event_Custom [EventName=OnTick]\nNODE n7: PrintString [InString=\"Tick\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_09:L09_13", "category": "switch_with_timer"}
{"instruction": "bp with integer mode. on beginplay switch on mode. case 1 sets a 1-second looping timer. case 2 sets a 5-second looping timer. the timer prints tick.", "output": "BLUEPRINT: BP_ModeTimer\nPARENT: Actor\nVAR Mode: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Mode]\nNODE n3: SwitchOnInt\nNODE n4: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=1.0, Looping=true]\nNODE n5: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=5.0, Looping=true]\nNODE n6: Event_Custom [EventName=OnTick]\nNODE n7: PrintString [InString=\"Tick\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_09:L09_13", "category": "switch_with_timer"}
{"instruction": "Create a Blueprint with integer Mode. On BeginPlay switch on Mode. Case 1 sets a 1-second looping timer. Case 2 sets a 5-second looping timer. The timer calls PrintString with text Tick.", "output": "BLUEPRINT: BP_ModeTimer\nPARENT: Actor\nVAR Mode: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Mode]\nNODE n3: SwitchOnInt\nNODE n4: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=1.0, Looping=true]\nNODE n5: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=5.0, Looping=true]\nNODE n6: Event_Custom [EventName=OnTick]\nNODE n7: PrintString [InString=\"Tick\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_09:L09_13", "category": "switch_with_timer"}
{"instruction": "Create a Blueprint with float Value. On BeginPlay if Value greater than 100, set to 100. If less than 0, set to 0. Print the final value.", "output": "BLUEPRINT: BP_ClampValue\nPARENT: Actor\nVAR Value: Float = 150.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Value]\nNODE n3: GreaterThan [B=100.0]\nNODE n4: Branch\nNODE n5: VariableSet [VarName=Value]\nNODE n6: LessThan [B=0.0]\nNODE n7: Branch\nNODE n8: VariableSet [VarName=Value]\nNODE n9: VariableGet [VarName=Value]\nNODE n10: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA 100.0 -> n5.Value [Float]\nEXEC n5.Then -> n10.Execute\nEXEC n4.False -> n7.Execute\nDATA n2.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nDATA 0.0 -> n8.Value [Float]\nEXEC n8.Then -> n10.Execute\nEXEC n7.False -> n10.Execute\nDATA n9.Value -> n10.InString [String]", "source": "lesson:lesson_09:L09_14", "category": "branch_clamp"}
{"instruction": "bp with float value. on beginplay if value greater than 100, set to 100. if less than 0, set to 0. print the final value.", "output": "BLUEPRINT: BP_ClampValue\nPARENT: Actor\nVAR Value: Float = 150.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Value]\nNODE n3: GreaterThan [B=100.0]\nNODE n4: Branch\nNODE n5: VariableSet [VarName=Value]\nNODE n6: LessThan [B=0.0]\nNODE n7: Branch\nNODE n8: VariableSet [VarName=Value]\nNODE n9: VariableGet [VarName=Value]\nNODE n10: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA 100.0 -> n5.Value [Float]\nEXEC n5.Then -> n10.Execute\nEXEC n4.False -> n7.Execute\nDATA n2.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nDATA 0.0 -> n8.Value [Float]\nEXEC n8.Then -> n10.Execute\nEXEC n7.False -> n10.Execute\nDATA n9.Value -> n10.InString [String]", "source": "lesson:lesson_09:L09_14", "category": "branch_clamp"}
{"instruction": "Create a Blueprint with bool IsDay and bool HasTorch. On overlap if IsDay OR HasTorch print Can See. Else print Darkness.", "output": "BLUEPRINT: BP_VisionCheck\nPARENT: Actor\nVAR IsDay: Bool = false\nVAR HasTorch: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=IsDay]\nNODE n3: VariableGet [VarName=HasTorch]\nNODE n4: BooleanOR\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Can See\"]\nNODE n7: PrintString [InString=\"Darkness\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n4.A [Bool]\nDATA n3.Value -> n4.B [Bool]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_09:L09_15", "category": "branch_or_pattern"}
{"instruction": "bp with bool isday and bool hastorch. on overlap if isday or hastorch print can see. else print darkness.", "output": "BLUEPRINT: BP_VisionCheck\nPARENT: Actor\nVAR IsDay: Bool = false\nVAR HasTorch: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=IsDay]\nNODE n3: VariableGet [VarName=HasTorch]\nNODE n4: BooleanOR\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Can See\"]\nNODE n7: PrintString [InString=\"Darkness\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n4.A [Bool]\nDATA n3.Value -> n4.B [Bool]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_09:L09_15", "category": "branch_or_pattern"}
{"instruction": "Create a Blueprint with string DamageType and float Armor. On AnyDamage if DamageType equals Fire and Armor less than 50 print Burned. If DamageType equals Fire and armor 50+ print Resisted. If not fire print Hit.", "output": "BLUEPRINT: BP_DamageResponse\nPARENT: Actor\nVAR Armor: Float = 30.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: EqualEqual [B=\"Fire\"]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=Armor]\nNODE n5: LessThan [B=50.0]\nNODE n6: Branch\nNODE n7: PrintString [InString=\"Burned\"]\nNODE n8: PrintString [InString=\"Resisted\"]\nNODE n9: PrintString [InString=\"Hit\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Condition [Bool]\nEXEC n3.True -> n6.Execute\nDATA n4.Value -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n7.Execute\nEXEC n6.False -> n8.Execute\nEXEC n3.False -> n9.Execute", "source": "lesson:lesson_09:L09_16", "category": "nested_damage_type"}
{"instruction": "bp with string damagetype and float armor. on anydamage if damagetype equals fire and armor less than 50 print burned. if damagetype equals fire and armor 50+ print resisted. if not fire print hit.", "output": "BLUEPRINT: BP_DamageResponse\nPARENT: Actor\nVAR Armor: Float = 30.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: EqualEqual [B=\"Fire\"]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=Armor]\nNODE n5: LessThan [B=50.0]\nNODE n6: Branch\nNODE n7: PrintString [InString=\"Burned\"]\nNODE n8: PrintString [InString=\"Resisted\"]\nNODE n9: PrintString [InString=\"Hit\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Condition [Bool]\nEXEC n3.True -> n6.Execute\nDATA n4.Value -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n7.Execute\nEXEC n6.False -> n8.Execute\nEXEC n3.False -> n9.Execute", "source": "lesson:lesson_09:L09_16", "category": "nested_damage_type"}
{"instruction": "Create a Blueprint with integer EnemyType. On BeginPlay switch on EnemyType. Case 1 spawns BP_Goblin. Case 2 spawns BP_Skeleton. Case 3 spawns BP_Dragon. All spawn at actor location.", "output": "BLUEPRINT: BP_EnemySpawner\nPARENT: Actor\nVAR EnemyType: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=EnemyType]\nNODE n3: SwitchOnInt\nNODE n4: GetActorLocation\nNODE n5: SpawnActorFromClass [ActorClass=BP_Goblin]\nNODE n6: SpawnActorFromClass [ActorClass=BP_Skeleton]\nNODE n7: SpawnActorFromClass [ActorClass=BP_Dragon]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n5.Execute\nEXEC n3.Case_2 -> n6.Execute\nEXEC n3.Case_3 -> n7.Execute\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]\nDATA n4.ReturnValue -> n6.SpawnTransform [Transform]\nDATA n4.ReturnValue -> n7.SpawnTransform [Transform]", "source": "lesson:lesson_09:L09_17", "category": "switch_spawn"}
{"instruction": "bp with integer enemytype. on beginplay switch on enemytype. case 1 spawns bp_goblin. case 2 spawns bp_skeleton. case 3 spawns bp_dragon. all spawn at actor location.", "output": "BLUEPRINT: BP_EnemySpawner\nPARENT: Actor\nVAR EnemyType: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=EnemyType]\nNODE n3: SwitchOnInt\nNODE n4: GetActorLocation\nNODE n5: SpawnActorFromClass [ActorClass=BP_Goblin]\nNODE n6: SpawnActorFromClass [ActorClass=BP_Skeleton]\nNODE n7: SpawnActorFromClass [ActorClass=BP_Dragon]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n5.Execute\nEXEC n3.Case_2 -> n6.Execute\nEXEC n3.Case_3 -> n7.Execute\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]\nDATA n4.ReturnValue -> n6.SpawnTransform [Transform]\nDATA n4.ReturnValue -> n7.SpawnTransform [Transform]", "source": "lesson:lesson_09:L09_17", "category": "switch_spawn"}
{"instruction": "Create a Blueprint with float Temperature. On BeginPlay if Temperature less than 0 print Freezing. If between 0 and 30 print Normal. If above 30 print Hot.", "output": "BLUEPRINT: BP_TempCheck\nPARENT: Actor\nVAR Temperature: Float = 20.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Temperature]\nNODE n3: LessThan [B=0.0]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Freezing\"]\nNODE n6: GreaterThan [B=30.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Hot\"]\nNODE n9: PrintString [InString=\"Normal\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n7.Execute\nDATA n2.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute", "source": "lesson:lesson_09:L09_18", "category": "branch_range_check"}
{"instruction": "bp with float temperature. on beginplay if temperature less than 0 print freezing. if between 0 and 30 print normal. if above 30 print hot.", "output": "BLUEPRINT: BP_TempCheck\nPARENT: Actor\nVAR Temperature: Float = 20.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Temperature]\nNODE n3: LessThan [B=0.0]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Freezing\"]\nNODE n6: GreaterThan [B=30.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Hot\"]\nNODE n9: PrintString [InString=\"Normal\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n7.Execute\nDATA n2.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute", "source": "lesson:lesson_09:L09_18", "category": "branch_range_check"}
{"instruction": "Create a Blueprint with actor variable Target. On Tick check if Target is valid. If valid check distance less than 500. If close print Tracking. If far print Searching. If invalid print No Target.", "output": "BLUEPRINT: BP_TargetStatus\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=500.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Tracking\"]\nNODE n9: PrintString [InString=\"Searching\"]\nNODE n10: PrintString [InString=\"No Target\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.Value -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\nEXEC n4.False -> n10.Execute", "source": "lesson:lesson_09:L09_19", "category": "nested_valid_branch"}
{"instruction": "bp with actor variable target. on tick check if target is valid. if valid check distance less than 500. if close print tracking. if far print searching. if invalid print no target.", "output": "BLUEPRINT: BP_TargetStatus\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=500.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Tracking\"]\nNODE n9: PrintString [InString=\"Searching\"]\nNODE n10: PrintString [InString=\"No Target\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.Value -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\nEXEC n4.False -> n10.Execute", "source": "lesson:lesson_09:L09_19", "category": "nested_valid_branch"}
{"instruction": "Create a Blueprint with integer Screen. On pressing Menu switch on Screen. Case 0 creates WBP_MainMenu. Case 1 creates WBP_Inventory. Case 2 creates WBP_Map. Add each to viewport.", "output": "BLUEPRINT: BP_ScreenSwitch\nPARENT: Actor\nVAR Screen: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Menu\"]\nNODE n2: VariableGet [VarName=Screen]\nNODE n3: SwitchOnInt\nNODE n4: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n5: AddToViewport\nNODE n6: CreateWidget [WidgetClass=WBP_Inventory]\nNODE n7: AddToViewport\nNODE n8: CreateWidget [WidgetClass=WBP_Map]\nNODE n9: AddToViewport\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_0 -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n3.Case_1 -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Target [Widget]\nEXEC n3.Case_2 -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Target [Widget]", "source": "lesson:lesson_09:L09_20", "category": "switch_with_ui"}
{"instruction": "bp with integer screen. on pressing menu switch on screen. case 0 creates wbp_mainmenu. case 1 creates wbp_inventory. case 2 creates wbp_map. add each to viewport.", "output": "BLUEPRINT: BP_ScreenSwitch\nPARENT: Actor\nVAR Screen: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Menu\"]\nNODE n2: VariableGet [VarName=Screen]\nNODE n3: SwitchOnInt\nNODE n4: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n5: AddToViewport\nNODE n6: CreateWidget [WidgetClass=WBP_Inventory]\nNODE n7: AddToViewport\nNODE n8: CreateWidget [WidgetClass=WBP_Map]\nNODE n9: AddToViewport\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_0 -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n3.Case_1 -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Target [Widget]\nEXEC n3.Case_2 -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Target [Widget]", "source": "lesson:lesson_09:L09_20", "category": "switch_with_ui"}
{"instruction": "Create a Blueprint for a health pickup. On overlap cast to Character. If cast succeeds add 25 to a Health variable, play a sound, and destroy the actor.", "output": "BLUEPRINT: BP_HealthPickup\nPARENT: Actor\nVAR Health: Float = 25.0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableGet [VarName=Health]\nNODE n4: PlaySoundAtLocation [Sound=PickupSound]\nNODE n5: GetActorLocation\nNODE n6: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n5.ReturnValue -> n4.Location [Vector]\nEXEC n4.Then -> n6.Execute", "source": "lesson:lesson_10:L10_01", "category": "pickup_full"}
{"instruction": "bp for a health pickup. on overlap cast to character. if cast succeeds add 25 to a health variable, play a sound, and destroy the actor.", "output": "BLUEPRINT: BP_HealthPickup\nPARENT: Actor\nVAR Health: Float = 25.0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableGet [VarName=Health]\nNODE n4: PlaySoundAtLocation [Sound=PickupSound]\nNODE n5: GetActorLocation\nNODE n6: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n5.ReturnValue -> n4.Location [Vector]\nEXEC n4.Then -> n6.Execute", "source": "lesson:lesson_10:L10_01", "category": "pickup_full"}
{"instruction": "Create a Blueprint for a trap. On overlap enable physics on the overlapping actor, add downward impulse of 5000, wait 2 seconds, then destroy self.", "output": "BLUEPRINT: BP_TrapFloor\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: AddImpulse [Impulse=(X=0,Y=0,Z=-5000)]\nNODE n4: Delay [Duration=2.0]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nEXEC n2.Then -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_10:L10_02", "category": "trap_floor"}
{"instruction": "bp for a trap. on overlap enable physics on the overlapping actor, add downward impulse of 5000, wait 2 seconds, then destroy self.", "output": "BLUEPRINT: BP_TrapFloor\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: AddImpulse [Impulse=(X=0,Y=0,Z=-5000)]\nNODE n4: Delay [Duration=2.0]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nEXEC n2.Then -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_10:L10_02", "category": "trap_floor"}
{"instruction": "Create a Blueprint for an interactive door. On pressing Interact check distance to player. If less than 200 use FlipFlop. A path rotates door 90 degrees and prints Open. B path rotates back and prints Closed.", "output": "BLUEPRINT: BP_InteractiveDoor\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: FlipFlop\nNODE n7: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=90,Roll=0)]\nNODE n8: PrintString [InString=\"Open\"]\nNODE n9: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=-90,Roll=0)]\nNODE n10: PrintString [InString=\"Closed\"]\nEXEC n1.Pressed -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.A -> n7.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n6.B -> n9.Execute\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_10:L10_03", "category": "door_interact"}
{"instruction": "bp for an interactive door. on pressing interact check distance to player. if less than 200 use flipflop. a path rotates door 90 degrees and prints open. b path rotates back and prints closed.", "output": "BLUEPRINT: BP_InteractiveDoor\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: FlipFlop\nNODE n7: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=90,Roll=0)]\nNODE n8: PrintString [InString=\"Open\"]\nNODE n9: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=-90,Roll=0)]\nNODE n10: PrintString [InString=\"Closed\"]\nEXEC n1.Pressed -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.A -> n7.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n6.B -> n9.Execute\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_10:L10_03", "category": "door_interact"}
{"instruction": "Create a Blueprint for an interactive door. On pressing Interact check distance to player. If less than 200 use FlipFlop. A path rotates door 90 degrees and calls PrintString with text Open. B path rotates back and calls PrintString with text Closed.", "output": "BLUEPRINT: BP_InteractiveDoor\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: FlipFlop\nNODE n7: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=90,Roll=0)]\nNODE n8: PrintString [InString=\"Open\"]\nNODE n9: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=-90,Roll=0)]\nNODE n10: PrintString [InString=\"Closed\"]\nEXEC n1.Pressed -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.A -> n7.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n6.B -> n9.Execute\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_10:L10_03", "category": "door_interact"}
{"instruction": "Create a Blueprint that spawns enemies in waves. On BeginPlay set a looping timer every 5 seconds. Each tick increment a WaveCount variable, spawn BP_Enemy at actor location, and print the wave number. After 5 waves clear the timer.", "output": "BLUEPRINT: BP_WaveSpawner\nPARENT: Actor\nVAR WaveCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnWave\", Time=5.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnWave]\nNODE n4: VariableGet [VarName=WaveCount]\nNODE n5: AddInt [B=1]\nNODE n6: VariableSet [VarName=WaveCount]\nNODE n7: GetActorLocation\nNODE n8: SpawnActorFromClass [ActorClass=BP_Enemy]\nNODE n9: PrintString\nNODE n10: GreaterThan [B=4]\nNODE n11: Branch\nNODE n12: ClearTimerByFunctionName [FunctionName=\"SpawnWave\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Value [Int]\nEXEC n6.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.SpawnTransform [Transform]\nEXEC n8.Then -> n9.Execute\nDATA n6.Value -> n9.InString [String]\nEXEC n9.Then -> n11.Execute\nDATA n6.Value -> n10.A [Int]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute", "source": "lesson:lesson_10:L10_04", "category": "spawner_waves"}
{"instruction": "make a bp that spawns enemies in waves. on beginplay set a looping timer every 5 seconds. each tick increment a wavecount variable, spawn bp_enemy at actor location, and print the wave number. after 5 waves clear the timer.", "output": "BLUEPRINT: BP_WaveSpawner\nPARENT: Actor\nVAR WaveCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnWave\", Time=5.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnWave]\nNODE n4: VariableGet [VarName=WaveCount]\nNODE n5: AddInt [B=1]\nNODE n6: VariableSet [VarName=WaveCount]\nNODE n7: GetActorLocation\nNODE n8: SpawnActorFromClass [ActorClass=BP_Enemy]\nNODE n9: PrintString\nNODE n10: GreaterThan [B=4]\nNODE n11: Branch\nNODE n12: ClearTimerByFunctionName [FunctionName=\"SpawnWave\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Value [Int]\nEXEC n6.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.SpawnTransform [Transform]\nEXEC n8.Then -> n9.Execute\nDATA n6.Value -> n9.InString [String]\nEXEC n9.Then -> n11.Execute\nDATA n6.Value -> n10.A [Int]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute", "source": "lesson:lesson_10:L10_04", "category": "spawner_waves"}
{"instruction": "Create a Blueprint for a checkpoint. On overlap cast to Character. If success, use DoOnce, save the actor location to a variable SavedLocation, play a sound, and print Checkpoint Saved.", "output": "BLUEPRINT: BP_Checkpoint\nPARENT: Actor\nVAR SavedLocation: Vector\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: DoOnce\nNODE n4: GetActorLocation\nNODE n5: VariableSet [VarName=SavedLocation]\nNODE n6: PlaySoundAtLocation [Sound=CheckpointSound]\nNODE n7: PrintString [InString=\"Checkpoint Saved\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Completed -> n5.Execute\nDATA n4.ReturnValue -> n5.Value [Vector]\nEXEC n5.Then -> n6.Execute\nDATA n4.ReturnValue -> n6.Location [Vector]\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_05", "category": "checkpoint"}
{"instruction": "bp for a checkpoint. on overlap cast to character. if success, use doonce, save the actor location to a variable savedlocation, play a sound, and print checkpoint saved.", "output": "BLUEPRINT: BP_Checkpoint\nPARENT: Actor\nVAR SavedLocation: Vector\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: DoOnce\nNODE n4: GetActorLocation\nNODE n5: VariableSet [VarName=SavedLocation]\nNODE n6: PlaySoundAtLocation [Sound=CheckpointSound]\nNODE n7: PrintString [InString=\"Checkpoint Saved\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Completed -> n5.Execute\nDATA n4.ReturnValue -> n5.Value [Vector]\nEXEC n5.Then -> n6.Execute\nDATA n4.ReturnValue -> n6.Location [Vector]\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_05", "category": "checkpoint"}
{"instruction": "Create a Blueprint for a damage zone. On overlap start a looping timer every 1 second. Each tick subtract 10 from Health variable and print the health. On end overlap clear the timer.", "output": "BLUEPRINT: BP_DamageZone\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: SetTimerByFunctionName [FunctionName=\"DealDamage\", Time=1.0, Looping=true]\nNODE n3: Event_ActorEndOverlap\nNODE n4: ClearTimerByFunctionName [FunctionName=\"DealDamage\"]\nNODE n5: Event_Custom [EventName=DealDamage]\nNODE n6: VariableGet [VarName=Health]\nNODE n7: SubtractFloat [B=10.0]\nNODE n8: VariableSet [VarName=Health]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:lesson_10:L10_06", "category": "damage_zone"}
{"instruction": "bp for a damage zone. on overlap start a looping timer every 1 second. each tick subtract 10 from health variable and print the health. on end overlap clear the timer.", "output": "BLUEPRINT: BP_DamageZone\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: SetTimerByFunctionName [FunctionName=\"DealDamage\", Time=1.0, Looping=true]\nNODE n3: Event_ActorEndOverlap\nNODE n4: ClearTimerByFunctionName [FunctionName=\"DealDamage\"]\nNODE n5: Event_Custom [EventName=DealDamage]\nNODE n6: VariableGet [VarName=Health]\nNODE n7: SubtractFloat [B=10.0]\nNODE n8: VariableSet [VarName=Health]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:lesson_10:L10_06", "category": "damage_zone"}
{"instruction": "Create a Blueprint for a collectible coin. On overlap cast to Character. If success, increment a CoinCount variable, play sound at location, print the count, and destroy self.", "output": "BLUEPRINT: BP_Coin\nPARENT: Actor\nVAR CoinCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableGet [VarName=CoinCount]\nNODE n4: AddInt [B=1]\nNODE n5: VariableSet [VarName=CoinCount]\nNODE n6: GetActorLocation\nNODE n7: PlaySoundAtLocation [Sound=CoinSound]\nNODE n8: PrintString\nNODE n9: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n5.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n4.ReturnValue -> n5.Value [Int]\nEXEC n5.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Location [Vector]\nEXEC n7.Then -> n8.Execute\nDATA n5.Value -> n8.InString [String]\nEXEC n8.Then -> n9.Execute", "source": "lesson:lesson_10:L10_07", "category": "collectible_counter"}
{"instruction": "bp for a collectible coin. on overlap cast to character. if success, increment a coincount variable, play sound at location, print the count, and destroy self.", "output": "BLUEPRINT: BP_Coin\nPARENT: Actor\nVAR CoinCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableGet [VarName=CoinCount]\nNODE n4: AddInt [B=1]\nNODE n5: VariableSet [VarName=CoinCount]\nNODE n6: GetActorLocation\nNODE n7: PlaySoundAtLocation [Sound=CoinSound]\nNODE n8: PrintString\nNODE n9: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n5.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n4.ReturnValue -> n5.Value [Int]\nEXEC n5.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Location [Vector]\nEXEC n7.Then -> n8.Execute\nDATA n5.Value -> n8.InString [String]\nEXEC n8.Then -> n9.Execute", "source": "lesson:lesson_10:L10_07", "category": "collectible_counter"}
{"instruction": "Create a Blueprint for a disappearing platform. On BeginPlay use a Sequence. First output makes it visible. Second output waits 3 seconds, hides it, waits 2 seconds, shows it again, looping with a timer.", "output": "BLUEPRINT: BP_BlinkPlatform\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetActorHiddenInGame [NewHidden=false]\nNODE n3: SetTimerByFunctionName [FunctionName=\"Blink\", Time=5.0, Looping=true]\nNODE n4: Event_Custom [EventName=Blink]\nNODE n5: SetActorHiddenInGame [NewHidden=true]\nNODE n6: Delay [Duration=2.0]\nNODE n7: SetActorHiddenInGame [NewHidden=false]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "source": "lesson:lesson_10:L10_08", "category": "timed_platform"}
{"instruction": "bp for a disappearing platform. on beginplay use a sequence. first output makes it visible. second output waits 3 seconds, hides it, waits 2 seconds, shows it again, looping with a timer.", "output": "BLUEPRINT: BP_BlinkPlatform\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetActorHiddenInGame [NewHidden=false]\nNODE n3: SetTimerByFunctionName [FunctionName=\"Blink\", Time=5.0, Looping=true]\nNODE n4: Event_Custom [EventName=Blink]\nNODE n5: SetActorHiddenInGame [NewHidden=true]\nNODE n6: Delay [Duration=2.0]\nNODE n7: SetActorHiddenInGame [NewHidden=false]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "source": "lesson:lesson_10:L10_08", "category": "timed_platform"}
{"instruction": "Create a Blueprint for a disappearing platform. On BeginPlay use a Sequence. First output makes it visible. Second output uses a Delay node for 3 seconds, hides it, uses a Delay node for 2 seconds, shows it again, looping with a timer.", "output": "BLUEPRINT: BP_BlinkPlatform\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetActorHiddenInGame [NewHidden=false]\nNODE n3: SetTimerByFunctionName [FunctionName=\"Blink\", Time=5.0, Looping=true]\nNODE n4: Event_Custom [EventName=Blink]\nNODE n5: SetActorHiddenInGame [NewHidden=true]\nNODE n6: Delay [Duration=2.0]\nNODE n7: SetActorHiddenInGame [NewHidden=false]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "source": "lesson:lesson_10:L10_08", "category": "timed_platform"}
{"instruction": "Create a Blueprint for a simple enemy. On Tick get distance to player. If less than 500 print Alert and move toward player using Lerp. If more than 500 print Patrolling.", "output": "BLUEPRINT: BP_SimpleEnemy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=500.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Alert\"]\nNODE n7: GetActorLocation\nNODE n8: Lerp [Alpha=0.02]\nNODE n9: SetActorLocation\nNODE n10: PrintString [InString=\"Patrolling\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.Then -> n9.Execute\nDATA n7.ReturnValue -> n8.A [Vector]\nDATA n8.ReturnValue -> n9.NewLocation [Vector]\nEXEC n5.False -> n10.Execute", "source": "lesson:lesson_10:L10_09", "category": "enemy_proximity"}
{"instruction": "bp for a simple enemy. on tick get distance to player. if less than 500 print alert and move toward player using lerp. if more than 500 print patrolling.", "output": "BLUEPRINT: BP_SimpleEnemy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=500.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Alert\"]\nNODE n7: GetActorLocation\nNODE n8: Lerp [Alpha=0.02]\nNODE n9: SetActorLocation\nNODE n10: PrintString [InString=\"Patrolling\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.Then -> n9.Execute\nDATA n7.ReturnValue -> n8.A [Vector]\nDATA n8.ReturnValue -> n9.NewLocation [Vector]\nEXEC n5.False -> n10.Execute", "source": "lesson:lesson_10:L10_09", "category": "enemy_proximity"}
{"instruction": "Create a Blueprint for a speed power-up. On overlap cast to Character. If success, set variable SpeedBoost to true, wait 5 seconds, set SpeedBoost to false, print Boost Expired, and destroy self.", "output": "BLUEPRINT: BP_SpeedBoost\nPARENT: Actor\nVAR SpeedBoost: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableSet [VarName=SpeedBoost]\nNODE n4: Delay [Duration=5.0]\nNODE n5: VariableSet [VarName=SpeedBoost]\nNODE n6: PrintString [InString=\"Boost Expired\"]\nNODE n7: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nDATA true -> n3.Value [Bool]\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nDATA false -> n5.Value [Bool]\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_10", "category": "power_up"}
{"instruction": "bp for a speed power-up. on overlap cast to character. if success, set variable speedboost to true, wait 5 seconds, set speedboost to false, print boost expired, and destroy self.", "output": "BLUEPRINT: BP_SpeedBoost\nPARENT: Actor\nVAR SpeedBoost: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableSet [VarName=SpeedBoost]\nNODE n4: Delay [Duration=5.0]\nNODE n5: VariableSet [VarName=SpeedBoost]\nNODE n6: PrintString [InString=\"Boost Expired\"]\nNODE n7: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nDATA true -> n3.Value [Bool]\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nDATA false -> n5.Value [Bool]\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_10", "category": "power_up"}
{"instruction": "Create a Blueprint with integer PickupType. On overlap switch on PickupType. Case 1 adds 25 health. Case 2 adds 50 health. Case 3 adds 10 to armor. All cases play a sound and destroy self.", "output": "BLUEPRINT: BP_MultiPickup\nPARENT: Actor\nVAR PickupType: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=PickupType]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Health +25\"]\nNODE n5: PrintString [InString=\"Health +50\"]\nNODE n6: PrintString [InString=\"Armor +10\"]\nNODE n7: GetActorLocation\nNODE n8: PlaySoundAtLocation [Sound=PickupSound]\nNODE n9: DestroyActor\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute\nEXEC n4.Then -> n8.Execute\nEXEC n5.Then -> n8.Execute\nEXEC n6.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Location [Vector]\nEXEC n8.Then -> n9.Execute", "source": "lesson:lesson_10:L10_11", "category": "multi_pickup"}
{"instruction": "bp with integer pickuptype. on overlap switch on pickuptype. case 1 adds 25 health. case 2 adds 50 health. case 3 adds 10 to armor. all cases play a sound and destroy self.", "output": "BLUEPRINT: BP_MultiPickup\nPARENT: Actor\nVAR PickupType: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=PickupType]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Health +25\"]\nNODE n5: PrintString [InString=\"Health +50\"]\nNODE n6: PrintString [InString=\"Armor +10\"]\nNODE n7: GetActorLocation\nNODE n8: PlaySoundAtLocation [Sound=PickupSound]\nNODE n9: DestroyActor\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute\nEXEC n4.Then -> n8.Execute\nEXEC n5.Then -> n8.Execute\nEXEC n6.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Location [Vector]\nEXEC n8.Then -> n9.Execute", "source": "lesson:lesson_10:L10_11", "category": "multi_pickup"}
{"instruction": "Create a Blueprint for a turret. On BeginPlay set a looping timer every 2 seconds. Each tick get distance to player. If less than 1000, spawn BP_Projectile at actor location and print Firing.", "output": "BLUEPRINT: BP_Turret\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"TurretTick\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=TurretTick]\nNODE n4: GetPlayerPawn\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=1000.0]\nNODE n7: Branch\nNODE n8: GetActorLocation\nNODE n9: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n10: PrintString [InString=\"Firing\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n7.Execute\nDATA n4.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n9.Execute\nDATA n8.ReturnValue -> n9.SpawnTransform [Transform]\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_10:L10_12", "category": "turret_basic"}
{"instruction": "bp for a turret. on beginplay set a looping timer every 2 seconds. each tick get distance to player. if less than 1000, spawn bp_projectile at actor location and print firing.", "output": "BLUEPRINT: BP_Turret\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"TurretTick\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=TurretTick]\nNODE n4: GetPlayerPawn\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=1000.0]\nNODE n7: Branch\nNODE n8: GetActorLocation\nNODE n9: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n10: PrintString [InString=\"Firing\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n7.Execute\nDATA n4.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n9.Execute\nDATA n8.ReturnValue -> n9.SpawnTransform [Transform]\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_10:L10_12", "category": "turret_basic"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_HealthBar and adds to viewport. On AnyDamage subtract damage from Health variable. If Health less than 0 remove widget and destroy actor.", "output": "BLUEPRINT: BP_HealthHUD\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR HealthBar: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HealthBar]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HealthBar]\nNODE n5: Event_AnyDamage\nNODE n6: VariableGet [VarName=Health]\nNODE n7: SubtractFloat\nNODE n8: VariableSet [VarName=Health]\nNODE n9: LessThan [B=0.0]\nNODE n10: Branch\nNODE n11: VariableGet [VarName=HealthBar]\nNODE n12: RemoveFromParent\nNODE n13: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n5.Damage -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n10.Execute\nDATA n8.Value -> n9.A [Float]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n12.Execute\nDATA n11.Value -> n12.Target [Widget]\nEXEC n12.Then -> n13.Execute", "source": "lesson:lesson_10:L10_13", "category": "hud_health"}
{"instruction": "make a bp that on beginplay creates wbp_healthbar and adds to viewport. on anydamage subtract damage from health variable. if health less than 0 remove widget and destroy actor.", "output": "BLUEPRINT: BP_HealthHUD\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR HealthBar: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HealthBar]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HealthBar]\nNODE n5: Event_AnyDamage\nNODE n6: VariableGet [VarName=Health]\nNODE n7: SubtractFloat\nNODE n8: VariableSet [VarName=Health]\nNODE n9: LessThan [B=0.0]\nNODE n10: Branch\nNODE n11: VariableGet [VarName=HealthBar]\nNODE n12: RemoveFromParent\nNODE n13: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n5.Damage -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n10.Execute\nDATA n8.Value -> n9.A [Float]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n12.Execute\nDATA n11.Value -> n12.Target [Widget]\nEXEC n12.Then -> n13.Execute", "source": "lesson:lesson_10:L10_13", "category": "hud_health"}
{"instruction": "Create a Blueprint for a projectile. On BeginPlay enable physics, add forward impulse of 3000, set a 5-second self-destruct timer. On Hit print Impact and destroy self.", "output": "BLUEPRINT: BP_Projectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: GetActorForwardVector\nNODE n4: MultiplyFloat [B=3000.0]\nNODE n5: AddImpulse\nNODE n6: SetTimerByFunctionName [FunctionName=\"SelfDestruct\", Time=5.0, Looping=false]\nNODE n7: Event_Custom [EventName=SelfDestruct]\nNODE n8: DestroyActor\nNODE n9: Event_Hit\nNODE n10: PrintString [InString=\"Impact\"]\nNODE n11: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.A [Vector]\nDATA n4.ReturnValue -> n5.Impulse [Vector]\nEXEC n5.Then -> n6.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n9.Then -> n10.Execute\nEXEC n10.Then -> n11.Execute", "source": "lesson:lesson_10:L10_14", "category": "projectile_full"}
{"instruction": "bp for a projectile. on beginplay enable physics, add forward impulse of 3000, set a 5-second self-destruct timer. on hit print impact and destroy self.", "output": "BLUEPRINT: BP_Projectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: GetActorForwardVector\nNODE n4: MultiplyFloat [B=3000.0]\nNODE n5: AddImpulse\nNODE n6: SetTimerByFunctionName [FunctionName=\"SelfDestruct\", Time=5.0, Looping=false]\nNODE n7: Event_Custom [EventName=SelfDestruct]\nNODE n8: DestroyActor\nNODE n9: Event_Hit\nNODE n10: PrintString [InString=\"Impact\"]\nNODE n11: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.A [Vector]\nDATA n4.ReturnValue -> n5.Impulse [Vector]\nEXEC n5.Then -> n6.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n9.Then -> n10.Execute\nEXEC n10.Then -> n11.Execute", "source": "lesson:lesson_10:L10_14", "category": "projectile_full"}
{"instruction": "Create a Blueprint for a pressure plate. On overlap open a Gate. The gate exit activates a looping timer that prints Active every 1 second. On end overlap close the gate and clear the timer.", "output": "BLUEPRINT: BP_PressurePlate\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"Activate\", Time=1.0, Looping=true]\nNODE n4: Event_Custom [EventName=Activate]\nNODE n5: PrintString [InString=\"Active\"]\nNODE n6: Event_ActorEndOverlap\nNODE n7: ClearTimerByFunctionName [FunctionName=\"Activate\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n6.Then -> n2.Close\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_15", "category": "pressure_plate"}
{"instruction": "bp for a pressure plate. on overlap open a gate. the gate exit activates a looping timer that prints active every 1 second. on end overlap close the gate and clear the timer.", "output": "BLUEPRINT: BP_PressurePlate\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"Activate\", Time=1.0, Looping=true]\nNODE n4: Event_Custom [EventName=Activate]\nNODE n5: PrintString [InString=\"Active\"]\nNODE n6: Event_ActorEndOverlap\nNODE n7: ClearTimerByFunctionName [FunctionName=\"Activate\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n6.Then -> n2.Close\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_15", "category": "pressure_plate"}
{"instruction": "Create a Blueprint for a pressure plate. On overlap open a Gate. The gate exit activates a looping timer that calls PrintString with text Active every 1 second. On end overlap close the gate and clear the timer.", "output": "BLUEPRINT: BP_PressurePlate\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"Activate\", Time=1.0, Looping=true]\nNODE n4: Event_Custom [EventName=Activate]\nNODE n5: PrintString [InString=\"Active\"]\nNODE n6: Event_ActorEndOverlap\nNODE n7: ClearTimerByFunctionName [FunctionName=\"Activate\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n6.Then -> n2.Close\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_15", "category": "pressure_plate"}
{"instruction": "Create a Blueprint with vector SpawnPoint. On BeginPlay save actor location to SpawnPoint. When Health reaches 0, reset Health to 100, teleport to SpawnPoint, and print Respawned.", "output": "BLUEPRINT: BP_Respawn\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR SpawnPoint: Vector\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: VariableSet [VarName=SpawnPoint]\nNODE n4: Event_AnyDamage\nNODE n5: VariableGet [VarName=Health]\nNODE n6: SubtractFloat\nNODE n7: VariableSet [VarName=Health]\nNODE n8: LessThan [B=1.0]\nNODE n9: Branch\nNODE n10: VariableSet [VarName=Health]\nNODE n11: VariableGet [VarName=SpawnPoint]\nNODE n12: SetActorLocation\nNODE n13: PrintString [InString=\"Respawned\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Vector]\nEXEC n4.Then -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n4.Damage -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute\nDATA 100.0 -> n10.Value [Float]\nEXEC n10.Then -> n12.Execute\nDATA n11.Value -> n12.NewLocation [Vector]\nEXEC n12.Then -> n13.Execute", "source": "lesson:lesson_10:L10_16", "category": "respawn_system"}
{"instruction": "bp with vector spawnpoint. on beginplay save actor location to spawnpoint. when health reaches 0, reset health to 100, teleport to spawnpoint, and print respawned.", "output": "BLUEPRINT: BP_Respawn\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR SpawnPoint: Vector\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: VariableSet [VarName=SpawnPoint]\nNODE n4: Event_AnyDamage\nNODE n5: VariableGet [VarName=Health]\nNODE n6: SubtractFloat\nNODE n7: VariableSet [VarName=Health]\nNODE n8: LessThan [B=1.0]\nNODE n9: Branch\nNODE n10: VariableSet [VarName=Health]\nNODE n11: VariableGet [VarName=SpawnPoint]\nNODE n12: SetActorLocation\nNODE n13: PrintString [InString=\"Respawned\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Vector]\nEXEC n4.Then -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n4.Damage -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute\nDATA 100.0 -> n10.Value [Float]\nEXEC n10.Then -> n12.Execute\nDATA n11.Value -> n12.NewLocation [Vector]\nEXEC n12.Then -> n13.Execute", "source": "lesson:lesson_10:L10_16", "category": "respawn_system"}
{"instruction": "Create a Blueprint for a platform that moves between two points. Use a float variable Alpha going from 0 to 1 on Tick. Lerp between PointA and PointB using Alpha. When Alpha reaches 1, reverse direction.", "output": "BLUEPRINT: BP_MovingPlatform\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nVAR Direction: Float = 1.0\nVAR Speed: Float = 0.5\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: VariableGet [VarName=Direction]\nNODE n4: VariableGet [VarName=Speed]\nNODE n5: MultiplyFloat\nNODE n6: AddFloat\nNODE n7: VariableSet [VarName=Alpha]\nNODE n8: VariableGet [VarName=PointA]\nNODE n9: VariableGet [VarName=PointB]\nNODE n10: Lerp\nNODE n11: SetActorLocation\nEXEC n1.Then -> n7.Execute\nDATA n1.DeltaSeconds -> n5.A [Float]\nDATA n4.Value -> n5.B [Float]\nDATA n3.Value -> n5.B [Float]\nDATA n2.Value -> n6.A [Float]\nDATA n5.ReturnValue -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n11.Execute\nDATA n8.Value -> n10.A [Vector]\nDATA n9.Value -> n10.B [Vector]\nDATA n7.Value -> n10.Alpha [Float]\nDATA n10.ReturnValue -> n11.NewLocation [Vector]", "source": "lesson:lesson_10:L10_17", "category": "moving_platform"}
{"instruction": "bp for a platform that moves between two points. use a float variable alpha going from 0 to 1 on tick. lerp between pointa and pointb using alpha. when alpha reaches 1, reverse direction.", "output": "BLUEPRINT: BP_MovingPlatform\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nVAR Direction: Float = 1.0\nVAR Speed: Float = 0.5\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: VariableGet [VarName=Direction]\nNODE n4: VariableGet [VarName=Speed]\nNODE n5: MultiplyFloat\nNODE n6: AddFloat\nNODE n7: VariableSet [VarName=Alpha]\nNODE n8: VariableGet [VarName=PointA]\nNODE n9: VariableGet [VarName=PointB]\nNODE n10: Lerp\nNODE n11: SetActorLocation\nEXEC n1.Then -> n7.Execute\nDATA n1.DeltaSeconds -> n5.A [Float]\nDATA n4.Value -> n5.B [Float]\nDATA n3.Value -> n5.B [Float]\nDATA n2.Value -> n6.A [Float]\nDATA n5.ReturnValue -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n11.Execute\nDATA n8.Value -> n10.A [Vector]\nDATA n9.Value -> n10.B [Vector]\nDATA n7.Value -> n10.Alpha [Float]\nDATA n10.ReturnValue -> n11.NewLocation [Vector]", "source": "lesson:lesson_10:L10_17", "category": "moving_platform"}
{"instruction": "Create a Blueprint that requires 3 overlaps in sequence. Use integer StepCount starting at 0. Each overlap increments StepCount. When StepCount equals 3, print Sequence Complete and play a sound.", "output": "BLUEPRINT: BP_TriggerSequence\nPARENT: Actor\nVAR StepCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=StepCount]\nNODE n3: AddInt [B=1]\nNODE n4: VariableSet [VarName=StepCount]\nNODE n5: EqualEqual [B=3]\nNODE n6: Branch\nNODE n7: PrintString [InString=\"Sequence Complete\"]\nNODE n8: GetActorLocation\nNODE n9: PlaySoundAtLocation [Sound=CompleteSound]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n7.Execute\nEXEC n7.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Location [Vector]", "source": "lesson:lesson_10:L10_18", "category": "trigger_sequence"}
{"instruction": "make a bp that requires 3 overlaps in sequence. use integer stepcount starting at 0. each overlap increments stepcount. when stepcount equals 3, print sequence complete and play a sound.", "output": "BLUEPRINT: BP_TriggerSequence\nPARENT: Actor\nVAR StepCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=StepCount]\nNODE n3: AddInt [B=1]\nNODE n4: VariableSet [VarName=StepCount]\nNODE n5: EqualEqual [B=3]\nNODE n6: Branch\nNODE n7: PrintString [InString=\"Sequence Complete\"]\nNODE n8: GetActorLocation\nNODE n9: PlaySoundAtLocation [Sound=CompleteSound]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n7.Execute\nEXEC n7.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Location [Vector]", "source": "lesson:lesson_10:L10_18", "category": "trigger_sequence"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_Loading widget and adds to viewport. Waits 3 seconds. Removes loading widget. Creates WBP_MainMenu and adds to viewport. Prints Ready.", "output": "BLUEPRINT: BP_LoadScreen\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_Loading]\nNODE n3: AddToViewport\nNODE n4: Delay [Duration=3.0]\nNODE n5: RemoveFromParent\nNODE n6: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n7: AddToViewport\nNODE n8: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nDATA n2.ReturnValue -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Target [Widget]\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_10:L10_19", "category": "loading_screen"}
{"instruction": "make a bp that on beginplay creates wbp_loading widget and adds to viewport. waits 3 seconds. removes loading widget. creates wbp_mainmenu and adds to viewport. prints ready.", "output": "BLUEPRINT: BP_LoadScreen\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_Loading]\nNODE n3: AddToViewport\nNODE n4: Delay [Duration=3.0]\nNODE n5: RemoveFromParent\nNODE n6: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n7: AddToViewport\nNODE n8: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nDATA n2.ReturnValue -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Target [Widget]\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_10:L10_19", "category": "loading_screen"}
{"instruction": "Create a Blueprint with int Score at 0 and float Health at 100. On BeginPlay create WBP_HUD. On overlap add 10 to Score and print it. On AnyDamage subtract damage from Health. If Health below 0, remove HUD, print Game Over, destroy actor.", "output": "BLUEPRINT: BP_GameLoop\nPARENT: Actor\nVAR Score: Int = 0\nVAR Health: Float = 100.0\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_ActorBeginOverlap\nNODE n6: VariableGet [VarName=Score]\nNODE n7: AddInt [B=10]\nNODE n8: VariableSet [VarName=Score]\nNODE n9: PrintString\nNODE n10: Event_AnyDamage\nNODE n11: VariableGet [VarName=Health]\nNODE n12: SubtractFloat\nNODE n13: VariableSet [VarName=Health]\nNODE n14: LessThan [B=0.0]\nNODE n15: Branch\nNODE n16: VariableGet [VarName=HUD]\nNODE n17: RemoveFromParent\nNODE n18: PrintString [InString=\"Game Over\"]\nNODE n19: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Int]\nDATA n7.ReturnValue -> n8.Value [Int]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]\nEXEC n10.Then -> n13.Execute\nDATA n11.Value -> n12.A [Float]\nDATA n10.Damage -> n12.B [Float]\nDATA n12.ReturnValue -> n13.Value [Float]\nEXEC n13.Then -> n15.Execute\nDATA n13.Value -> n14.A [Float]\nDATA n14.ReturnValue -> n15.Condition [Bool]\nEXEC n15.True -> n17.Execute\nDATA n16.Value -> n17.Target [Widget]\nEXEC n17.Then -> n18.Execute\nEXEC n18.Then -> n19.Execute", "source": "lesson:lesson_10:L10_20", "category": "full_game_loop"}
{"instruction": "bp with int score at 0 and float health at 100. on beginplay create wbp_hud. on overlap add 10 to score and print it. on anydamage subtract damage from health. if health below 0, remove hud, print game over, destroy actor.", "output": "BLUEPRINT: BP_GameLoop\nPARENT: Actor\nVAR Score: Int = 0\nVAR Health: Float = 100.0\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_ActorBeginOverlap\nNODE n6: VariableGet [VarName=Score]\nNODE n7: AddInt [B=10]\nNODE n8: VariableSet [VarName=Score]\nNODE n9: PrintString\nNODE n10: Event_AnyDamage\nNODE n11: VariableGet [VarName=Health]\nNODE n12: SubtractFloat\nNODE n13: VariableSet [VarName=Health]\nNODE n14: LessThan [B=0.0]\nNODE n15: Branch\nNODE n16: VariableGet [VarName=HUD]\nNODE n17: RemoveFromParent\nNODE n18: PrintString [InString=\"Game Over\"]\nNODE n19: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Int]\nDATA n7.ReturnValue -> n8.Value [Int]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]\nEXEC n10.Then -> n13.Execute\nDATA n11.Value -> n12.A [Float]\nDATA n10.Damage -> n12.B [Float]\nDATA n12.ReturnValue -> n13.Value [Float]\nEXEC n13.Then -> n15.Execute\nDATA n13.Value -> n14.A [Float]\nDATA n14.ReturnValue -> n15.Condition [Bool]\nEXEC n15.True -> n17.Execute\nDATA n16.Value -> n17.Target [Widget]\nEXEC n17.Then -> n18.Execute\nEXEC n18.Then -> n19.Execute", "source": "lesson:lesson_10:L10_20", "category": "full_game_loop"}
{"instruction": "Create a Blueprint with two vector variables PointA and PointB. On Tick, lerp the actor position between them using a float Alpha that increases each frame.", "output": "BLUEPRINT: BP_SimplePatrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: AddFloat [B=0.01]\nNODE n4: VariableSet [VarName=Alpha]\nNODE n5: VariableGet [VarName=PointA]\nNODE n6: VariableGet [VarName=PointB]\nNODE n7: Lerp\nNODE n8: SetActorLocation\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.DeltaSeconds -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n8.Execute\nDATA n5.Value -> n7.A [Vector]\nDATA n6.Value -> n7.B [Vector]\nDATA n4.Value -> n7.Alpha [Float]\nDATA n7.ReturnValue -> n8.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_01", "category": "patrol_simple"}
{"instruction": "bp with two vector variables pointa and pointb. on tick, lerp the actor position between them with float alpha that increases each frame.", "output": "BLUEPRINT: BP_SimplePatrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: AddFloat [B=0.01]\nNODE n4: VariableSet [VarName=Alpha]\nNODE n5: VariableGet [VarName=PointA]\nNODE n6: VariableGet [VarName=PointB]\nNODE n7: Lerp\nNODE n8: SetActorLocation\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.DeltaSeconds -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n8.Execute\nDATA n5.Value -> n7.A [Vector]\nDATA n6.Value -> n7.B [Vector]\nDATA n4.Value -> n7.Alpha [Float]\nDATA n7.ReturnValue -> n8.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_01", "category": "patrol_simple"}
{"instruction": "Create a Blueprint with two vector variables PointA and PointB. On Tick, lerp the actor position between them using a float Alpha that increases every tick via Event Tick.", "output": "BLUEPRINT: BP_SimplePatrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: AddFloat [B=0.01]\nNODE n4: VariableSet [VarName=Alpha]\nNODE n5: VariableGet [VarName=PointA]\nNODE n6: VariableGet [VarName=PointB]\nNODE n7: Lerp\nNODE n8: SetActorLocation\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.DeltaSeconds -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n8.Execute\nDATA n5.Value -> n7.A [Vector]\nDATA n6.Value -> n7.B [Vector]\nDATA n4.Value -> n7.Alpha [Float]\nDATA n7.ReturnValue -> n8.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_01", "category": "patrol_simple"}
{"instruction": "Create a Blueprint that moves between PointA and PointB. Use Alpha going 0 to 1. When Alpha exceeds 1, set direction to -1. When below 0, set direction to 1.", "output": "BLUEPRINT: BP_PingPong\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nVAR Direction: Float = 1.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: VariableGet [VarName=Direction]\nNODE n4: MultiplyFloat\nNODE n5: AddFloat\nNODE n6: VariableSet [VarName=Alpha]\nNODE n7: GreaterThan [B=1.0]\nNODE n8: Branch\nNODE n9: VariableSet [VarName=Direction]\nNODE n10: LessThan [B=0.0]\nNODE n11: Branch\nNODE n12: VariableSet [VarName=Direction]\nNODE n13: VariableGet [VarName=PointA]\nNODE n14: VariableGet [VarName=PointB]\nNODE n15: Lerp\nNODE n16: SetActorLocation\nEXEC n1.Then -> n6.Execute\nDATA n1.DeltaSeconds -> n4.A [Float]\nDATA n3.Value -> n4.B [Float]\nDATA n2.Value -> n5.A [Float]\nDATA n4.ReturnValue -> n5.B [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA -1.0 -> n9.Value [Float]\nEXEC n8.False -> n11.Execute\nDATA n6.Value -> n10.A [Float]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute\nDATA 1.0 -> n12.Value [Float]\nEXEC n11.False -> n16.Execute\nEXEC n9.Then -> n16.Execute\nEXEC n12.Then -> n16.Execute\nDATA n13.Value -> n15.A [Vector]\nDATA n14.Value -> n15.B [Vector]\nDATA n6.Value -> n15.Alpha [Float]\nDATA n15.ReturnValue -> n16.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_02", "category": "patrol_ping_pong"}
{"instruction": "make a bp that moves between pointa and pointb. use alpha going 0 to 1. when alpha exceeds 1, set direction to -1. when below 0, set direction to 1.", "output": "BLUEPRINT: BP_PingPong\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nVAR Direction: Float = 1.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: VariableGet [VarName=Direction]\nNODE n4: MultiplyFloat\nNODE n5: AddFloat\nNODE n6: VariableSet [VarName=Alpha]\nNODE n7: GreaterThan [B=1.0]\nNODE n8: Branch\nNODE n9: VariableSet [VarName=Direction]\nNODE n10: LessThan [B=0.0]\nNODE n11: Branch\nNODE n12: VariableSet [VarName=Direction]\nNODE n13: VariableGet [VarName=PointA]\nNODE n14: VariableGet [VarName=PointB]\nNODE n15: Lerp\nNODE n16: SetActorLocation\nEXEC n1.Then -> n6.Execute\nDATA n1.DeltaSeconds -> n4.A [Float]\nDATA n3.Value -> n4.B [Float]\nDATA n2.Value -> n5.A [Float]\nDATA n4.ReturnValue -> n5.B [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA -1.0 -> n9.Value [Float]\nEXEC n8.False -> n11.Execute\nDATA n6.Value -> n10.A [Float]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute\nDATA 1.0 -> n12.Value [Float]\nEXEC n11.False -> n16.Execute\nEXEC n9.Then -> n16.Execute\nEXEC n12.Then -> n16.Execute\nDATA n13.Value -> n15.A [Vector]\nDATA n14.Value -> n15.B [Vector]\nDATA n6.Value -> n15.Alpha [Float]\nDATA n15.ReturnValue -> n16.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_02", "category": "patrol_ping_pong"}
{"instruction": "Create a Blueprint with vectors PointA and PointB and bool GoingToB. On Tick, if GoingToB lerp toward PointB. If distance to PointB less than 50 set GoingToB false. Else lerp toward PointA.", "output": "BLUEPRINT: BP_TwoPointPatrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR GoingToB: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=GoingToB]\nNODE n3: Branch\nNODE n4: GetActorLocation\nNODE n5: VariableGet [VarName=PointB]\nNODE n6: Lerp [Alpha=0.02]\nNODE n7: SetActorLocation\nNODE n8: GetActorLocation\nNODE n9: VariableGet [VarName=PointA]\nNODE n10: Lerp [Alpha=0.02]\nNODE n11: SetActorLocation\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n7.Execute\nDATA n4.ReturnValue -> n6.A [Vector]\nDATA n5.Value -> n6.B [Vector]\nDATA n6.ReturnValue -> n7.NewLocation [Vector]\nEXEC n3.False -> n11.Execute\nDATA n8.ReturnValue -> n10.A [Vector]\nDATA n9.Value -> n10.B [Vector]\nDATA n10.ReturnValue -> n11.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_03", "category": "patrol_two_point"}
{"instruction": "bp with vectors pointa and pointb and bool goingtob. on tick, if goingtob lerp toward pointb. if distance to pointb less than 50 set goingtob false. else lerp toward pointa.", "output": "BLUEPRINT: BP_TwoPointPatrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR GoingToB: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=GoingToB]\nNODE n3: Branch\nNODE n4: GetActorLocation\nNODE n5: VariableGet [VarName=PointB]\nNODE n6: Lerp [Alpha=0.02]\nNODE n7: SetActorLocation\nNODE n8: GetActorLocation\nNODE n9: VariableGet [VarName=PointA]\nNODE n10: Lerp [Alpha=0.02]\nNODE n11: SetActorLocation\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n7.Execute\nDATA n4.ReturnValue -> n6.A [Vector]\nDATA n5.Value -> n6.B [Vector]\nDATA n6.ReturnValue -> n7.NewLocation [Vector]\nEXEC n3.False -> n11.Execute\nDATA n8.ReturnValue -> n10.A [Vector]\nDATA n9.Value -> n10.B [Vector]\nDATA n10.ReturnValue -> n11.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_03", "category": "patrol_two_point"}
{"instruction": "Create a Blueprint with integer Rolls at 0. On BeginPlay use WhileLoop while Rolls less than 10. Each loop generate random int 1-6 and print it. Increment Rolls.", "output": "BLUEPRINT: BP_DiceRolls\nPARENT: Actor\nVAR Rolls: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Rolls]\nNODE n4: LessThan [B=10]\nNODE n5: RandomInteger [Min=1, Max=6]\nNODE n6: PrintString\nNODE n7: VariableGet [VarName=Rolls]\nNODE n8: AddInt [B=1]\nNODE n9: VariableSet [VarName=Rolls]\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n6.Execute\nDATA n5.ReturnValue -> n6.InString [String]\nEXEC n6.Then -> n9.Execute\nDATA n7.Value -> n8.A [Int]\nDATA n8.ReturnValue -> n9.Value [Int]", "source": "lesson:correction_v3a:C3A_04", "category": "while_random_simple"}
{"instruction": "bp with integer rolls at 0. on beginplay use whileloop while rolls less than 10. each loop generate random int 1-6 and print it. increment rolls.", "output": "BLUEPRINT: BP_DiceRolls\nPARENT: Actor\nVAR Rolls: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Rolls]\nNODE n4: LessThan [B=10]\nNODE n5: RandomInteger [Min=1, Max=6]\nNODE n6: PrintString\nNODE n7: VariableGet [VarName=Rolls]\nNODE n8: AddInt [B=1]\nNODE n9: VariableSet [VarName=Rolls]\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n6.Execute\nDATA n5.ReturnValue -> n6.InString [String]\nEXEC n6.Then -> n9.Execute\nDATA n7.Value -> n8.A [Int]\nDATA n8.ReturnValue -> n9.Value [Int]", "source": "lesson:correction_v3a:C3A_04", "category": "while_random_simple"}
{"instruction": "Create a Blueprint with float Total at 0. Use WhileLoop while Total less than 100. Each iteration add random float 1-25 to Total and print it.", "output": "BLUEPRINT: BP_Accumulator\nPARENT: Actor\nVAR Total: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Total]\nNODE n4: LessThan [B=100.0]\nNODE n5: VariableGet [VarName=Total]\nNODE n6: RandomFloat [Min=1.0, Max=25.0]\nNODE n7: AddFloat\nNODE n8: VariableSet [VarName=Total]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n8.Execute\nDATA n5.Value -> n7.A [Float]\nDATA n6.ReturnValue -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:correction_v3a:C3A_05", "category": "while_accumulate"}
{"instruction": "bp with float total at 0. use whileloop while total less than 100. each iteration add random float 1-25 to total and print it.", "output": "BLUEPRINT: BP_Accumulator\nPARENT: Actor\nVAR Total: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Total]\nNODE n4: LessThan [B=100.0]\nNODE n5: VariableGet [VarName=Total]\nNODE n6: RandomFloat [Min=1.0, Max=25.0]\nNODE n7: AddFloat\nNODE n8: VariableSet [VarName=Total]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n8.Execute\nDATA n5.Value -> n7.A [Float]\nDATA n6.ReturnValue -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:correction_v3a:C3A_05", "category": "while_accumulate"}
{"instruction": "Create a Blueprint that on overlap first casts to Character. If fails, cast to Pawn. If that also fails, print Unknown.", "output": "BLUEPRINT: BP_CastChain\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Character Found\"]\nNODE n4: CastToPawn\nNODE n5: PrintString [InString=\"Pawn Found\"]\nNODE n6: PrintString [InString=\"Unknown\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute\nDATA n1.OtherActor -> n4.Object [Actor]\nEXEC n4.CastSucceeded -> n5.Execute\nEXEC n4.CastFailed -> n6.Execute", "source": "lesson:correction_v3a:C3A_06", "category": "cast_chain"}
{"instruction": "make a bp that on overlap first casts to character. if fails, cast to pawn. if that also fails, print unknown.", "output": "BLUEPRINT: BP_CastChain\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Character Found\"]\nNODE n4: CastToPawn\nNODE n5: PrintString [InString=\"Pawn Found\"]\nNODE n6: PrintString [InString=\"Unknown\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute\nDATA n1.OtherActor -> n4.Object [Actor]\nEXEC n4.CastSucceeded -> n5.Execute\nEXEC n4.CastFailed -> n6.Execute", "source": "lesson:correction_v3a:C3A_06", "category": "cast_chain"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If success, store in variable Player and print Found Player. If fail, cast to Pawn. If that succeeds store in variable NPC.", "output": "BLUEPRINT: BP_CastAndStore\nPARENT: Actor\nVAR Player: Actor = None\nVAR NPC: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableSet [VarName=Player]\nNODE n4: PrintString [InString=\"Found Player\"]\nNODE n5: CastToPawn\nNODE n6: VariableSet [VarName=NPC]\nNODE n7: PrintString [InString=\"Found NPC\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nDATA n2.AsCharacter -> n3.Value [Actor]\nEXEC n3.Then -> n4.Execute\nEXEC n2.CastFailed -> n5.Execute\nDATA n1.OtherActor -> n5.Object [Actor]\nEXEC n5.CastSucceeded -> n6.Execute\nDATA n5.AsPawn -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute", "source": "lesson:correction_v3a:C3A_07", "category": "cast_store"}
{"instruction": "make a bp that on overlap casts to character. if success, store in variable player and print found player. if fail, cast to pawn. if that succeeds store in variable npc.", "output": "BLUEPRINT: BP_CastAndStore\nPARENT: Actor\nVAR Player: Actor = None\nVAR NPC: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableSet [VarName=Player]\nNODE n4: PrintString [InString=\"Found Player\"]\nNODE n5: CastToPawn\nNODE n6: VariableSet [VarName=NPC]\nNODE n7: PrintString [InString=\"Found NPC\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nDATA n2.AsCharacter -> n3.Value [Actor]\nEXEC n3.Then -> n4.Execute\nEXEC n2.CastFailed -> n5.Execute\nDATA n1.OtherActor -> n5.Object [Actor]\nEXEC n5.CastSucceeded -> n6.Execute\nDATA n5.AsPawn -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute", "source": "lesson:correction_v3a:C3A_07", "category": "cast_store"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If success and IsValid, get player location and print it. If cast fails print Not A Character.", "output": "BLUEPRINT: BP_SafeCastLocation\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetActorLocation\nNODE n6: PrintString\nNODE n7: PrintString [InString=\"Not A Character\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n2.AsCharacter -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n6.Execute\nDATA n2.AsCharacter -> n5.Target [Actor]\nDATA n5.ReturnValue -> n6.InString [String]\nEXEC n2.CastFailed -> n7.Execute", "source": "lesson:correction_v3a:C3A_08", "category": "cast_with_isvalid"}
{"instruction": "make a bp that on overlap casts to character. if success and isvalid, get player location and print it. if cast fails print not a character.", "output": "BLUEPRINT: BP_SafeCastLocation\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetActorLocation\nNODE n6: PrintString\nNODE n7: PrintString [InString=\"Not A Character\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n2.AsCharacter -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n6.Execute\nDATA n2.AsCharacter -> n5.Target [Actor]\nDATA n5.ReturnValue -> n6.InString [String]\nEXEC n2.CastFailed -> n7.Execute", "source": "lesson:correction_v3a:C3A_08", "category": "cast_with_isvalid"}
{"instruction": "Create a Blueprint with a Gate. Pressing Open opens the gate and creates WBP_Panel widget. Pressing Close closes the gate and removes the widget.", "output": "BLUEPRINT: BP_GateWidget\nPARENT: Actor\nVAR Panel: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Panel]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Panel]\nNODE n6: Event_InputAction [ActionName=\"Close\"]\nNODE n7: VariableGet [VarName=Panel]\nNODE n8: RemoveFromParent\nEXEC n1.Pressed -> n2.Open\nEXEC n2.Exit -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n6.Pressed -> n2.Close\nEXEC n6.Pressed -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]", "source": "lesson:correction_v3a:C3A_09", "category": "gate_widget_basic"}
{"instruction": "bp with a gate. pressing open opens the gate and creates wbp_panel widget. pressing close closes the gate and removes the widget.", "output": "BLUEPRINT: BP_GateWidget\nPARENT: Actor\nVAR Panel: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Panel]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Panel]\nNODE n6: Event_InputAction [ActionName=\"Close\"]\nNODE n7: VariableGet [VarName=Panel]\nNODE n8: RemoveFromParent\nEXEC n1.Pressed -> n2.Open\nEXEC n2.Exit -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n6.Pressed -> n2.Close\nEXEC n6.Pressed -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]", "source": "lesson:correction_v3a:C3A_09", "category": "gate_widget_basic"}
{"instruction": "Create a Blueprint that on BeginPlay opens a Gate and starts a looping timer. The timer enters the gate. The gate exit creates WBP_Notification and adds to viewport. Pressing Stop closes gate and clears timer.", "output": "BLUEPRINT: BP_GateTimerUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"Pulse\", Time=3.0, Looping=true]\nNODE n4: Event_Custom [EventName=Pulse]\nNODE n5: CreateWidget [WidgetClass=WBP_Notification]\nNODE n6: AddToViewport\nNODE n7: Event_InputAction [ActionName=\"Stop\"]\nNODE n8: ClearTimerByFunctionName [FunctionName=\"Pulse\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]\nEXEC n7.Pressed -> n2.Close\nEXEC n7.Pressed -> n8.Execute", "source": "lesson:correction_v3a:C3A_10", "category": "gate_timer_widget"}
{"instruction": "make a bp that on beginplay opens a gate and starts a looping timer. the timer enters the gate. the gate exit creates wbp_notification and adds to viewport. pressing stop closes gate and clears timer.", "output": "BLUEPRINT: BP_GateTimerUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"Pulse\", Time=3.0, Looping=true]\nNODE n4: Event_Custom [EventName=Pulse]\nNODE n5: CreateWidget [WidgetClass=WBP_Notification]\nNODE n6: AddToViewport\nNODE n7: Event_InputAction [ActionName=\"Stop\"]\nNODE n8: ClearTimerByFunctionName [FunctionName=\"Pulse\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]\nEXEC n7.Pressed -> n2.Close\nEXEC n7.Pressed -> n8.Execute", "source": "lesson:correction_v3a:C3A_10", "category": "gate_timer_widget"}
{"instruction": "Create a Blueprint that on pressing Fire spawns BP_Projectile at actor location. Gets the spawned actor's location and prints Spawned at: followed by the location.", "output": "BLUEPRINT: BP_SpawnLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: GetActorLocation\nNODE n5: Concatenate [A=\"Spawned at: \"]\nNODE n6: PrintString\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n6.Execute\nDATA n3.ReturnValue -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:correction_v3a:C3A_11", "category": "spawn_and_log"}
{"instruction": "make a bp that on pressing fire spawns bp_projectile at actor location. gets the spawned actor's location and prints spawned at: followed by the location.", "output": "BLUEPRINT: BP_SpawnLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: GetActorLocation\nNODE n5: Concatenate [A=\"Spawned at: \"]\nNODE n6: PrintString\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n6.Execute\nDATA n3.ReturnValue -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:correction_v3a:C3A_11", "category": "spawn_and_log"}
{"instruction": "Create a Blueprint that on pressing Fire spawns BP_Projectile at actor location. Gets the spawned actor's location and calls PrintString with text Spawned at: followed by the location.", "output": "BLUEPRINT: BP_SpawnLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: GetActorLocation\nNODE n5: Concatenate [A=\"Spawned at: \"]\nNODE n6: PrintString\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n6.Execute\nDATA n3.ReturnValue -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:correction_v3a:C3A_11", "category": "spawn_and_log"}
{"instruction": "Create a Blueprint with integer SpawnCount at 0. On pressing Spawn, increment SpawnCount, spawn BP_Item at actor location, print Spawned # followed by the count.", "output": "BLUEPRINT: BP_CountedSpawn\nPARENT: Actor\nVAR SpawnCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Spawn\"]\nNODE n2: VariableGet [VarName=SpawnCount]\nNODE n3: AddInt [B=1]\nNODE n4: VariableSet [VarName=SpawnCount]\nNODE n5: GetActorLocation\nNODE n6: SpawnActorFromClass [ActorClass=BP_Item]\nNODE n7: Concatenate [A=\"Spawned # \"]\nNODE n8: PrintString\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.SpawnTransform [Transform]\nEXEC n6.Then -> n8.Execute\nDATA n4.Value -> n7.B [String]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:correction_v3a:C3A_12", "category": "spawn_count_log"}
{"instruction": "bp with integer spawncount at 0. on pressing spawn, increment spawncount, spawn bp_item at actor location, print spawned # followed by the count.", "output": "BLUEPRINT: BP_CountedSpawn\nPARENT: Actor\nVAR SpawnCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Spawn\"]\nNODE n2: VariableGet [VarName=SpawnCount]\nNODE n3: AddInt [B=1]\nNODE n4: VariableSet [VarName=SpawnCount]\nNODE n5: GetActorLocation\nNODE n6: SpawnActorFromClass [ActorClass=BP_Item]\nNODE n7: Concatenate [A=\"Spawned # \"]\nNODE n8: PrintString\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.SpawnTransform [Transform]\nEXEC n6.Then -> n8.Execute\nDATA n4.Value -> n7.B [String]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:correction_v3a:C3A_12", "category": "spawn_count_log"}
{"instruction": "Create a Blueprint with float Health. On AnyDamage subtract damage from Health. If Health less than 0 set to 0. If greater than 100 set to 100. Print the clamped value.", "output": "BLUEPRINT: BP_ClampHealth\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: Clamp [Min=0.0, Max=100.0]\nNODE n5: VariableSet [VarName=Health]\nNODE n6: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n6.Execute\nDATA n5.Value -> n6.InString [String]", "source": "lesson:correction_v3a:C3A_13", "category": "clamp_health"}
{"instruction": "bp with float health. on anydamage subtract damage from health. if health less than 0 set to 0. if greater than 100 set to 100. print the clamped value.", "output": "BLUEPRINT: BP_ClampHealth\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: Clamp [Min=0.0, Max=100.0]\nNODE n5: VariableSet [VarName=Health]\nNODE n6: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n6.Execute\nDATA n5.Value -> n6.InString [String]", "source": "lesson:correction_v3a:C3A_13", "category": "clamp_health"}
{"instruction": "Create a Blueprint that on Tick gets actor location. If Z less than 0 set Z to 0. If Z greater than 500 set Z to 500. Set the clamped location.", "output": "BLUEPRINT: BP_ClampZ\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: BreakVector\nNODE n4: Clamp [Min=0.0, Max=500.0]\nNODE n5: MakeVector\nNODE n6: SetActorLocation\nEXEC n1.Then -> n6.Execute\nDATA n2.ReturnValue -> n3.Input [Vector]\nDATA n3.X -> n5.X [Float]\nDATA n3.Y -> n5.Y [Float]\nDATA n3.Z -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Z [Float]\nDATA n5.ReturnValue -> n6.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_14", "category": "clamp_position_z"}
{"instruction": "make a bp that on tick gets actor location. if z less than 0 set z to 0. if z greater than 500 set z to 500. set the clamped location.", "output": "BLUEPRINT: BP_ClampZ\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: BreakVector\nNODE n4: Clamp [Min=0.0, Max=500.0]\nNODE n5: MakeVector\nNODE n6: SetActorLocation\nEXEC n1.Then -> n6.Execute\nDATA n2.ReturnValue -> n3.Input [Vector]\nDATA n3.X -> n5.X [Float]\nDATA n3.Y -> n5.Y [Float]\nDATA n3.Z -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Z [Float]\nDATA n5.ReturnValue -> n6.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_14", "category": "clamp_position_z"}
{"instruction": "Create a Blueprint with float Speed at 50. On pressing SpeedUp add 25 to Speed. Clamp Speed between 0 and 200. Print Speed: followed by the value.", "output": "BLUEPRINT: BP_ClampSpeed\nPARENT: Actor\nVAR Speed: Float = 50.0\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"SpeedUp\"]\nNODE n2: VariableGet [VarName=Speed]\nNODE n3: AddFloat [B=25.0]\nNODE n4: Clamp [Min=0.0, Max=200.0]\nNODE n5: VariableSet [VarName=Speed]\nNODE n6: Concatenate [A=\"Speed: \"]\nNODE n7: PrintString\nEXEC n1.Pressed -> n5.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n7.Execute\nDATA n5.Value -> n6.B [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:correction_v3a:C3A_15", "category": "clamp_speed"}
{"instruction": "bp with float speed at 50. on pressing speedup add 25 to speed. clamp speed between 0 and 200. print speed: followed by the value.", "output": "BLUEPRINT: BP_ClampSpeed\nPARENT: Actor\nVAR Speed: Float = 50.0\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"SpeedUp\"]\nNODE n2: VariableGet [VarName=Speed]\nNODE n3: AddFloat [B=25.0]\nNODE n4: Clamp [Min=0.0, Max=200.0]\nNODE n5: VariableSet [VarName=Speed]\nNODE n6: Concatenate [A=\"Speed: \"]\nNODE n7: PrintString\nEXEC n1.Pressed -> n5.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n7.Execute\nDATA n5.Value -> n6.B [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:correction_v3a:C3A_15", "category": "clamp_speed"}
{"instruction": "Create a Blueprint that prints Ready on BeginPlay.", "output": "BLUEPRINT: BP_Ready\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute", "source": "lesson:correction_v3b:C3B_01", "category": "clean_simple"}
{"instruction": "make a bp that prints ready on beginplay.", "output": "BLUEPRINT: BP_Ready\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute", "source": "lesson:correction_v3b:C3B_01", "category": "clean_simple"}
{"instruction": "Create a Blueprint that calls PrintString with text Ready on BeginPlay.", "output": "BLUEPRINT: BP_Ready\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute", "source": "lesson:correction_v3b:C3B_01", "category": "clean_simple"}
{"instruction": "Create a Blueprint that destroys itself on BeginPlay.", "output": "BLUEPRINT: BP_SelfDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: DestroyActor\nEXEC n1.Then -> n2.Execute", "source": "lesson:correction_v3b:C3B_02", "category": "clean_destroy"}
{"instruction": "make a bp that destroys itself on beginplay.", "output": "BLUEPRINT: BP_SelfDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: DestroyActor\nEXEC n1.Then -> n2.Execute", "source": "lesson:correction_v3b:C3B_02", "category": "clean_destroy"}
{"instruction": "Create a Blueprint that calls DestroyActor on self on BeginPlay.", "output": "BLUEPRINT: BP_SelfDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: DestroyActor\nEXEC n1.Then -> n2.Execute", "source": "lesson:correction_v3b:C3B_02", "category": "clean_destroy"}
{"instruction": "Create a Blueprint with integer Count at 0. On BeginPlay set Count to 5 and print the value.", "output": "BLUEPRINT: BP_SetCount\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=Count]\nNODE n3: PrintString\nEXEC n1.Then -> n2.Execute\nDATA 5 -> n2.Value [Int]\nEXEC n2.Then -> n3.Execute\nDATA n2.Value -> n3.InString [String]", "source": "lesson:correction_v3b:C3B_03", "category": "clean_variable"}
{"instruction": "bp with integer count at 0. on beginplay set count to 5 and print the value.", "output": "BLUEPRINT: BP_SetCount\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=Count]\nNODE n3: PrintString\nEXEC n1.Then -> n2.Execute\nDATA 5 -> n2.Value [Int]\nEXEC n2.Then -> n3.Execute\nDATA n2.Value -> n3.InString [String]", "source": "lesson:correction_v3b:C3B_03", "category": "clean_variable"}
{"instruction": "Create a Blueprint with bool IsReady. On BeginPlay if IsReady print Go. Else print Wait.", "output": "BLUEPRINT: BP_ReadyCheck\nPARENT: Actor\nVAR IsReady: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsReady]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Go\"]\nNODE n5: PrintString [InString=\"Wait\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:correction_v3b:C3B_04", "category": "clean_branch"}
{"instruction": "bp with bool isready. on beginplay if isready print go. else print wait.", "output": "BLUEPRINT: BP_ReadyCheck\nPARENT: Actor\nVAR IsReady: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsReady]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Go\"]\nNODE n5: PrintString [InString=\"Wait\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:correction_v3b:C3B_04", "category": "clean_branch"}
{"instruction": "Create a Blueprint that on overlap prints Touched and destroys the overlapping actor.", "output": "BLUEPRINT: BP_TouchDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: PrintString [InString=\"Touched\"]\nNODE n3: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n1.OtherActor -> n3.Target [Actor]", "source": "lesson:correction_v3b:C3B_05", "category": "clean_overlap"}
{"instruction": "make a bp that on overlap prints touched and destroys the overlapping actor.", "output": "BLUEPRINT: BP_TouchDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: PrintString [InString=\"Touched\"]\nNODE n3: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n1.OtherActor -> n3.Target [Actor]", "source": "lesson:correction_v3b:C3B_05", "category": "clean_overlap"}
{"instruction": "Create a Blueprint that on overlap calls PrintString with text Touched and destroys the overlapping actor.", "output": "BLUEPRINT: BP_TouchDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: PrintString [InString=\"Touched\"]\nNODE n3: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n1.OtherActor -> n3.Target [Actor]", "source": "lesson:correction_v3b:C3B_05", "category": "clean_overlap"}
{"instruction": "Create a Blueprint that on BeginPlay waits 2 seconds then prints Done.", "output": "BLUEPRINT: BP_DelayPrint\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=2.0]\nNODE n3: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:correction_v3b:C3B_06", "category": "clean_delay"}
{"instruction": "make a bp that on beginplay waits 2 seconds then prints done.", "output": "BLUEPRINT: BP_DelayPrint\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=2.0]\nNODE n3: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:correction_v3b:C3B_06", "category": "clean_delay"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Delay node for 2 seconds then calls PrintString with text Done.", "output": "BLUEPRINT: BP_DelayPrint\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=2.0]\nNODE n3: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:correction_v3b:C3B_06", "category": "clean_delay"}
{"instruction": "Create a Blueprint that on BeginPlay starts a looping timer every 3 seconds. The timer prints Tick.", "output": "BLUEPRINT: BP_TickTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=3.0, Looping=true]\nNODE n3: Event_Custom [EventName=OnTick]\nNODE n4: PrintString [InString=\"Tick\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:correction_v3b:C3B_07", "category": "clean_timer"}
{"instruction": "make a bp that on beginplay starts a looping timer every 3 seconds. the timer prints tick.", "output": "BLUEPRINT: BP_TickTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=3.0, Looping=true]\nNODE n3: Event_Custom [EventName=OnTick]\nNODE n4: PrintString [InString=\"Tick\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:correction_v3b:C3B_07", "category": "clean_timer"}
{"instruction": "Create a Blueprint that on BeginPlay starts a looping timer every 3 seconds. The timer calls PrintString with text Tick.", "output": "BLUEPRINT: BP_TickTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=3.0, Looping=true]\nNODE n3: Event_Custom [EventName=OnTick]\nNODE n4: PrintString [InString=\"Tick\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:correction_v3b:C3B_07", "category": "clean_timer"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If success print Player. If fail print Other.", "output": "BLUEPRINT: BP_CastCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player\"]\nNODE n4: PrintString [InString=\"Other\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute", "source": "lesson:correction_v3b:C3B_08", "category": "clean_cast"}
{"instruction": "make a bp that on overlap casts to character. if success print player. if fail print other.", "output": "BLUEPRINT: BP_CastCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player\"]\nNODE n4: PrintString [InString=\"Other\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute", "source": "lesson:correction_v3b:C3B_08", "category": "clean_cast"}
{"instruction": "Create a Blueprint with vectors PointA and PointB and float Alpha. On Tick add DeltaSeconds times 0.3 to Alpha. Lerp between PointA and PointB using Alpha. Set actor location to result.", "output": "BLUEPRINT: BP_LerpPlatform\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: MultiplyFloat [B=0.3]\nNODE n4: AddFloat\nNODE n5: VariableSet [VarName=Alpha]\nNODE n6: VariableGet [VarName=PointA]\nNODE n7: VariableGet [VarName=PointB]\nNODE n8: Lerp\nNODE n9: SetActorLocation\nEXEC n1.Then -> n5.Execute\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.Value -> n4.A [Float]\nDATA n3.ReturnValue -> n4.B [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n9.Execute\nDATA n6.Value -> n8.A [Vector]\nDATA n7.Value -> n8.B [Vector]\nDATA n5.Value -> n8.Alpha [Float]\nDATA n8.ReturnValue -> n9.NewLocation [Vector]", "source": "lesson:correction_v4a:C4A_01", "category": "lerp_ab_basic"}
{"instruction": "bp with vectors pointa and pointb and float alpha. on tick add deltaseconds times 0.3 to alpha. lerp between pointa and pointb using alpha. set actor location to result.", "output": "BLUEPRINT: BP_LerpPlatform\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: MultiplyFloat [B=0.3]\nNODE n4: AddFloat\nNODE n5: VariableSet [VarName=Alpha]\nNODE n6: VariableGet [VarName=PointA]\nNODE n7: VariableGet [VarName=PointB]\nNODE n8: Lerp\nNODE n9: SetActorLocation\nEXEC n1.Then -> n5.Execute\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.Value -> n4.A [Float]\nDATA n3.ReturnValue -> n4.B [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n9.Execute\nDATA n6.Value -> n8.A [Vector]\nDATA n7.Value -> n8.B [Vector]\nDATA n5.Value -> n8.Alpha [Float]\nDATA n8.ReturnValue -> n9.NewLocation [Vector]", "source": "lesson:correction_v4a:C4A_01", "category": "lerp_ab_basic"}
{"instruction": "Create a Blueprint with vectors Start and End, float T at 0, and float Dir at 1. On Tick, add DeltaSeconds times Dir to T. If T greater than 1 set Dir to -1. If T less than 0 set Dir to 1. Lerp and set location.", "output": "BLUEPRINT: BP_ReverseLerp\nPARENT: Actor\nVAR Start: Vector\nVAR End: Vector\nVAR T: Float = 0.0\nVAR Dir: Float = 1.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=T]\nNODE n3: VariableGet [VarName=Dir]\nNODE n4: MultiplyFloat\nNODE n5: AddFloat\nNODE n6: VariableSet [VarName=T]\nNODE n7: GreaterThan [B=1.0]\nNODE n8: Branch\nNODE n9: VariableSet [VarName=Dir]\nNODE n10: LessThan [B=0.0]\nNODE n11: Branch\nNODE n12: VariableSet [VarName=Dir]\nNODE n13: VariableGet [VarName=Start]\nNODE n14: VariableGet [VarName=End]\nNODE n15: Lerp\nNODE n16: SetActorLocation\nEXEC n1.Then -> n6.Execute\nDATA n1.DeltaSeconds -> n4.A [Float]\nDATA n3.Value -> n4.B [Float]\nDATA n2.Value -> n5.A [Float]\nDATA n4.ReturnValue -> n5.B [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA -1.0 -> n9.Value [Float]\nEXEC n9.Then -> n16.Execute\nEXEC n8.False -> n11.Execute\nDATA n6.Value -> n10.A [Float]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute\nDATA 1.0 -> n12.Value [Float]\nEXEC n12.Then -> n16.Execute\nEXEC n11.False -> n16.Execute\nDATA n13.Value -> n15.A [Vector]\nDATA n14.Value -> n15.B [Vector]\nDATA n6.Value -> n15.Alpha [Float]\nDATA n15.ReturnValue -> n16.NewLocation [Vector]", "source": "lesson:correction_v4a:C4A_02", "category": "lerp_reverse"}
{"instruction": "bp with vectors start and end, float t at 0, and float dir at 1. on tick, add deltaseconds times dir to t. if t greater than 1 set dir to -1. if t less than 0 set dir to 1. lerp and set location.", "output": "BLUEPRINT: BP_ReverseLerp\nPARENT: Actor\nVAR Start: Vector\nVAR End: Vector\nVAR T: Float = 0.0\nVAR Dir: Float = 1.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=T]\nNODE n3: VariableGet [VarName=Dir]\nNODE n4: MultiplyFloat\nNODE n5: AddFloat\nNODE n6: VariableSet [VarName=T]\nNODE n7: GreaterThan [B=1.0]\nNODE n8: Branch\nNODE n9: VariableSet [VarName=Dir]\nNODE n10: LessThan [B=0.0]\nNODE n11: Branch\nNODE n12: VariableSet [VarName=Dir]\nNODE n13: VariableGet [VarName=Start]\nNODE n14: VariableGet [VarName=End]\nNODE n15: Lerp\nNODE n16: SetActorLocation\nEXEC n1.Then -> n6.Execute\nDATA n1.DeltaSeconds -> n4.A [Float]\nDATA n3.Value -> n4.B [Float]\nDATA n2.Value -> n5.A [Float]\nDATA n4.ReturnValue -> n5.B [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA -1.0 -> n9.Value [Float]\nEXEC n9.Then -> n16.Execute\nEXEC n8.False -> n11.Execute\nDATA n6.Value -> n10.A [Float]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute\nDATA 1.0 -> n12.Value [Float]\nEXEC n12.Then -> n16.Execute\nEXEC n11.False -> n16.Execute\nDATA n13.Value -> n15.A [Vector]\nDATA n14.Value -> n15.B [Vector]\nDATA n6.Value -> n15.Alpha [Float]\nDATA n15.ReturnValue -> n16.NewLocation [Vector]", "source": "lesson:correction_v4a:C4A_02", "category": "lerp_reverse"}
{"instruction": "Create a Blueprint that on Tick increases Alpha by DeltaSeconds. Clamp Alpha between 0 and 1. Lerp between PointA and PointB. Set actor location.", "output": "BLUEPRINT: BP_ClampedLerp\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: AddFloat\nNODE n4: Clamp [Min=0.0, Max=1.0]\nNODE n5: VariableSet [VarName=Alpha]\nNODE n6: VariableGet [VarName=PointA]\nNODE n7: VariableGet [VarName=PointB]\nNODE n8: Lerp\nNODE n9: SetActorLocation\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.DeltaSeconds -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n9.Execute\nDATA n6.Value -> n8.A [Vector]\nDATA n7.Value -> n8.B [Vector]\nDATA n5.Value -> n8.Alpha [Float]\nDATA n8.ReturnValue -> n9.NewLocation [Vector]", "source": "lesson:correction_v4a:C4A_03", "category": "lerp_clamp"}
{"instruction": "make a bp that on tick increases alpha by deltaseconds. clamp alpha between 0 and 1. lerp between pointa and pointb. set actor location.", "output": "BLUEPRINT: BP_ClampedLerp\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: AddFloat\nNODE n4: Clamp [Min=0.0, Max=1.0]\nNODE n5: VariableSet [VarName=Alpha]\nNODE n6: VariableGet [VarName=PointA]\nNODE n7: VariableGet [VarName=PointB]\nNODE n8: Lerp\nNODE n9: SetActorLocation\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.DeltaSeconds -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n9.Execute\nDATA n6.Value -> n8.A [Vector]\nDATA n7.Value -> n8.B [Vector]\nDATA n5.Value -> n8.Alpha [Float]\nDATA n8.ReturnValue -> n9.NewLocation [Vector]", "source": "lesson:correction_v4a:C4A_03", "category": "lerp_clamp"}
{"instruction": "Create a Blueprint. On pressing Interact get distance to player pawn. If less than 200, use FlipFlop. A path adds 90 degrees yaw rotation. B path adds -90 degrees yaw rotation.", "output": "BLUEPRINT: BP_FlipDoor\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: FlipFlop\nNODE n7: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=90,Roll=0)]\nNODE n8: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=-90,Roll=0)]\nEXEC n1.Pressed -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.A -> n7.Execute\nEXEC n6.B -> n8.Execute", "source": "lesson:correction_v4a:C4A_04", "category": "door_flipflop"}
{"instruction": "Create a Blueprint with bool IsOpen. On pressing Use, check distance to player less than 300. If close, branch on IsOpen. If closed, rotate 90 yaw, set IsOpen true, play sound. If open, rotate -90 yaw, set IsOpen false.", "output": "BLUEPRINT: BP_SoundDoor\nPARENT: Actor\nVAR IsOpen: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Use\"]\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=300.0]\nNODE n5: Branch\nNODE n6: VariableGet [VarName=IsOpen]\nNODE n7: Branch\nNODE n8: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=90,Roll=0)]\nNODE n9: VariableSet [VarName=IsOpen]\nNODE n10: PlaySoundAtLocation [Sound=DoorOpen]\nNODE n11: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=-90,Roll=0)]\nNODE n12: VariableSet [VarName=IsOpen]\nEXEC n1.Pressed -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n6.Value -> n7.Condition [Bool]\nEXEC n7.False -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA true -> n9.Value [Bool]\nEXEC n9.Then -> n10.Execute\nEXEC n7.True -> n11.Execute\nEXEC n11.Then -> n12.Execute\nDATA false -> n12.Value [Bool]", "source": "lesson:correction_v4a:C4A_05", "category": "door_with_sound"}
{"instruction": "bp with bool isopen. on pressing use, check distance to player less than 300. if close, branch on isopen. if closed, rotate 90 yaw, set isopen true, play sound. if open, rotate -90 yaw, set isopen false.", "output": "BLUEPRINT: BP_SoundDoor\nPARENT: Actor\nVAR IsOpen: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Use\"]\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=300.0]\nNODE n5: Branch\nNODE n6: VariableGet [VarName=IsOpen]\nNODE n7: Branch\nNODE n8: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=90,Roll=0)]\nNODE n9: VariableSet [VarName=IsOpen]\nNODE n10: PlaySoundAtLocation [Sound=DoorOpen]\nNODE n11: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=-90,Roll=0)]\nNODE n12: VariableSet [VarName=IsOpen]\nEXEC n1.Pressed -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n6.Value -> n7.Condition [Bool]\nEXEC n7.False -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA true -> n9.Value [Bool]\nEXEC n9.Then -> n10.Execute\nEXEC n7.True -> n11.Execute\nEXEC n11.Then -> n12.Execute\nDATA false -> n12.Value [Bool]", "source": "lesson:correction_v4a:C4A_05", "category": "door_with_sound"}
{"instruction": "Create a Blueprint with float Health at 100 and vector SpawnPoint. On BeginPlay save location to SpawnPoint. On AnyDamage subtract damage from Health. If Health less than 0, set Health to 100, teleport to SpawnPoint, print Respawned.", "output": "BLUEPRINT: BP_BasicRespawn\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR SpawnPoint: Vector\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: VariableSet [VarName=SpawnPoint]\nNODE n4: Event_AnyDamage\nNODE n5: VariableGet [VarName=Health]\nNODE n6: SubtractFloat\nNODE n7: VariableSet [VarName=Health]\nNODE n8: LessThan [B=0.0]\nNODE n9: Branch\nNODE n10: VariableSet [VarName=Health]\nNODE n11: VariableGet [VarName=SpawnPoint]\nNODE n12: SetActorLocation\nNODE n13: PrintString [InString=\"Respawned\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Vector]\nEXEC n4.Then -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n4.Damage -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute\nDATA 100.0 -> n10.Value [Float]\nEXEC n10.Then -> n12.Execute\nDATA n11.Value -> n12.NewLocation [Vector]\nEXEC n12.Then -> n13.Execute", "source": "lesson:correction_v4a:C4A_06", "category": "respawn_basic"}
{"instruction": "bp with float health at 100 and vector spawnpoint. on beginplay save location to spawnpoint. on anydamage subtract damage from health. if health less than 0, set health to 100, teleport to spawnpoint, print respawned.", "output": "BLUEPRINT: BP_BasicRespawn\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR SpawnPoint: Vector\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: VariableSet [VarName=SpawnPoint]\nNODE n4: Event_AnyDamage\nNODE n5: VariableGet [VarName=Health]\nNODE n6: SubtractFloat\nNODE n7: VariableSet [VarName=Health]\nNODE n8: LessThan [B=0.0]\nNODE n9: Branch\nNODE n10: VariableSet [VarName=Health]\nNODE n11: VariableGet [VarName=SpawnPoint]\nNODE n12: SetActorLocation\nNODE n13: PrintString [InString=\"Respawned\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Vector]\nEXEC n4.Then -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n4.Damage -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute\nDATA 100.0 -> n10.Value [Float]\nEXEC n10.Then -> n12.Execute\nDATA n11.Value -> n12.NewLocation [Vector]\nEXEC n12.Then -> n13.Execute", "source": "lesson:correction_v4a:C4A_06", "category": "respawn_basic"}
{"instruction": "Create a Blueprint with Health at 100, vector Spawn, and int Deaths at 0. On BeginPlay save location. On AnyDamage subtract. If dead, increment Deaths, reset Health, teleport, print death count.", "output": "BLUEPRINT: BP_DeathCounter\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR Spawn: Vector\nVAR Deaths: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: VariableSet [VarName=Spawn]\nNODE n4: Event_AnyDamage\nNODE n5: VariableGet [VarName=Health]\nNODE n6: SubtractFloat\nNODE n7: VariableSet [VarName=Health]\nNODE n8: LessThan [B=0.0]\nNODE n9: Branch\nNODE n10: VariableGet [VarName=Deaths]\nNODE n11: AddInt [B=1]\nNODE n12: VariableSet [VarName=Deaths]\nNODE n13: VariableSet [VarName=Health]\nNODE n14: VariableGet [VarName=Spawn]\nNODE n15: SetActorLocation\nNODE n16: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Vector]\nEXEC n4.Then -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n4.Damage -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n12.Execute\nDATA n10.Value -> n11.A [Int]\nDATA n11.ReturnValue -> n12.Value [Int]\nEXEC n12.Then -> n13.Execute\nDATA 100.0 -> n13.Value [Float]\nEXEC n13.Then -> n15.Execute\nDATA n14.Value -> n15.NewLocation [Vector]\nEXEC n15.Then -> n16.Execute\nDATA n12.Value -> n16.InString [String]", "source": "lesson:correction_v4a:C4A_07", "category": "respawn_with_counter"}
{"instruction": "bp with health at 100, vector spawn, and int deaths at 0. on beginplay save location. on anydamage subtract. if dead, increment deaths, reset health, teleport, print death count.", "output": "BLUEPRINT: BP_DeathCounter\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR Spawn: Vector\nVAR Deaths: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: VariableSet [VarName=Spawn]\nNODE n4: Event_AnyDamage\nNODE n5: VariableGet [VarName=Health]\nNODE n6: SubtractFloat\nNODE n7: VariableSet [VarName=Health]\nNODE n8: LessThan [B=0.0]\nNODE n9: Branch\nNODE n10: VariableGet [VarName=Deaths]\nNODE n11: AddInt [B=1]\nNODE n12: VariableSet [VarName=Deaths]\nNODE n13: VariableSet [VarName=Health]\nNODE n14: VariableGet [VarName=Spawn]\nNODE n15: SetActorLocation\nNODE n16: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Vector]\nEXEC n4.Then -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n4.Damage -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n12.Execute\nDATA n10.Value -> n11.A [Int]\nDATA n11.ReturnValue -> n12.Value [Int]\nEXEC n12.Then -> n13.Execute\nDATA 100.0 -> n13.Value [Float]\nEXEC n13.Then -> n15.Execute\nDATA n14.Value -> n15.NewLocation [Vector]\nEXEC n15.Then -> n16.Execute\nDATA n12.Value -> n16.InString [String]", "source": "lesson:correction_v4a:C4A_07", "category": "respawn_with_counter"}
{"instruction": "Create a Blueprint. On BeginPlay start looping timer every 2 seconds. Timer checks distance to player pawn. If less than 1000, spawn BP_Projectile at actor location and print Firing.", "output": "BLUEPRINT: BP_SimpleTurret\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Fire\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=Fire]\nNODE n4: GetPlayerPawn\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=1000.0]\nNODE n7: Branch\nNODE n8: GetActorLocation\nNODE n9: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n10: PrintString [InString=\"Firing\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n7.Execute\nDATA n4.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n9.Execute\nDATA n8.ReturnValue -> n9.SpawnTransform [Transform]\nEXEC n9.Then -> n10.Execute", "source": "lesson:correction_v4a:C4A_08", "category": "turret_simple"}
{"instruction": "Create a Blueprint with int Ammo at 10. Timer every 1.5 seconds. If distance less than 800 and Ammo greater than 0, spawn projectile, subtract 1 from Ammo, print ammo count. If Ammo is 0 clear timer.", "output": "BLUEPRINT: BP_AmmoTurret\nPARENT: Actor\nVAR Ammo: Int = 10\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Shoot\", Time=1.5, Looping=true]\nNODE n3: Event_Custom [EventName=Shoot]\nNODE n4: GetPlayerPawn\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=800.0]\nNODE n7: Branch\nNODE n8: VariableGet [VarName=Ammo]\nNODE n9: GreaterThan [B=0]\nNODE n10: Branch\nNODE n11: GetActorLocation\nNODE n12: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n13: VariableGet [VarName=Ammo]\nNODE n14: SubtractInt [B=1]\nNODE n15: VariableSet [VarName=Ammo]\nNODE n16: PrintString\nNODE n17: EqualEqual [B=0]\nNODE n18: Branch\nNODE n19: ClearTimerByFunctionName [FunctionName=\"Shoot\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n7.Execute\nDATA n4.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n10.Execute\nDATA n8.Value -> n9.A [Int]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n12.Execute\nDATA n11.ReturnValue -> n12.SpawnTransform [Transform]\nEXEC n12.Then -> n15.Execute\nDATA n13.Value -> n14.A [Int]\nDATA n14.ReturnValue -> n15.Value [Int]\nEXEC n15.Then -> n16.Execute\nDATA n15.Value -> n16.InString [String]\nEXEC n16.Then -> n18.Execute\nDATA n15.Value -> n17.A [Int]\nDATA n17.ReturnValue -> n18.Condition [Bool]\nEXEC n18.True -> n19.Execute", "source": "lesson:correction_v4a:C4A_09", "category": "turret_with_ammo"}
{"instruction": "bp with int ammo at 10. timer every 1.5 seconds. if distance less than 800 and ammo greater than 0, spawn projectile, subtract 1 from ammo, print ammo count. if ammo is 0 clear timer.", "output": "BLUEPRINT: BP_AmmoTurret\nPARENT: Actor\nVAR Ammo: Int = 10\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Shoot\", Time=1.5, Looping=true]\nNODE n3: Event_Custom [EventName=Shoot]\nNODE n4: GetPlayerPawn\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=800.0]\nNODE n7: Branch\nNODE n8: VariableGet [VarName=Ammo]\nNODE n9: GreaterThan [B=0]\nNODE n10: Branch\nNODE n11: GetActorLocation\nNODE n12: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n13: VariableGet [VarName=Ammo]\nNODE n14: SubtractInt [B=1]\nNODE n15: VariableSet [VarName=Ammo]\nNODE n16: PrintString\nNODE n17: EqualEqual [B=0]\nNODE n18: Branch\nNODE n19: ClearTimerByFunctionName [FunctionName=\"Shoot\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n7.Execute\nDATA n4.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n10.Execute\nDATA n8.Value -> n9.A [Int]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n12.Execute\nDATA n11.ReturnValue -> n12.SpawnTransform [Transform]\nEXEC n12.Then -> n15.Execute\nDATA n13.Value -> n14.A [Int]\nDATA n14.ReturnValue -> n15.Value [Int]\nEXEC n15.Then -> n16.Execute\nDATA n15.Value -> n16.InString [String]\nEXEC n16.Then -> n18.Execute\nDATA n15.Value -> n17.A [Int]\nDATA n17.ReturnValue -> n18.Condition [Bool]\nEXEC n18.True -> n19.Execute", "source": "lesson:correction_v4a:C4A_09", "category": "turret_with_ammo"}
{"instruction": "Create a Blueprint. On pressing Show, open a Gate and create WBP_Info widget, add to viewport, store in variable. On pressing Hide, close the gate and remove widget from parent.", "output": "BLUEPRINT: BP_GateShowHide\nPARENT: Actor\nVAR Info: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Show\"]\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Info]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Info]\nNODE n6: Event_InputAction [ActionName=\"Hide\"]\nNODE n7: VariableGet [VarName=Info]\nNODE n8: RemoveFromParent\nEXEC n1.Pressed -> n2.Open\nEXEC n2.Exit -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n6.Pressed -> n2.Close\nEXEC n6.Pressed -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]", "source": "lesson:correction_v4a:C4A_10", "category": "gate_create_remove"}
{"instruction": "Create a Blueprint. On overlap open Gate and create WBP_Prompt, add to viewport. On end overlap close Gate and remove widget. Gate exit prints Active.", "output": "BLUEPRINT: BP_OverlapGateUI\nPARENT: Actor\nVAR Prompt: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Prompt]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Prompt]\nNODE n6: PrintString [InString=\"Active\"]\nNODE n7: Event_ActorEndOverlap\nNODE n8: VariableGet [VarName=Prompt]\nNODE n9: RemoveFromParent\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n2.Exit -> n6.Execute\nEXEC n7.Then -> n2.Close\nEXEC n7.Then -> n9.Execute\nDATA n8.Value -> n9.Target [Widget]", "source": "lesson:correction_v4a:C4A_11", "category": "gate_overlap_widget"}
{"instruction": "Create a Blueprint. On overlap open Gate and create WBP_Prompt, add to viewport. On end overlap close Gate and remove widget. Gate exit calls PrintString with text Active.", "output": "BLUEPRINT: BP_OverlapGateUI\nPARENT: Actor\nVAR Prompt: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Prompt]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Prompt]\nNODE n6: PrintString [InString=\"Active\"]\nNODE n7: Event_ActorEndOverlap\nNODE n8: VariableGet [VarName=Prompt]\nNODE n9: RemoveFromParent\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n2.Exit -> n6.Execute\nEXEC n7.Then -> n2.Close\nEXEC n7.Then -> n9.Execute\nDATA n8.Value -> n9.Target [Widget]", "source": "lesson:correction_v4a:C4A_11", "category": "gate_overlap_widget"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_HUD and stores it. On EndPlay check if widget IsValid. If valid, remove from parent.", "output": "BLUEPRINT: BP_CleanHUD\nPARENT: Actor\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_EndPlay\nNODE n6: VariableGet [VarName=HUD]\nNODE n7: IsValid\nNODE n8: Branch\nNODE n9: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.Input [Object]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA n6.Value -> n9.Target [Widget]", "source": "lesson:correction_v4a:C4A_12", "category": "endplay_widget_cleanup"}
{"instruction": "make a bp that on beginplay creates wbp_hud and stores it. on endplay check if widget isvalid. if valid, remove from parent.", "output": "BLUEPRINT: BP_CleanHUD\nPARENT: Actor\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_EndPlay\nNODE n6: VariableGet [VarName=HUD]\nNODE n7: IsValid\nNODE n8: Branch\nNODE n9: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.Input [Object]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA n6.Value -> n9.Target [Widget]", "source": "lesson:correction_v4a:C4A_12", "category": "endplay_widget_cleanup"}
{"instruction": "Create a Blueprint with widget variables ScreenA and ScreenB. On pressing Swap use FlipFlop. A path shows ScreenA and hides ScreenB. B path shows ScreenB and hides ScreenA.", "output": "BLUEPRINT: BP_SwapUI\nPARENT: Actor\nVAR ScreenA: Widget = None\nVAR ScreenB: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Swap\"]\nNODE n2: FlipFlop\nNODE n3: VariableGet [VarName=ScreenA]\nNODE n4: AddToViewport\nNODE n5: VariableGet [VarName=ScreenB]\nNODE n6: RemoveFromParent\nNODE n7: VariableGet [VarName=ScreenB]\nNODE n8: AddToViewport\nNODE n9: VariableGet [VarName=ScreenA]\nNODE n10: RemoveFromParent\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n4.Execute\nDATA n3.Value -> n4.Target [Widget]\nEXEC n4.Then -> n6.Execute\nDATA n5.Value -> n6.Target [Widget]\nEXEC n2.B -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]\nEXEC n8.Then -> n10.Execute\nDATA n9.Value -> n10.Target [Widget]", "source": "lesson:correction_v4a:C4A_13", "category": "flipflop_widget_swap"}
{"instruction": "bp with widget variables screena and screenb. on pressing swap use flipflop. a path shows screena and hides screenb. b path shows screenb and hides screena.", "output": "BLUEPRINT: BP_SwapUI\nPARENT: Actor\nVAR ScreenA: Widget = None\nVAR ScreenB: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Swap\"]\nNODE n2: FlipFlop\nNODE n3: VariableGet [VarName=ScreenA]\nNODE n4: AddToViewport\nNODE n5: VariableGet [VarName=ScreenB]\nNODE n6: RemoveFromParent\nNODE n7: VariableGet [VarName=ScreenB]\nNODE n8: AddToViewport\nNODE n9: VariableGet [VarName=ScreenA]\nNODE n10: RemoveFromParent\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n4.Execute\nDATA n3.Value -> n4.Target [Widget]\nEXEC n4.Then -> n6.Execute\nDATA n5.Value -> n6.Target [Widget]\nEXEC n2.B -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]\nEXEC n8.Then -> n10.Execute\nDATA n9.Value -> n10.Target [Widget]", "source": "lesson:correction_v4a:C4A_13", "category": "flipflop_widget_swap"}
{"instruction": "Create a Blueprint with float Health at 100 and widget variable HUD. On BeginPlay create WBP_HUD and add to viewport. On AnyDamage subtract from Health. If Health below 0, remove HUD and destroy actor.", "output": "BLUEPRINT: BP_HUDDeath\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_AnyDamage\nNODE n6: VariableGet [VarName=Health]\nNODE n7: SubtractFloat\nNODE n8: VariableSet [VarName=Health]\nNODE n9: LessThan [B=0.0]\nNODE n10: Branch\nNODE n11: VariableGet [VarName=HUD]\nNODE n12: RemoveFromParent\nNODE n13: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n5.Damage -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n10.Execute\nDATA n8.Value -> n9.A [Float]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n12.Execute\nDATA n11.Value -> n12.Target [Widget]\nEXEC n12.Then -> n13.Execute", "source": "lesson:correction_v4a:C4A_14", "category": "hud_damage_death"}
{"instruction": "bp with float health at 100 and widget variable hud. on beginplay create wbp_hud and add to viewport. on anydamage subtract from health. if health below 0, remove hud and destroy actor.", "output": "BLUEPRINT: BP_HUDDeath\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_AnyDamage\nNODE n6: VariableGet [VarName=Health]\nNODE n7: SubtractFloat\nNODE n8: VariableSet [VarName=Health]\nNODE n9: LessThan [B=0.0]\nNODE n10: Branch\nNODE n11: VariableGet [VarName=HUD]\nNODE n12: RemoveFromParent\nNODE n13: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n5.Damage -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n10.Execute\nDATA n8.Value -> n9.A [Float]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n12.Execute\nDATA n11.Value -> n12.Target [Widget]\nEXEC n12.Then -> n13.Execute", "source": "lesson:correction_v4a:C4A_14", "category": "hud_damage_death"}
