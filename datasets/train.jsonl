{"instruction": "Create a Blueprint that reloads the weapon when the player presses the F key.", "input": "", "output": "BLUEPRINT: BP_Reload\nPARENT: Character\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Reload\"]\nNODE n2: PrintString [InString=\"Reload activated\"]\nNODE n3: CallFunction [FunctionName=\"ExecuteReload\"]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Then -> n3.Execute", "pattern": "pattern_key_press_action"}
{"instruction": "Create a Blueprint that interacts with nearby objects when the player presses the SpaceBar key.", "input": "", "output": "BLUEPRINT: BP_Interact\nPARENT: Character\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: PrintString [InString=\"Interact activated\"]\nNODE n3: CallFunction [FunctionName=\"ExecuteInteract\"]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Then -> n3.Execute", "pattern": "pattern_key_press_action"}
{"instruction": "Create a Blueprint that on begin play waits 3.0s then prints 'Step 1', waits 2.0s then prints 'Step 2', waits 0.5s then prints 'Step 3'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=0.5]\nNODE n7: PrintString [InString=\"Step 3\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint that activates a special ability when the player presses the Q key.", "input": "", "output": "BLUEPRINT: BP_UseAbility\nPARENT: Character\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"UseAbility\"]\nNODE n2: PrintString [InString=\"UseAbility activated\"]\nNODE n3: CallFunction [FunctionName=\"ExecuteUseAbility\"]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Then -> n3.Execute", "pattern": "pattern_key_press_action"}
{"instruction": "Create a Blueprint that on begin play waits 1.0s then prints 'Step 1', waits 2.0s then prints 'Step 2', waits 1.5s then prints 'Step 3', waits 2.0s then prints 'Step 4'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=1.0]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=1.5]\nNODE n7: PrintString [InString=\"Step 3\"]\nNODE n8: Delay [Duration=2.0]\nNODE n9: PrintString [InString=\"Step 4\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n8.Completed -> n9.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint with a WidgetComponent that toggles visibility when the player presses the \"Interact\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleWidget\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=WidgetComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=WidgetComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint that toggles sprinting when the player presses the Q key.", "input": "", "output": "BLUEPRINT: BP_Sprint\nPARENT: Character\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Sprint\"]\nNODE n2: PrintString [InString=\"Sprint activated\"]\nNODE n3: CallFunction [FunctionName=\"ExecuteSprint\"]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Then -> n3.Execute", "pattern": "pattern_key_press_action"}
{"instruction": "Create a Blueprint that on begin play waits 0.5s then prints 'Step 1', waits 2.0s then prints 'Step 2', waits 0.5s then prints 'Step 3', waits 0.5s then prints 'Step 4'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=0.5]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=0.5]\nNODE n7: PrintString [InString=\"Step 3\"]\nNODE n8: Delay [Duration=0.5]\nNODE n9: PrintString [InString=\"Step 4\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n8.Completed -> n9.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint that on begin play waits 2.0s then prints 'Step 1', waits 1.0s then prints 'Step 2', waits 0.5s then prints 'Step 3', waits 0.5s then prints 'Step 4'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=2.0]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=1.0]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=0.5]\nNODE n7: PrintString [InString=\"Step 3\"]\nNODE n8: Delay [Duration=0.5]\nNODE n9: PrintString [InString=\"Step 4\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n8.Completed -> n9.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint that on begin play waits 2.0s then prints 'Step 1', waits 1.5s then prints 'Step 2', waits 1.5s then prints 'Step 3'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=2.0]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=1.5]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=1.5]\nNODE n7: PrintString [InString=\"Step 3\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a health system Blueprint with 200 max health. It should take 20 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 200\nVAR MaxHealth: Float = 200\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=20]\nNODE n4: ClampFloat [Min=0.0, Max=200]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a health system Blueprint with 100 max health. It should take 15 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 100\nVAR MaxHealth: Float = 100\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=15]\nNODE n4: ClampFloat [Min=0.0, Max=100]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that prints a message when a player overlaps with it.", "input": "", "output": "BLUEPRINT: BP_OverlapTrigger\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player Entered\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]", "pattern": "pattern_overlap_trigger"}
{"instruction": "Create a health system Blueprint with 150 max health. It should take 50 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 150\nVAR MaxHealth: Float = 150\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=50]\nNODE n4: ClampFloat [Min=0.0, Max=150]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that on begin play waits 1.5s then prints 'Step 1', waits 1.0s then prints 'Step 2', waits 3.0s then prints 'Step 3', waits 0.5s then prints 'Step 4'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=1.5]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=1.0]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=3.0]\nNODE n7: PrintString [InString=\"Step 3\"]\nNODE n8: Delay [Duration=0.5]\nNODE n9: PrintString [InString=\"Step 4\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n8.Completed -> n9.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a health system Blueprint with 100 max health. It should take 10 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 100\nVAR MaxHealth: Float = 100\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=10]\nNODE n4: ClampFloat [Min=0.0, Max=100]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that makes the character jump when the player presses the LeftShift key.", "input": "", "output": "BLUEPRINT: BP_Jump\nPARENT: Character\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Jump\"]\nNODE n2: PrintString [InString=\"Jump activated\"]\nNODE n3: CallFunction [FunctionName=\"ExecuteJump\"]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Then -> n3.Execute", "pattern": "pattern_key_press_action"}
{"instruction": "Create a Blueprint that on begin play waits 0.5s then prints 'Step 1', waits 3.0s then prints 'Step 2', waits 1.0s then prints 'Step 3', waits 1.5s then prints 'Step 4'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=0.5]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=3.0]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=1.0]\nNODE n7: PrintString [InString=\"Step 3\"]\nNODE n8: Delay [Duration=1.5]\nNODE n9: PrintString [InString=\"Step 4\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n8.Completed -> n9.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint that on begin play waits 2.0s then prints 'Step 1', waits 1.5s then prints 'Step 2', waits 1.0s then prints 'Step 3'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=2.0]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=1.5]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=1.0]\nNODE n7: PrintString [InString=\"Step 3\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Z axis at a speed of 1.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingRoll\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=1.0]\nNODE n4: MakeRotator [Roll=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Roll [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint that on begin play waits 0.5s then prints 'Step 1', waits 0.5s then prints 'Step 2'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=0.5]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=0.5]\nNODE n5: PrintString [InString=\"Step 2\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint that on begin play waits 1.0s then prints 'Step 1', waits 2.0s then prints 'Step 2'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=1.0]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Step 2\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint that checks if the actor is alive. If true, it shows the actor. If false, it prints 'Condition Failed'.", "input": "", "output": "BLUEPRINT: BP_ConditionalIsAlive\nPARENT: Actor\n\nVAR IsAlive: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=IsAlive]\nNODE n3: BooleanAND [B=true]\nNODE n4: Branch\nNODE n5: SetActorHiddenInGame [bNewHidden=false]\nNODE n6: PrintString [InString=\"Condition Failed\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Bool]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint that on begin play waits 0.5s then prints 'Step 1', waits 2.0s then prints 'Step 2'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=0.5]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Step 2\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint that rotates slightly every 1.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=1.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: AddActorLocalRotation [DeltaRotation=(Yaw=5.0)]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint that on begin play waits 3.0s then prints 'Step 1', waits 1.5s then prints 'Step 2', waits 2.0s then prints 'Step 3'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=1.5]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=2.0]\nNODE n7: PrintString [InString=\"Step 3\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint with a LightComponent that toggles visibility when the player presses the \"Interact\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleLight\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=LightComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=LightComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint that on begin play waits 1.5s then prints 'Step 1', waits 2.0s then prints 'Step 2', waits 1.5s then prints 'Step 3'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=1.5]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Step 2\"]\nNODE n6: Delay [Duration=1.5]\nNODE n7: PrintString [InString=\"Step 3\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint that on begin play waits 3.0s then prints 'Step 1', waits 1.0s then prints 'Step 2'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=1.0]\nNODE n5: PrintString [InString=\"Step 2\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a Blueprint that rotates slightly every 0.5 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=0.5, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: AddActorLocalRotation [DeltaRotation=(Yaw=5.0)]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a health pack Blueprint that adds 25 to the player's CurrentHealth when overlapped, then destroys itself.", "input": "", "output": "BLUEPRINT: BP_HealthPack\nPARENT: Actor\nCATEGORY: Pickups\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetVar [Variable=CurrentHealth]\nNODE n4: AddFloat [B=25]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: PlaySound [Sound=PickupSound]\nNODE n7: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Value [Float]", "pattern": "pattern_pickup_item"}
{"instruction": "Create a Blueprint that checks if health is above 50. If true, it shows the actor. If false, it destroys the actor.", "input": "", "output": "BLUEPRINT: BP_ConditionalHealth\nPARENT: Actor\n\nVAR Health: Float = 50.0\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Health]\nNODE n3: GreaterThan [B=50.0]\nNODE n4: Branch\nNODE n5: SetActorHiddenInGame [bNewHidden=false]\nNODE n6: DestroyActor []\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a coin Blueprint that adds 1 to the player's CoinCount when overlapped, then destroys itself.", "input": "", "output": "BLUEPRINT: BP_Coin\nPARENT: Actor\nCATEGORY: Pickups\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetVar [Variable=CoinCount]\nNODE n4: AddFloat [B=1]\nNODE n5: SetVar [Variable=CoinCount]\nNODE n6: PlaySound [Sound=PickupSound]\nNODE n7: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Value [Float]", "pattern": "pattern_pickup_item"}
{"instruction": "Create a Blueprint that prints \"Ready\" when the game starts.", "input": "", "output": "BLUEPRINT: BP_PrintReady\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\n\nEXEC n1.Then -> n2.Execute", "pattern": "pattern_print_on_begin_play"}
{"instruction": "Create a Blueprint that on begin play waits 1.5s then prints 'Step 1', waits 2.0s then prints 'Step 2'.", "input": "", "output": "BLUEPRINT: BP_DelaySequence\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=1.5]\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Step 2\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "pattern": "pattern_delay_sequence"}
{"instruction": "Create a health system Blueprint with 100 max health. It should take 20 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 100\nVAR MaxHealth: Float = 100\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=20]\nNODE n4: ClampFloat [Min=0.0, Max=100]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the X axis at a speed of 2.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingPitch\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=2.0]\nNODE n4: MakeRotator [Pitch=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Pitch [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a health system Blueprint with 100 max health. It should take 50 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 100\nVAR MaxHealth: Float = 100\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=50]\nNODE n4: ClampFloat [Min=0.0, Max=100]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that prints 'Tick' every 0.5 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=0.5, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: PrintString [InString=\"Tick\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint that checks if ammo is greater than 0. If true, it prints 'Condition Met'. If false, it prints 'Condition Failed'.", "input": "", "output": "BLUEPRINT: BP_ConditionalAmmo\nPARENT: Actor\n\nVAR Ammo: Int = 0\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Ammo]\nNODE n3: GreaterThan [B=0]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Condition Met\"]\nNODE n6: PrintString [InString=\"Condition Failed\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint that checks if health is above 50. If true, it prints 'Condition Met'. If false, it prints 'Condition Failed'.", "input": "", "output": "BLUEPRINT: BP_ConditionalHealth\nPARENT: Actor\n\nVAR Health: Float = 50.0\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Health]\nNODE n3: GreaterThan [B=50.0]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Condition Met\"]\nNODE n6: PrintString [InString=\"Condition Failed\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Y axis at a speed of 10.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingYaw\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=10.0]\nNODE n4: MakeRotator [Yaw=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Yaw [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint with a LightComponent that toggles visibility when the player presses the \"Activate\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleLight\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Activate\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=LightComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=LightComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint with a ParticleComponent that toggles visibility when the player presses the \"Interact\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleParticle\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=ParticleComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=ParticleComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a health system Blueprint with 200 max health. It should take 25 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 200\nVAR MaxHealth: Float = 200\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=25]\nNODE n4: ClampFloat [Min=0.0, Max=200]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Y axis at a speed of 2.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingYaw\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=2.0]\nNODE n4: MakeRotator [Yaw=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Yaw [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint that checks if the actor is alive. If true, it prints 'Condition Met'. If false, it prints 'Condition Failed'.", "input": "", "output": "BLUEPRINT: BP_ConditionalIsAlive\nPARENT: Actor\n\nVAR IsAlive: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=IsAlive]\nNODE n3: BooleanAND [B=true]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Condition Met\"]\nNODE n6: PrintString [InString=\"Condition Failed\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Bool]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint with a WidgetComponent that toggles visibility when the player presses the \"ToggleVis\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleWidget\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"ToggleVis\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=WidgetComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=WidgetComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint with a MeshComponent that toggles visibility when the player presses the \"Activate\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleMesh\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Activate\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=MeshComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=MeshComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a health system Blueprint with 150 max health. It should take 15 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 150\nVAR MaxHealth: Float = 150\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=15]\nNODE n4: ClampFloat [Min=0.0, Max=150]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that moves upward every 1.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=1.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: AddActorLocalOffset [DeltaLocation=(Z=1.0)]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint that checks if health is above 50. If true, it shows the actor. If false, it prints 'Condition Failed'.", "input": "", "output": "BLUEPRINT: BP_ConditionalHealth\nPARENT: Actor\n\nVAR Health: Float = 50.0\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Health]\nNODE n3: GreaterThan [B=50.0]\nNODE n4: Branch\nNODE n5: SetActorHiddenInGame [bNewHidden=false]\nNODE n6: PrintString [InString=\"Condition Failed\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the X axis at a speed of 1.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingPitch\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=1.0]\nNODE n4: MakeRotator [Pitch=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Pitch [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint that rotates slightly every 2.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=2.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: AddActorLocalRotation [DeltaRotation=(Yaw=5.0)]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a health system Blueprint with 150 max health. It should take 25 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 150\nVAR MaxHealth: Float = 150\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=25]\nNODE n4: ClampFloat [Min=0.0, Max=150]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that checks if ammo is greater than 0. If true, it prints 'Condition Met'. If false, it destroys the actor.", "input": "", "output": "BLUEPRINT: BP_ConditionalAmmo\nPARENT: Actor\n\nVAR Ammo: Int = 0\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Ammo]\nNODE n3: GreaterThan [B=0]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Condition Met\"]\nNODE n6: DestroyActor []\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the X axis at a speed of 5.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingPitch\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=5.0]\nNODE n4: MakeRotator [Pitch=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Pitch [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Z axis at a speed of 5.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingRoll\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=5.0]\nNODE n4: MakeRotator [Roll=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Roll [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint that hides itself when a player overlaps with it.", "input": "", "output": "BLUEPRINT: BP_OverlapTrigger\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: SetActorHiddenInGame [bNewHidden=true]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]", "pattern": "pattern_overlap_trigger"}
{"instruction": "Create a Blueprint with a MeshComponent that toggles visibility when the player presses the \"Switch\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleMesh\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Switch\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=MeshComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=MeshComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint with a WidgetComponent that toggles visibility when the player presses the \"Activate\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleWidget\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Activate\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=WidgetComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=WidgetComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint that checks if ammo is greater than 0. If true, it shows the actor. If false, it destroys the actor.", "input": "", "output": "BLUEPRINT: BP_ConditionalAmmo\nPARENT: Actor\n\nVAR Ammo: Int = 0\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Ammo]\nNODE n3: GreaterThan [B=0]\nNODE n4: Branch\nNODE n5: SetActorHiddenInGame [bNewHidden=false]\nNODE n6: DestroyActor []\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a health system Blueprint with 200 max health. It should take 10 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 200\nVAR MaxHealth: Float = 200\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=10]\nNODE n4: ClampFloat [Min=0.0, Max=200]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that prints 'Tick' every 1.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=1.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: PrintString [InString=\"Tick\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint with a ParticleComponent that toggles visibility when the player presses the \"ToggleVis\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleParticle\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"ToggleVis\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=ParticleComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=ParticleComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a speed boost Blueprint that adds 200 to the player's MoveSpeed when overlapped, then destroys itself.", "input": "", "output": "BLUEPRINT: BP_SpeedBoost\nPARENT: Actor\nCATEGORY: Pickups\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetVar [Variable=MoveSpeed]\nNODE n4: AddFloat [B=200]\nNODE n5: SetVar [Variable=MoveSpeed]\nNODE n6: PlaySound [Sound=PickupSound]\nNODE n7: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Value [Float]", "pattern": "pattern_pickup_item"}
{"instruction": "Create a Blueprint that prints \"Hello World\" when the game starts.", "input": "", "output": "BLUEPRINT: BP_PrintHelloWorld\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Hello World\"]\n\nEXEC n1.Then -> n2.Execute", "pattern": "pattern_print_on_begin_play"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Y axis at a speed of 1.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingYaw\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=1.0]\nNODE n4: MakeRotator [Yaw=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Yaw [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Z axis at a speed of 10.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingRoll\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=10.0]\nNODE n4: MakeRotator [Roll=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Roll [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint that checks if ammo is greater than 0. If true, it shows the actor. If false, it prints 'Condition Failed'.", "input": "", "output": "BLUEPRINT: BP_ConditionalAmmo\nPARENT: Actor\n\nVAR Ammo: Int = 0\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Ammo]\nNODE n3: GreaterThan [B=0]\nNODE n4: Branch\nNODE n5: SetActorHiddenInGame [bNewHidden=false]\nNODE n6: PrintString [InString=\"Condition Failed\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint with a WidgetComponent that toggles visibility when the player presses the \"Switch\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleWidget\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Switch\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=WidgetComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=WidgetComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the X axis at a speed of 0.5 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingPitch\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=0.5]\nNODE n4: MakeRotator [Pitch=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Pitch [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint that prints 'Tick' every 3.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=3.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: PrintString [InString=\"Tick\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Y axis at a speed of 0.5 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingYaw\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=0.5]\nNODE n4: MakeRotator [Yaw=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Yaw [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Z axis at a speed of 0.5 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingRoll\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=0.5]\nNODE n4: MakeRotator [Roll=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Roll [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint that checks if the actor is alive. If true, it prints 'Condition Met'. If false, it destroys the actor.", "input": "", "output": "BLUEPRINT: BP_ConditionalIsAlive\nPARENT: Actor\n\nVAR IsAlive: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=IsAlive]\nNODE n3: BooleanAND [B=true]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Condition Met\"]\nNODE n6: DestroyActor []\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Bool]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint that prints \"Blueprint Active\" when the game starts.", "input": "", "output": "BLUEPRINT: BP_PrintBlueprintActive\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Blueprint Active\"]\n\nEXEC n1.Then -> n2.Execute", "pattern": "pattern_print_on_begin_play"}
{"instruction": "Create a health system Blueprint with 250 max health. It should take 20 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 250\nVAR MaxHealth: Float = 250\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=20]\nNODE n4: ClampFloat [Min=0.0, Max=250]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a ammo crate Blueprint that adds 30 to the player's AmmoCount when overlapped, then destroys itself.", "input": "", "output": "BLUEPRINT: BP_AmmoCrate\nPARENT: Actor\nCATEGORY: Pickups\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetVar [Variable=AmmoCount]\nNODE n4: AddFloat [B=30]\nNODE n5: SetVar [Variable=AmmoCount]\nNODE n6: PlaySound [Sound=PickupSound]\nNODE n7: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Value [Float]", "pattern": "pattern_pickup_item"}
{"instruction": "Create a Blueprint that plays a sound when a player overlaps with it.", "input": "", "output": "BLUEPRINT: BP_OverlapTrigger\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PlaySound [Sound=OverlapSound]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]", "pattern": "pattern_overlap_trigger"}
{"instruction": "Create a health system Blueprint with 250 max health. It should take 50 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 250\nVAR MaxHealth: Float = 250\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=50]\nNODE n4: ClampFloat [Min=0.0, Max=250]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a health system Blueprint with 150 max health. It should take 20 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 150\nVAR MaxHealth: Float = 150\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=20]\nNODE n4: ClampFloat [Min=0.0, Max=150]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a health system Blueprint with 200 max health. It should take 50 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 200\nVAR MaxHealth: Float = 200\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=50]\nNODE n4: ClampFloat [Min=0.0, Max=200]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that destroys itself when a player overlaps with it.", "input": "", "output": "BLUEPRINT: BP_OverlapTrigger\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]", "pattern": "pattern_overlap_trigger"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Z axis at a speed of 2.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingRoll\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=2.0]\nNODE n4: MakeRotator [Roll=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Roll [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint that moves upward every 0.5 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=0.5, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: AddActorLocalOffset [DeltaLocation=(Z=1.0)]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a health system Blueprint with 250 max health. It should take 10 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 250\nVAR MaxHealth: Float = 250\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=10]\nNODE n4: ClampFloat [Min=0.0, Max=250]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that rotates slightly every 5.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=5.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: AddActorLocalRotation [DeltaRotation=(Yaw=5.0)]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint that prints \"Actor Initialized\" when the game starts.", "input": "", "output": "BLUEPRINT: BP_PrintActorInitialized\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Actor Initialized\"]\n\nEXEC n1.Then -> n2.Execute", "pattern": "pattern_print_on_begin_play"}
{"instruction": "Create a Blueprint that prints \"System Online\" when the game starts.", "input": "", "output": "BLUEPRINT: BP_PrintSystemOnline\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"System Online\"]\n\nEXEC n1.Then -> n2.Execute", "pattern": "pattern_print_on_begin_play"}
{"instruction": "Create a Blueprint that checks if score exceeds 100. If true, it prints 'Condition Met'. If false, it destroys the actor.", "input": "", "output": "BLUEPRINT: BP_ConditionalScore\nPARENT: Actor\n\nVAR Score: Int = 100\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Score]\nNODE n3: GreaterThan [B=100]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Condition Met\"]\nNODE n6: DestroyActor []\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint with a MeshComponent that toggles visibility when the player presses the \"ToggleVis\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleMesh\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"ToggleVis\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=MeshComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=MeshComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint that prints 'Tick' every 5.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=5.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: PrintString [InString=\"Tick\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the X axis at a speed of 10.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingPitch\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=10.0]\nNODE n4: MakeRotator [Pitch=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Pitch [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a health system Blueprint with 200 max health. It should take 15 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 200\nVAR MaxHealth: Float = 200\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=15]\nNODE n4: ClampFloat [Min=0.0, Max=200]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint with a ParticleComponent that toggles visibility when the player presses the \"Activate\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleParticle\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Activate\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=ParticleComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=ParticleComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint that checks if score exceeds 100. If true, it shows the actor. If false, it destroys the actor.", "input": "", "output": "BLUEPRINT: BP_ConditionalScore\nPARENT: Actor\n\nVAR Score: Int = 100\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Score]\nNODE n3: GreaterThan [B=100]\nNODE n4: Branch\nNODE n5: SetActorHiddenInGame [bNewHidden=false]\nNODE n6: DestroyActor []\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint with a LightComponent that toggles visibility when the player presses the \"ToggleVis\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleLight\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"ToggleVis\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=LightComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=LightComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a health system Blueprint with 250 max health. It should take 25 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 250\nVAR MaxHealth: Float = 250\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=25]\nNODE n4: ClampFloat [Min=0.0, Max=250]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint with a LightComponent that toggles visibility when the player presses the \"Switch\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleLight\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Switch\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=LightComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=LightComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint that prints 'Tick' every 2.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=2.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: PrintString [InString=\"Tick\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint with a MeshComponent that toggles visibility when the player presses the \"Interact\" input action.", "input": "", "output": "BLUEPRINT: BP_ToggleMesh\nPARENT: Actor\n\nVAR bIsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [Target=MeshComponent, NewVisibility=true]\nNODE n4: SetVisibility [Target=MeshComponent, NewVisibility=false]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "pattern": "pattern_toggle_visibility"}
{"instruction": "Create a Blueprint for an actor that continuously rotates on the Y axis at a speed of 5.0 degrees per tick.", "input": "", "output": "BLUEPRINT: BP_RotatingYaw\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetWorldDeltaSeconds\nNODE n3: MultiplyFloat [B=5.0]\nNODE n4: MakeRotator [Yaw=1.0]\nNODE n5: AddActorLocalRotation\n\nEXEC n1.Then -> n5.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Yaw [Float]\nDATA n4.ReturnValue -> n5.DeltaRotation [Rotator]", "pattern": "pattern_rotating_actor"}
{"instruction": "Create a Blueprint that checks if the actor is alive. If true, it shows the actor. If false, it destroys the actor.", "input": "", "output": "BLUEPRINT: BP_ConditionalIsAlive\nPARENT: Actor\n\nVAR IsAlive: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=IsAlive]\nNODE n3: BooleanAND [B=true]\nNODE n4: Branch\nNODE n5: SetActorHiddenInGame [bNewHidden=false]\nNODE n6: DestroyActor []\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Bool]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint that prints \"Game Started\" when the game starts.", "input": "", "output": "BLUEPRINT: BP_PrintGameStarted\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Game Started\"]\n\nEXEC n1.Then -> n2.Execute", "pattern": "pattern_print_on_begin_play"}
{"instruction": "Create a shield pickup Blueprint that adds 50 to the player's ShieldAmount when overlapped, then destroys itself.", "input": "", "output": "BLUEPRINT: BP_Shield\nPARENT: Actor\nCATEGORY: Pickups\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetVar [Variable=ShieldAmount]\nNODE n4: AddFloat [B=50]\nNODE n5: SetVar [Variable=ShieldAmount]\nNODE n6: PlaySound [Sound=PickupSound]\nNODE n7: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Value [Float]", "pattern": "pattern_pickup_item"}
{"instruction": "Create a health system Blueprint with 250 max health. It should take 15 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 250\nVAR MaxHealth: Float = 250\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=15]\nNODE n4: ClampFloat [Min=0.0, Max=250]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that moves upward every 5.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=5.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: AddActorLocalOffset [DeltaLocation=(Z=1.0)]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint that checks if score exceeds 100. If true, it shows the actor. If false, it prints 'Condition Failed'.", "input": "", "output": "BLUEPRINT: BP_ConditionalScore\nPARENT: Actor\n\nVAR Score: Int = 100\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Score]\nNODE n3: GreaterThan [B=100]\nNODE n4: Branch\nNODE n5: SetActorHiddenInGame [bNewHidden=false]\nNODE n6: PrintString [InString=\"Condition Failed\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a health system Blueprint with 100 max health. It should take 25 damage when hit and destroy the actor when health reaches zero.", "input": "", "output": "BLUEPRINT: BP_HealthSystem\nPARENT: Actor\nCATEGORY: Gameplay\n\nVAR CurrentHealth: Float = 100\nVAR MaxHealth: Float = 100\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent [EventName=\"TakeDamage\"]\nNODE n2: GetVar [Variable=CurrentHealth]\nNODE n3: SubtractFloat [B=25]\nNODE n4: ClampFloat [Min=0.0, Max=100]\nNODE n5: SetVar [Variable=CurrentHealth]\nNODE n6: LessEqualFloat [B=0.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Damage Taken\"]\n\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n5.Execute\nEXEC n5.Then -> n7.Execute\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\n\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]", "pattern": "pattern_health_system"}
{"instruction": "Create a Blueprint that checks if score exceeds 100. If true, it prints 'Condition Met'. If false, it prints 'Condition Failed'.", "input": "", "output": "BLUEPRINT: BP_ConditionalScore\nPARENT: Actor\n\nVAR Score: Int = 100\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: GetVar [Variable=Score]\nNODE n3: GreaterThan [B=100]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Condition Met\"]\nNODE n6: PrintString [InString=\"Condition Failed\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "pattern": "pattern_branch_condition"}
{"instruction": "Create a Blueprint that moves upward every 2.0 seconds using a timer.", "input": "", "output": "BLUEPRINT: BP_TimerLoop\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=2.0, bLooping=true]\nNODE n3: Event_CustomEvent [EventName=\"OnTimer\"]\nNODE n4: AddActorLocalOffset [DeltaLocation=(Z=1.0)]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "pattern": "pattern_timer_loop"}
{"instruction": "Create a Blueprint called BP_Demo111 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo111\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: GetVar\nNODE n3: Do AI Combo Attack\nNODE n4: Event_CustomEvent\nNODE n5: FinishTask\nNODE n6: Event_Unknown\nNODE n7: GetVar\nNODE n8: Branch\nNODE n9: Branch"}
{"instruction": "Create a Blueprint called BP_Demo112 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo112\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: GetVar\nNODE n2: Event_Unknown\nNODE n3: K2_SetFocus\nNODE n4: GetVar\nNODE n5: Event_Unknown\nNODE n6: GetVar\nNODE n7: Branch\nNODE n8: Branch\nNODE n9: K2_ClearFocus"}
{"instruction": "Create a Blueprint called BP_Demo113 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo113\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: GetVar\nNODE n2: Event_Unknown\nNODE n3: Event_Unknown\nNODE n4: GetVar\nNODE n5: Branch\nNODE n6: Branch\nNODE n7: K2_SetFocalPoint\nNODE n8: GetVar\nNODE n9: K2_ClearFocus"}
{"instruction": "Create a Blueprint called BP_Demo114 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo114\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: GetPlayerPawn\nNODE n2: SetVar\nNODE n3: Event_Unknown\nNODE n4: GetVar\nNODE n5: _MACRO_\nNODE n6: GetActorLocation\nNODE n7: SetVar\nNODE n8: GetVar\nNODE n9: GetActorLocation\nNODE n10: UnknownMath\nNODE n11: VSize\nNODE n12: SetVar"}
{"instruction": "Create a Blueprint called BP_Demo115 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo115\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: Branch\nNODE n3: GetVar\nNODE n4: GetVar\nNODE n5: SetVar\nNODE n6: GetVar"}
{"instruction": "Create a Blueprint called BP_Demo116 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo116\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: GetVar\nNODE n3: FinishTask\nNODE n4: Event_Unknown\nNODE n5: GetVar\nNODE n6: Branch\nNODE n7: Branch\nNODE n8: Event_CustomEvent"}
{"instruction": "Create a Blueprint called BP_Demo117 that performs an action when the game starts.", "input": "", "output": "BLUEPRINT: BP_Demo117\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Event_CustomEvent\nNODE n3: GetVar\nNODE n4: K2_GetComponentToWorld\nNODE n5: Event_CustomEvent\nNODE n6: RetriggerableDelay\nNODE n7: GetVar\nNODE n8: GetVar\nNODE n9: _MACRO_\nNODE n10: Branch\nNODE n11: Spawn Enemy\nNODE n12: Delay\nNODE n13: GetVar\nNODE n14: GetVar\nNODE n15: Spawn Enemy\nNODE n16: Event_Unknown\nNODE n17: Branch\nNODE n18: GetVar\nNODE n19: GetVar\nNODE n20: Branch\nNODE n21: _MACRO_\nNODE n22: Spawn Enemy\nNODE n23: GetVar\nNODE n24: _MACRO_\nNODE n25: GetVar\nNODE n26: Delay\nNODE n27: UnknownMath"}
{"instruction": "Create a Blueprint called BP_Demo118 that destroys itself when the game starts.", "input": "", "output": "BLUEPRINT: BP_Demo118\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Event_Unknown\nNODE n3: SetVar\nNODE n4: GetVar\nNODE n5: UnknownMath\nNODE n6: UnknownMath\nNODE n7: Branch\nNODE n8: ApplyDamage\nNODE n9: Event_AnyDamage\nNODE n10: Delay\nNODE n11: DestroyActor\nNODE n12: GetVar\nNODE n13: GetUserWidgetObject\nNODE n14: CastToObject\nNODE n15: SetVar\nNODE n16: GetVar\nNODE n17: Set Life Percentage\nNODE n18: GetVar\nNODE n19: UnknownMath\nNODE n20: GetVar\nNODE n21: GetVar\nNODE n22: SetHiddenInGame\nNODE n23: Event_CustomEvent\nNODE n24: GetVar\nNODE n25: GetVar\nNODE n26: SetSimulatePhysics\nNODE n27: GetVar\nNODE n28: DisableMovement\nNODE n29: GetVar\nNODE n30: SetCollisionEnabled\nNODE n31: SpawnSystemAtLocation\nNODE n32: Conv_VectorToRotator\nNODE n33: GetVar\nNODE n34: AddImpulse\nNODE n35: GetMass\nNODE n36: UnknownMath\nNODE n37: IsSimulatingPhysics\nNODE n38: Branch\nNODE n39: Event_Unknown\nNODE n40: GetActorForwardVector\nNODE n41: UnknownMath\nNODE n42: GetVar\nNODE n43: UnknownMath\nNODE n44: SphereTraceMultiForObjects\nNODE n45: GetVar\nNODE n46: Branch\nNODE n47: _MACRO_\nNODE n48: BreakHitResult\nNODE n49: GetVar\nNODE n50: UnknownMath\nNODE n51: GetVar\nNODE n52: UnknownMath\nNODE n53: GetVar\nNODE n54: Vector_Up\nNODE n55: UnknownMath\nNODE n56: UnknownMath\nNODE n57: ActorHasTag\nNODE n58: Branch\nNODE n59: GetVar\nNODE n60: GetAnimInstance\nNODE n61: Montage_Stop\nNODE n62: Event_Unknown\nNODE n63: GetVar\nNODE n64: GetSocketLocation\nNODE n65: SetPhysicsBlendWeight\nNODE n66: GetVar\nNODE n67: Event_Unknown\nNODE n68: SetPhysicsBlendWeight\nNODE n69: GetVar\nNODE n70: GetVar\nNODE n71: UnknownMath\nNODE n72: Branch\nNODE n73: SetBodySimulatePhysics\nNODE n74: GetVar\nNODE n75: SetVar\nNODE n76: SetVar\nNODE n77: Event_Unknown\nNODE n78: GetVar\nNODE n79: Branch\nNODE n80: GetVar\nNODE n81: _MACRO_\nNODE n82: GetVar\nNODE n83: GetAnimInstance\nNODE n84: GetVar\nNODE n85: Montage_JumpToSection\nNODE n86: GetVar\nNODE n87: GetVar\nNODE n88: GetVar\nNODE n89: RandomInteger\nNODE n90: GetVar\nNODE n91: Handle Death\nNODE n92: UnknownMath\nNODE n93: GetVar\nNODE n94: AddImpulse\nNODE n95: GetVar\nNODE n96: Sequence\nNODE n97: Branch\nNODE n98: GetVar\nNODE n99: UnknownMath\nNODE n100: Event_CustomEvent\nNODE n101: Branch\nNODE n102: GetVar\nNODE n103: SetVar\nNODE n104: SetVar\nNODE n105: GetVar\nNODE n106: Branch\nNODE n107: GetVar\nNODE n108: SetVar\nNODE n109: SetVar\nNODE n110: SetVar\nNODE n111: SetVar\nNODE n112: RandomInteger\nNODE n113: GetVar\nNODE n114: GetVar\nNODE n115: Event_Unknown\nNODE n116: GetVar\nNODE n117: _MACRO_\nNODE n118: UnknownMath\nNODE n119: GetVar\nNODE n120: GetVar\nNODE n121: GetAnimInstance\nNODE n122: SelectName\nNODE n123: GetVar\nNODE n124: GetVar\nNODE n125: Montage_JumpToSection\nNODE n126: GetVar\nNODE n127: GetVar\nNODE n128: GetVar\nNODE n129: GetVar\nNODE n130: Montage_Stop\nNODE n131: GetVar"}
{"instruction": "Create a Blueprint called BP_Demo119 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo119\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Branch\nNODE n2: UnknownMath\nNODE n3: GetPlayerPawn\nNODE n4: Branch\nNODE n5: GetVar\nNODE n6: _MACRO_\nNODE n7: GetVar\nNODE n8: _MACRO_\nNODE n9: UnknownMath\nNODE n10: GetPlayerPawn"}
{"instruction": "Create a Blueprint called BP_Demo120 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo120\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Branch\nNODE n2: UnknownMath\nNODE n3: GetPlayerPawn\nNODE n4: Branch\nNODE n5: GetVar\nNODE n6: _MACRO_\nNODE n7: GetVar\nNODE n8: _MACRO_\nNODE n9: UnknownMath\nNODE n10: GetPlayerPawn\nNODE n11: CastToCharacter\nNODE n12: _MACRO_\nNODE n13: GetController\nNODE n14: CastToPlayerController\nNODE n15: Set Respawn Transform\nNODE n16: GetTransform"}
{"instruction": "Create a Blueprint called BP_Demo121 that destroys itself an event.", "input": "", "output": "BLUEPRINT: BP_Demo121\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: Sequence\nNODE n3: Event_CustomEvent\nNODE n4: _MACRO_\nNODE n5: Delay\nNODE n6: DestroyActor\nNODE n7: UnknownMath\nNODE n8: SetCollisionObjectType\nNODE n9: SpawnSystemAtLocation\nNODE n10: Conv_VectorToRotator\nNODE n11: GetVar\nNODE n12: GetVar\nNODE n13: GetMass\nNODE n14: UnknownMath\nNODE n15: AddImpulse\nNODE n16: GetVar\nNODE n17: UnknownMath\nNODE n18: SetVar\nNODE n19: Branch\nNODE n20: Destroy Box\nNODE n21: GetVar\nNODE n22: SetMaterial\nNODE n23: Sequence\nNODE n24: Branch\nNODE n25: GetVar\nNODE n26: UnknownMath\nNODE n27: SetActorScale3D\nNODE n28: Conv_DoubleToVector\nNODE n29: GetVar\nNODE n30: SetSimulatePhysics"}
{"instruction": "Create a Blueprint called BP_Demo122 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo122\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: GetVar\nNODE n2: SetConstrainedComponents\nNODE n3: GetVar\nNODE n4: GetVar"}
{"instruction": "Create a Blueprint called BP_Demo123 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo123\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: GetVar\nNODE n2: GetActorLocation"}
{"instruction": "Create a Blueprint called BP_Demo124 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo124\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent\nNODE n2: SetPercent\nNODE n3: Event_CustomEvent\nNODE n4: SetFillColorAndOpacity\nNODE n5: GetVar\nNODE n6: GetVar"}
{"instruction": "Create a Blueprint called BP_Demo125 that performs an action when the game starts.", "input": "", "output": "BLUEPRINT: BP_Demo125\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: GetVar\nNODE n2: Branch\nNODE n3: Event_Unknown\nNODE n4: Event_CustomEvent\nNODE n5: Jump\nNODE n6: StopJumping\nNODE n7: Try Multi Jump\nNODE n8: GetVar\nNODE n9: GetVar\nNODE n10: Activate\nNODE n11: GetVar\nNODE n12: Deactivate\nNODE n13: GetVar\nNODE n14: GetVar\nNODE n15: GetActorLocation\nNODE n16: GetActorForwardVector\nNODE n17: UnknownMath\nNODE n18: GetVar\nNODE n19: UnknownMath\nNODE n20: SphereTraceSingle\nNODE n21: GetVar\nNODE n22: BreakHitResult\nNODE n23: UnknownMath\nNODE n24: GetVar\nNODE n25: UnknownMath\nNODE n26: Vector_Up\nNODE n27: UnknownMath\nNODE n28: GetVar\nNODE n29: Branch\nNODE n30: LaunchCharacter\nNODE n31: IsFalling\nNODE n32: Branch\nNODE n33: GetVar\nNODE n34: SetVar\nNODE n35: SetVar\nNODE n36: Conv_VectorToRotator\nNODE n37: SetActorRotation\nNODE n38: SetVar\nNODE n39: SetVar\nNODE n40: Branch\nNODE n41: GetVar\nNODE n42: RetriggerableDelay\nNODE n43: GetVar\nNODE n44: GetVar\nNODE n45: SetVar\nNODE n46: GetVar\nNODE n47: SetVar\nNODE n48: SetVar\nNODE n49: GetVar\nNODE n50: GetVar\nNODE n51: Activate\nNODE n52: Sequence\nNODE n53: Activate\nNODE n54: GetVar\nNODE n55: GetVar\nNODE n56: Activate\nNODE n57: GetVar\nNODE n58: GetVar\nNODE n59: GetVar\nNODE n60: Branch\nNODE n61: GetVar\nNODE n62: Event_BeginPlay\nNODE n63: GetVar\nNODE n64: GetVar\nNODE n65: SetColorParameter\nNODE n66: GetVar\nNODE n67: GetVar\nNODE n68: IsMovingOnGround\nNODE n69: Branch\nNODE n70: GetVar\nNODE n71: Deactivate\nNODE n72: GetVar\nNODE n73: Branch\nNODE n74: GetVar\nNODE n75: SetVar\nNODE n76: SetVar\nNODE n77: SetVar\nNODE n78: Branch\nNODE n79: GetVar\nNODE n80: SetVar\nNODE n81: SetVar\nNODE n82: Event_CustomEvent\nNODE n83: Jump\nNODE n84: Aim\nNODE n85: Event_Unknown\nNODE n86: Aim\nNODE n87: Move\nNODE n88: Event_Unknown\nNODE n89: Move\nNODE n90: Event_Unknown\nNODE n91: Event_Unknown\nNODE n92: Event_Unknown\nNODE n93: Aim\nNODE n94: Event_CustomEvent\nNODE n95: GetVar\nNODE n96: GetVar\nNODE n97: Branch\nNODE n98: GetTimeSeconds\nNODE n99: SetVar\nNODE n100: GetTimeSeconds\nNODE n101: GetVar\nNODE n102: UnknownMath\nNODE n103: UnknownMath\nNODE n104: GetVar\nNODE n105: Branch\nNODE n106: Activate\nNODE n107: GetVar\nNODE n108: GetVar\nNODE n109: Jump"}
{"instruction": "Create a Blueprint called BP_Demo126 that performs an action when the game starts.", "input": "", "output": "BLUEPRINT: BP_Demo126\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: Event_CustomEvent\nNODE n3: GetAllActorsOfClass\nNODE n4: Branch\nNODE n5: GetTransform\nNODE n6: Possess\nNODE n7: Event_BeginPlay\nNODE n8: AddMappingContext\nNODE n9: Sequence\nNODE n10: IsLocalPlayerController\nNODE n11: Branch\nNODE n12: AddToPlayerScreen\nNODE n13: AddMappingContext\nNODE n14: GetVar\nNODE n15: GetPlatformName"}
{"instruction": "Create a Blueprint called BP_Demo127 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo127\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: GetVar\nNODE n3: SetVar"}
{"instruction": "Create a Blueprint called BP_Demo128 that destroys itself and toggles visibility when the game starts.", "input": "", "output": "BLUEPRINT: BP_Demo128\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Event_ActorBeginOverlap\nNODE n3: Event_Tick\nNODE n4: Event_Unknown\nNODE n5: DestroyActor\nNODE n6: Event_Unknown\nNODE n7: GetVar\nNODE n8: SetVisibility"}
{"instruction": "Create a Blueprint called BP_Demo129 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo129\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: GetVar\nNODE n2: SetIntensity\nNODE n3: GetVar\nNODE n4: SetIntensity\nNODE n5: GetVar\nNODE n6: Event_Unknown\nNODE n7: Branch\nNODE n8: SetHiddenInGame\nNODE n9: SetHiddenInGame"}
{"instruction": "Create a Blueprint called BP_Demo130 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo130\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: Branch\nNODE n3: GetVar\nNODE n4: K2_AttachToComponent\nNODE n5: SetVar\nNODE n6: GetVar\nNODE n7: K2_DestroyComponent\nNODE n8: SetWorldScale3D"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncharacter that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncharacter\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: StopJumping\nNODE n2: Jump\nNODE n3: Event_Unknown\nNODE n4: Event_Unknown\nNODE n5: Event_Unknown\nNODE n6: Event_Unknown\nNODE n7: Move\nNODE n8: Move\nNODE n9: Aim\nNODE n10: Aim\nNODE n11: Aim"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncontroller that performs an action when the game starts.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncontroller\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: AddMappingContext\nNODE n3: Sequence\nNODE n4: IsLocalPlayerController\nNODE n5: Branch\nNODE n6: AddToPlayerScreen\nNODE n7: AddMappingContext\nNODE n8: GetVar\nNODE n9: GetPlatformName"}
{"instruction": "Create a Blueprint called BP_Demoenvquerycontext_Player that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demoenvquerycontext_Player\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: GetPlayerPawn"}
{"instruction": "Create a Blueprint called BP_Demofirstpersoncharacter that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofirstpersoncharacter\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Jump\nNODE n2: StopJumping\nNODE n3: Move\nNODE n4: Move\nNODE n5: Aim\nNODE n6: Aim\nNODE n7: Aim\nNODE n8: Event_Unknown\nNODE n9: Event_Unknown\nNODE n10: Event_Unknown\nNODE n11: Event_Unknown"}
{"instruction": "Create a Blueprint called BP_Demofpsbp_Doorframe that performs an action when the game starts.", "input": "", "output": "BLUEPRINT: BP_Demofpsbp_Doorframe\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Event_ActorBeginOverlap\nNODE n3: GetVar\nNODE n4: SetRelativeLocation\nNODE n5: GetVar\nNODE n6: GetVar\nNODE n7: SetVar\nNODE n8: GetVar\nNODE n9: Lerp\nNODE n10: GetVar\nNODE n11: UnknownMath\nNODE n12: Event_ActorEndOverlap\nNODE n13: UnknownMath\nNODE n14: Branch\nNODE n15: GetVar\nNODE n16: GetVar\nNODE n17: SetRelativeLocation\nNODE n18: SelectFloat\nNODE n19: Lerp\nNODE n20: SelectFloat\nNODE n21: UnknownMath\nNODE n22: GetVar\nNODE n23: Lerp\nNODE n24: UnknownMath\nNODE n25: SetVar\nNODE n26: GetVar\nNODE n27: GetVar\nNODE n28: GetVar\nNODE n29: UnknownMath\nNODE n30: UnknownMath\nNODE n31: GetVar\nNODE n32: GetOverlappingActors"}
{"instruction": "Create a Blueprint called BP_Demofpscontroller that performs an action when the game starts.", "input": "", "output": "BLUEPRINT: BP_Demofpscontroller\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: AddMappingContext\nNODE n3: Sequence\nNODE n4: IsLocalPlayerController\nNODE n5: Branch\nNODE n6: AddToPlayerScreen\nNODE n7: AddMappingContext\nNODE n8: GetVar\nNODE n9: GetPlatformName"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Body that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Body\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Footik that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Footik\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Procedural that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Procedural\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsuithumbstick that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuithumbstick\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: Event_Unknown\nNODE n3: Branch\nNODE n4: GetVar\nNODE n5: GetInputTouchState\nNODE n6: GetPlayerController\nNODE n7: GetVar\nNODE n8: UnknownMath\nNODE n9: UnknownMath\nNODE n10: SetRenderTranslation\nNODE n11: SetVar\nNODE n12: UnknownMath\nNODE n13: UnknownMath\nNODE n14: ClampFloat\nNODE n15: ClampFloat\nNODE n16: GetVar\nNODE n17: UnknownMath\nNODE n18: UnknownMath\nNODE n19: UnknownMath\nNODE n20: UnknownMath\nNODE n21: UnknownMath\nNODE n22: SetRenderTranslation\nNODE n23: GetVar\nNODE n24: GetVar\nNODE n25: SelectFloat\nNODE n26: UnknownMath\nNODE n27: GetVar\nNODE n28: SelectFloat\nNODE n29: GetVar\nNODE n30: UnknownMath\nNODE n31: UnknownMath\nNODE n32: SelectFloat\nNODE n33: SelectFloat\nNODE n34: GetVar\nNODE n35: SetHeightOverride\nNODE n36: SetWidthOverride\nNODE n37: Touch Input Check\nNODE n38: Touch Input Check\nNODE n39: GetVar\nNODE n40: Branch\nNODE n41: GetVar\nNODE n42: GetVar\nNODE n43: GetVar\nNODE n44: LocalToViewport\nNODE n45: GetVar\nNODE n46: SetVar\nNODE n47: UnknownMath\nNODE n48: GetViewportScale\nNODE n49: UnknownMath\nNODE n50: GetVar"}
{"instruction": "Create a Blueprint called BP_Demofpsuitouchsimple that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuitouchsimple\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: GetOwningPlayer\nNODE n3: SetVar\nNODE n4: SetInputMode_GameAndUIEx\nNODE n5: GetOwningPlayer\nNODE n6: K2_GetPawn\nNODE n7: GetOwningPlayer\nNODE n8: K2_GetPawn"}
{"instruction": "Create a Blueprint called BP_Demostatetreecondition_Ischaractergrounded that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreecondition_Ischaractergrounded\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: GetVar\nNODE n2: GetMovementComponent\nNODE n3: IsMovingOnGround\nNODE n4: GetVar\nNODE n5: BooleanNOT"}
{"instruction": "Create a Blueprint called BP_Demostatetreetask_Chargedattack that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreetask_Chargedattack\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: GetVar\nNODE n3: Event_CustomEvent\nNODE n4: FinishTask\nNODE n5: Event_Unknown\nNODE n6: GetVar\nNODE n7: Branch\nNODE n8: Branch\nNODE n9: Do AI Charged Attack"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr101 that performs an action when the game starts.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr101\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: AddControllerPitchInput\nNODE n2: AddControllerYawInput\nNODE n3: AddMovementInput\nNODE n4: AddMovementInput\nNODE n5: GetControlRotation\nNODE n6: StopJumping\nNODE n7: GetForwardVector\nNODE n8: GetRightVector\nNODE n9: GetControlRotation\nNODE n10: CastToPlayerController\nNODE n11: AddMappingContext\nNODE n12: Event_BeginPlay\nNODE n13: GetController\nNODE n14: _MACRO_\nNODE n15: Event_CustomEvent\nNODE n16: SetVar\nNODE n17: Crouch\nNODE n18: Event_CustomEvent\nNODE n19: SetVar\nNODE n20: UnCrouch\nNODE n21: _MACRO_\nNODE n22: Event_CustomEvent\nNODE n23: SetVar\nNODE n24: GetVar\nNODE n25: SetVar\nNODE n26: Event_CustomEvent\nNODE n27: SetVar\nNODE n28: GetVar\nNODE n29: SetVar\nNODE n30: GetVar\nNODE n31: SetVar\nNODE n32: Lerp\nNODE n33: Jump\nNODE n34: GetActorLocation\nNODE n35: GetActorRotation\nNODE n36: GetUpVector\nNODE n37: UnknownMath\nNODE n38: UnknownMath\nNODE n39: BooleanNOT\nNODE n40: Branch\nNODE n41: SphereTraceSingle\nNODE n42: Sequence\nNODE n43: Start_Crouch\nNODE n44: Stop_Crouch\nNODE n45: Start_Sprint\nNODE n46: Stop_Sprint\nNODE n47: GetVar\nNODE n48: IsFalling\nNODE n49: Branch\nNODE n50: BooleanNOT\nNODE n51: SetVar\nNODE n52: ClampFloat\nNODE n53: Branch\nNODE n54: GetVar\nNODE n55: IsCrouching\nNODE n56: BooleanNOT\nNODE n57: GetVar\nNODE n58: BeginSettings\nNODE n59: GetVar\nNODE n60: GetVar\nNODE n61: Character_Interact\nNODE n62: Open Loadout Menu\nNODE n63: GetVar\nNODE n64: GetController\nNODE n65: CastToPlayerController\nNODE n66: GetVar\nNODE n67: EventToggleAttachment\nNODE n68: GetVar\nNODE n69: FireWeapon"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr102 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr102\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: SetVar\nNODE n3: GetVar\nNODE n4: SetWorldRotation\nNODE n5: RLerp\nNODE n6: GetVar\nNODE n7: GetActorRotation\nNODE n8: DegSin\nNODE n9: UnknownMath\nNODE n10: UnknownMath\nNODE n11: DegCos\nNODE n12: GetActorRotation\nNODE n13: GetActorRotation\nNODE n14: Event_CustomEvent\nNODE n15: SetVar\nNODE n16: Multicast Hit Effect\nNODE n17: MakeRotFromX\nNODE n18: NormalizedDeltaRotator\nNODE n19: SetVar\nNODE n20: SetVar\nNODE n21: Branch\nNODE n22: GetVar"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr103 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr103\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: CreateSaveGameObject\nNODE n2: DoesSaveGameExist\nNODE n3: Branch\nNODE n4: SetVar\nNODE n5: Event_Unknown\nNODE n6: LoadGameFromSlot\nNODE n7: SetVar\nNODE n8: CastToObject\nNODE n9: CreateSaveWeapon\nNODE n10: SaveGameToSlot\nNODE n11: GetVar\nNODE n12: GetVar\nNODE n13: GetVar\nNODE n14: GetVar\nNODE n15: Event_CustomEvent\nNODE n16: GetVar\nNODE n17: Save Weapon Slots"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr104 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr104\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: K2_AttachToComponent\nNODE n2: GetVar\nNODE n3: GetVar\nNODE n4: GetVar\nNODE n5: RemoveAttachment\nNODE n6: GetVar\nNODE n7: GetSocketTransform"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr105 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr105\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: GetVar\nNODE n3: GetVar\nNODE n4: SetColorAndOpacity\nNODE n5: GetVar\nNODE n6: SetText\nNODE n7: Conv_StringToText"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr106 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr106\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: SetText\nNODE n2: GetVar\nNODE n3: Conv_StringToText\nNODE n4: SetColorAndOpacity\nNODE n5: GetVar\nNODE n6: UnknownMath\nNODE n7: UnknownMath\nNODE n8: GetVar\nNODE n9: Conv_IntToString\nNODE n10: Conv_TextToString\nNODE n11: Conv_StringToInt\nNODE n12: GetVar\nNODE n13: AddInt\nNODE n14: GetVar\nNODE n15: Conv_IntToString\nNODE n16: SubtractInt\nNODE n17: Conv_IntToString"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr107 that prints 'a message' an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr107\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Sequence\nNODE n2: GetViewportSize\nNODE n3: BreakVector\nNODE n4: UnknownMath\nNODE n5: UnknownMath\nNODE n6: SetVar\nNODE n7: SetVar\nNODE n8: _MACRO_\nNODE n9: GetVar\nNODE n10: GetVar\nNODE n11: AddInt\nNODE n12: UnknownMath\nNODE n13: GetVar\nNODE n14: UnknownMath\nNODE n15: SetVar\nNODE n16: GetVar\nNODE n17: AddChildToCanvas\nNODE n18: SetPosition\nNODE n19: Conv_IntToDouble\nNODE n20: GetVar\nNODE n21: DegCos\nNODE n22: GetVar\nNODE n23: UnknownMath\nNODE n24: GetVar\nNODE n25: UnknownMath\nNODE n26: MakeVector\nNODE n27: GetVar\nNODE n28: DegSin\nNODE n29: GetVar\nNODE n30: UnknownMath\nNODE n31: GetVar\nNODE n32: UnknownMath\nNODE n33: GetVar\nNODE n34: GetAllChildren\nNODE n35: _MACRO_\nNODE n36: SetVar\nNODE n37: UnknownMath\nNODE n38: UnknownMath\nNODE n39: SlotAsCanvasSlot\nNODE n40: SetPosition\nNODE n41: GetVar\nNODE n42: RotateAngleAxis\nNODE n43: UnknownMath\nNODE n44: BreakVector\nNODE n45: MakeVector\nNODE n46: GetVar\nNODE n47: Branch\nNODE n48: MakeRotFromX\nNODE n49: BreakRotator\nNODE n50: SetRenderTransformAngle\nNODE n51: Conv_IntToDouble\nNODE n52: SetAnchors\nNODE n53: GetVar\nNODE n54: RotateAngleAxis\nNODE n55: SetRenderTransformAngle\nNODE n56: SetVar\nNODE n57: GetVar\nNODE n58: GetVar\nNODE n59: SetAlignment\nNODE n60: GetVar\nNODE n61: UnknownMath\nNODE n62: GetVar\nNODE n63: Event_Unknown\nNODE n64: GetSocketTransform\nNODE n65: Event_Unknown\nNODE n66: GetPlayerController\nNODE n67: ProjectWorldToScreen\nNODE n68: GetVar\nNODE n69: ScreenToViewport\nNODE n70: SetVar\nNODE n71: SetVar\nNODE n72: GetSocketTransform\nNODE n73: GetPlayerController\nNODE n74: ProjectWorldToScreen\nNODE n75: ScreenToViewport\nNODE n76: SetPosition\nNODE n77: GetVar\nNODE n78: SlotAsCanvasSlot\nNODE n79: ScreenToWidgetLocal\nNODE n80: GetVar\nNODE n81: GetCachedGeometry\nNODE n82: GetVar\nNODE n83: ClampFloat\nNODE n84: ClampFloat\nNODE n85: SetPosition\nNODE n86: GetVar\nNODE n87: SlotAsCanvasSlot\nNODE n88: ScreenToWidgetLocal\nNODE n89: GetVar\nNODE n90: GetCachedGeometry\nNODE n91: GetVar\nNODE n92: ClampFloat\nNODE n93: ClampFloat\nNODE n94: GetSize\nNODE n95: SlotAsCanvasSlot\nNODE n96: GetSize\nNODE n97: SlotAsCanvasSlot\nNODE n98: SetVar\nNODE n99: GetSocketTransform\nNODE n100: GetPlayerController\nNODE n101: ProjectWorldToScreen\nNODE n102: ScreenToViewport\nNODE n103: GetVar\nNODE n104: SlotAsCanvasSlot\nNODE n105: SetPosition\nNODE n106: GetVar\nNODE n107: SetAnchors\nNODE n108: SetAnchors\nNODE n109: SetAnchors\nNODE n110: ScreenToWidgetLocal\nNODE n111: GetCachedGeometry\nNODE n112: GetVar\nNODE n113: ClampFloat\nNODE n114: ClampFloat\nNODE n115: GetSize\nNODE n116: SlotAsCanvasSlot\nNODE n117: ScreenToViewport\nNODE n118: Abs\nNODE n119: PrintString\nNODE n120: LocalToViewport\nNODE n121: UnknownMath\nNODE n122: Event_Unknown\nNODE n123: SetVar\nNODE n124: GetActorOfClass\nNODE n125: GetVar\nNODE n126: Delay\nNODE n127: SetVar\nNODE n128: GetVar\nNODE n129: GetVar\nNODE n130: _MACRO_\nNODE n131: GetSocketTransform\nNODE n132: GetPlayerController\nNODE n133: ProjectWorldToScreen\nNODE n134: ScreenToViewport\nNODE n135: GetVar\nNODE n136: Branch\nNODE n137: GetVar\nNODE n138: Delay\nNODE n139: GetCachedGeometry\nNODE n140: GetVar\nNODE n141: ScreenToWidgetLocal\nNODE n142: GetVar\nNODE n143: AddChildToCanvas\nNODE n144: SetPosition\nNODE n145: GetVar\nNODE n146: _MACRO_\nNODE n147: GetVar\nNODE n148: GetChildAt\nNODE n149: SlotAsCanvasSlot\nNODE n150: SetAutoSize\nNODE n151: SetPosition\nNODE n152: ProjectWorldLocationToScreen\nNODE n153: ProjectWorldLocationToWidgetPosition\nNODE n154: UnknownMath\nNODE n155: GetViewportScale\nNODE n156: MultiplyFloat\nNODE n157: GetSocketLocation"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr108 that toggles visibility and destroys itself and toggles visibility and toggles visibility an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr108\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: AddToViewport\nNODE n3: GetVar\nNODE n4: GetOwningPlayer\nNODE n5: GetVar\nNODE n6: SetVisibility\nNODE n7: Event_Unknown\nNODE n8: GetVar\nNODE n9: DestroyActor\nNODE n10: Event_CustomEvent\nNODE n11: SetVisibility\nNODE n12: GetVar\nNODE n13: ActiveCameraCharacter\nNODE n14: GetVar\nNODE n15: Remove Main Loadout\nNODE n16: RemoveFromParent\nNODE n17: AddToViewport\nNODE n18: GetVar\nNODE n19: GetOwningPlayer\nNODE n20: GetVar\nNODE n21: SetVisibility\nNODE n22: GetVar\nNODE n23: GetVar\nNODE n24: GetVar\nNODE n25: GetVar\nNODE n26: SetText\nNODE n27: Conv_NameToText\nNODE n28: GetVar\nNODE n29: SetText\nNODE n30: Conv_NameToText\nNODE n31: GetVar\nNODE n32: SetBrushFromTexture\nNODE n33: SetBrushFromTexture\nNODE n34: GetVar\nNODE n35: GetVar\nNODE n36: SetBrushColor\nNODE n37: SetBrushColor\nNODE n38: GetVar\nNODE n39: SetBrushColor\nNODE n40: SetBrushColor\nNODE n41: GetVar\nNODE n42: GetVar\nNODE n43: GetVar\nNODE n44: GetVar\nNODE n45: GetVar\nNODE n46: ActiveCameraCharacter"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr109 that toggles visibility and toggles visibility and toggles visibility an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr109\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: GetDataTableRowNames\nNODE n3: _MACRO_\nNODE n4: GetOwningPlayer\nNODE n5: GetVar\nNODE n6: AddChild\nNODE n7: GetVar\nNODE n8: ClearChildren\nNODE n9: GetVar\nNODE n10: GetVar\nNODE n11: GetVar\nNODE n12: GetVar\nNODE n13: _MACRO_\nNODE n14: GetTypeWeaponList\nNODE n15: SetButtonSelect\nNODE n16: Sequence\nNODE n17: Event_CustomEvent\nNODE n18: GetTypeWeaponList\nNODE n19: SetButtonSelect\nNODE n20: Event_CustomEvent\nNODE n21: SetVar\nNODE n22: GetVar\nNODE n23: GetVar\nNODE n24: Equip Weapon\nNODE n25: GetVar\nNODE n26: UnknownMath\nNODE n27: Branch\nNODE n28: GetVar\nNODE n29: UnknownMath\nNODE n30: Branch\nNODE n31: GetVar\nNODE n32: SetVar\nNODE n33: BeginModifyWeapon\nNODE n34: GetVar\nNODE n35: SetVisibility\nNODE n36: GetVar\nNODE n37: SelectWeapon\nNODE n38: GetVar\nNODE n39: UnknownMath\nNODE n40: Branch\nNODE n41: SetVar\nNODE n42: GetVar\nNODE n43: GetVar\nNODE n44: Get Weapon Save\nNODE n45: GetVar\nNODE n46: UpdateStatusWeapon\nNODE n47: SetVisibility\nNODE n48: GetVar\nNODE n49: RemoveFromParent\nNODE n50: Event_CustomEvent\nNODE n51: SetVisibility\nNODE n52: GetVar\nNODE n53: SelectWeapon\nNODE n54: GetVar\nNODE n55: ReturnMainLoadout\nNODE n56: GetVar\nNODE n57: GetVar\nNODE n58: GetVar\nNODE n59: GetVar\nNODE n60: Branch\nNODE n61: BooleanOR\nNODE n62: GetVar\nNODE n63: ReturnMainLoadout\nNODE n64: RemoveFromParent\nNODE n65: GetVar\nNODE n66: GetVar\nNODE n67: Get Weapon Save\nNODE n68: GetVar\nNODE n69: SetVar\nNODE n70: GetVar\nNODE n71: SelectWeapon\nNODE n72: GetVar\nNODE n73: GetVar\nNODE n74: GetVar\nNODE n75: Get Weapon Save\nNODE n76: GetVar\nNODE n77: SetVar"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr110 that toggles visibility and toggles visibility an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr110\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: Event_Unknown\nNODE n3: Event_Unknown\nNODE n4: Event_CustomEvent\nNODE n5: Branch\nNODE n6: GetVar\nNODE n7: SetBrushColor\nNODE n8: GetVar\nNODE n9: SetBrushColor\nNODE n10: GetVar\nNODE n11: SetBrushColor\nNODE n12: GetVar\nNODE n13: SetBrushColor\nNODE n14: MouseEnter?\nNODE n15: MouseEnter?\nNODE n16: MouseEnter?\nNODE n17: GetVar\nNODE n18: GetVar\nNODE n19: GetVar\nNODE n20: GetVar\nNODE n21: UnknownMath\nNODE n22: Branch\nNODE n23: GetVar\nNODE n24: SetVisibility\nNODE n25: SetVisibility\nNODE n26: GetVar\nNODE n27: GetVar\nNODE n28: GetVar\nNODE n29: GetVar\nNODE n30: SelectWeapon_Event"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr111 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr111\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_CustomEvent\nNODE n2: GetVar\nNODE n3: SetText\nNODE n4: Conv_NameToText\nNODE n5: GetVar\nNODE n6: SetText\nNODE n7: Conv_IntToText\nNODE n8: GetVar\nNODE n9: SetText\nNODE n10: Conv_StringToText\nNODE n11: Conv_IntToString\nNODE n12: UnknownMath\nNODE n13: UpdateProgressBar\nNODE n14: GetVar\nNODE n15: UpdateProgressBar\nNODE n16: GetVar\nNODE n17: SetText\nNODE n18: UpdateProgressBar\nNODE n19: GetVar\nNODE n20: GetVar\nNODE n21: Conv_IntToText\nNODE n22: SetText\nNODE n23: UpdateProgressBar\nNODE n24: GetVar\nNODE n25: GetVar\nNODE n26: Conv_IntToText\nNODE n27: SetText\nNODE n28: UpdateProgressBar\nNODE n29: GetVar\nNODE n30: GetVar\nNODE n31: Conv_IntToText\nNODE n32: GetVar\nNODE n33: SetText\nNODE n34: UpdateProgressBar\nNODE n35: GetVar\nNODE n36: Conv_IntToText\nNODE n37: SetText\nNODE n38: GetVar\nNODE n39: Conv_DoubleToText\nNODE n40: SetText\nNODE n41: GetVar\nNODE n42: Conv_IntToText\nNODE n43: GetModeWeapon\nNODE n44: GetVar\nNODE n45: SetText\nNODE n46: Conv_DoubleToText\nNODE n47: SetText\nNODE n48: GetVar\nNODE n49: Conv_StringToText\nNODE n50: Conv_StringToText\nNODE n51: UnknownMath\nNODE n52: Conv_TextToString"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr112 that toggles visibility and toggles visibility an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr112\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Unknown\nNODE n2: GetVar\nNODE n3: Conv_StringToText\nNODE n4: GetVar\nNODE n5: SetText\nNODE n6: Event_CustomEvent\nNODE n7: GetVar\nNODE n8: Branch\nNODE n9: GetVar\nNODE n10: SetVisibility\nNODE n11: SetVisibility\nNODE n12: GetVar\nNODE n13: SetBrushColor\nNODE n14: SetBrushColor\nNODE n15: GetVar\nNODE n16: GetVar\nNODE n17: GetVar\nNODE n18: GetVar\nNODE n19: GetVar"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr113 that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr113\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: UnknownMath\nNODE n2: LineTraceSingle\nNODE n3: UnknownMath\nNODE n4: BreakHitResult\nNODE n5: GetVar\nNODE n6: K2_GetComponentLocation\nNODE n7: K2_GetComponentRotation\nNODE n8: GetForwardVector\nNODE n9: Event_CustomEvent\nNODE n10: SetVar\nNODE n11: Event_CustomEvent\nNODE n12: SetVar\nNODE n13: SetViewTargetWithBlend\nNODE n14: AddToViewport\nNODE n15: Event_CustomEvent\nNODE n16: GetVar\nNODE n17: SetVar\nNODE n18: GetVar\nNODE n19: GetVar\nNODE n20: Load Weapon Save\nNODE n21: Event_CustomEvent\nNODE n22: GetVar\nNODE n23: GetVar\nNODE n24: _MACRO_\nNODE n25: GetVar\nNODE n26: Branch\nNODE n27: SetVar\nNODE n28: SetVar\nNODE n29: GetVar\nNODE n30: Event_CustomEvent\nNODE n31: GetVar\nNODE n32: LineTraceSingle\nNODE n33: GetVar\nNODE n34: K2_GetComponentLocation\nNODE n35: GetForwardVector\nNODE n36: UnknownMath\nNODE n37: UnknownMath\nNODE n38: BreakHitResult\nNODE n39: Branch\nNODE n40: ApplyPointDamage\nNODE n41: SetVar\nNODE n42: AddToViewport\nNODE n43: SetVar\nNODE n44: GetVar\nNODE n45: Branch\nNODE n46: GetVar\nNODE n47: RemoveFromParent"}
{"instruction": "Create a Blueprint called BP_Hello_World that prints 'a message' every frame.", "input": "", "output": "BLUEPRINT: BP_Hello_World\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: PrintString"}
{"instruction": "Create a Blueprint called BP_Demo111.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo111.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo112.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo112.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo113.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo113.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo114.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo114.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo115.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo115.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo116.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo116.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo117.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo117.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo118.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo118.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo119.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo119.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo120.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo120.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo121.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo121.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo122.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo122.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo123.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo123.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo124.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo124.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo125.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo125.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo126.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo126.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo127.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo127.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo128.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo128.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo129.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo129.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo130.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo130.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncharacter.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncharacter.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncontroller.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncontroller.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demoenvquerycontext_Player.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demoenvquerycontext_Player.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofirstpersoncharacter.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofirstpersoncharacter.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsbp_Doorframe.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsbp_Doorframe.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscontroller.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscontroller.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Body.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Body.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Footik.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Footik.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Procedural.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Procedural.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsuithumbstick.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuithumbstick.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsuitouchsimple.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuitouchsimple.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demostatetreecondition_Ischaractergrounded.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreecondition_Ischaractergrounded.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demostatetreetask_Chargedattack.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreetask_Chargedattack.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr101.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr101.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr102.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr102.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr103.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr103.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr104.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr104.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr105.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr105.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr106.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr106.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr107.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr107.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr108.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr108.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr109.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr109.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr110.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr110.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr111.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr111.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr112.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr112.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr113.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr113.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Hello_World.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Hello_World.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo111.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo111.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo112.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo112.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo113.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo113.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo114.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo114.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo115.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo115.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo116.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo116.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo117.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo117.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo118.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo118.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo119.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo119.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo120.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo120.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo121.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo121.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo122.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo122.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo123.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo123.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo124.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo124.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo125.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo125.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo126.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo126.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo127.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo127.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo128.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo128.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo129.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo129.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo130.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo130.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncharacter.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncharacter.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncontroller.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncontroller.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demoenvquerycontext_Player.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demoenvquerycontext_Player.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofirstpersoncharacter.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofirstpersoncharacter.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsbp_Doorframe.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsbp_Doorframe.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscontroller.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscontroller.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Body.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Body.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Footik.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Footik.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Procedural.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Procedural.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsuithumbstick.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuithumbstick.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsuitouchsimple.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuitouchsimple.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demostatetreecondition_Ischaractergrounded.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreecondition_Ischaractergrounded.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demostatetreetask_Chargedattack.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreetask_Chargedattack.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr101.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr101.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr102.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr102.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr103.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr103.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr104.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr104.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr105.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr105.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr106.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr106.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr107.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr107.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr108.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr108.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr109.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr109.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr110.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr110.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr111.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr111.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr112.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr112.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr113.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr113.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Hello_World.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Hello_World.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo111.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo111.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo112.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo112.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo113.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo113.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo114.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo114.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo115.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo115.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo116.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo116.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo117.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo117.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo118.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo118.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo119.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo119.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo120.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo120.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo121.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo121.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo122.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo122.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo123.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo123.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo124.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo124.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo125.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo125.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo126.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo126.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo127.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo127.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo128.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo128.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo129.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo129.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo130.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo130.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncharacter.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncharacter.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncontroller.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncontroller.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demoenvquerycontext_Player.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demoenvquerycontext_Player.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofirstpersoncharacter.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofirstpersoncharacter.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsbp_Doorframe.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsbp_Doorframe.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscontroller.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscontroller.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Body.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Body.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Footik.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Footik.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Procedural.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Procedural.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsuithumbstick.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuithumbstick.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsuitouchsimple.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuitouchsimple.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demostatetreecondition_Ischaractergrounded.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreecondition_Ischaractergrounded.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demostatetreetask_Chargedattack.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreetask_Chargedattack.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr101.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr101.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr102.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr102.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr103.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr103.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr104.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr104.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr105.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr105.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr106.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr106.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr107.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr107.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr108.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr108.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr109.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr109.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr110.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr110.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr111.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr111.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr112.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr112.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr113.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr113.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Hello_World.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Hello_World.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo111.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo111.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo112.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo112.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo113.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo113.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo114.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo114.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo115.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo115.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo116.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo116.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo117.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo117.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo118.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo118.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo119.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo119.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo120.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo120.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo121.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo121.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo122.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo122.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo123.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo123.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo124.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo124.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo125.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo125.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo126.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo126.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo127.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo127.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo128.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo128.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo129.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo129.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demo130.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demo130.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncharacter.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncharacter.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demobp_Thirdpersoncontroller.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demobp_Thirdpersoncontroller.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demoenvquerycontext_Player.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demoenvquerycontext_Player.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofirstpersoncharacter.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofirstpersoncharacter.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsbp_Doorframe.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsbp_Doorframe.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscontroller.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscontroller.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Body.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Body.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Footik.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Footik.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpscr_Mannequin_Procedural.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpscr_Mannequin_Procedural.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsuithumbstick.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuithumbstick.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demofpsuitouchsimple.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demofpsuitouchsimple.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demostatetreecondition_Ischaractergrounded.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreecondition_Ischaractergrounded.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Demostatetreetask_Chargedattack.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Demostatetreetask_Chargedattack.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr101.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr101.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr102.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr102.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr103.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr103.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr104.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr104.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr105.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr105.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr106.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr106.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr107.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr107.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr108.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr108.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr109.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr109.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr110.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr110.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr111.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr111.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr112.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr112.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Fhfhgytr113.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Fhfhgytr113.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint called BP_Hello_World.Dsl.Dsl.Dsl.Dsl that performs an action an event.", "input": "", "output": "BLUEPRINT: BP_Hello_World.Dsl.Dsl.Dsl.Dsl\nPARENT: Actor\n\nGRAPH: EventGraph"}
{"instruction": "Create a Blueprint that prints Hello World when the game starts.", "output": "BLUEPRINT: BP_HelloWorld\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Hello World\"]\n\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_01:L01_01", "category": "print_hello"}
{"instruction": "Create a Blueprint for an actor that continuously rotates at 90 degrees per second on the Yaw axis.", "output": "BLUEPRINT: BP_RotatingActor\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: MakeRotator [X=0, Y=0, Z=90]\nNODE n3: MultiplyFloat\nNODE n4: AddActorLocalRotation\n\nEXEC n1.Then -> n4.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.ReturnValue -> n3.B [Rotator]\nDATA n3.ReturnValue -> n4.DeltaRotation [Rotator]", "source": "lesson:lesson_01:L01_02", "category": "rotating_actor"}
{"instruction": "Create a Blueprint that prints Entered when another actor overlaps it and prints Exited when the overlap ends.", "output": "BLUEPRINT: BP_OverlapZone\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: PrintString [InString=\"Entered\"]\nNODE n3: Event_ActorEndOverlap\nNODE n4: PrintString [InString=\"Exited\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_03", "category": "overlap_event"}
{"instruction": "Create a Blueprint with a boolean variable IsActive. On BeginPlay, check if IsActive is true. If true, print Active. If false, print Inactive.", "output": "BLUEPRINT: BP_BranchExample\nPARENT: Actor\n\nVAR IsActive: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Branch\nNODE n3: PrintString [InString=\"Active\"]\nNODE n4: PrintString [InString=\"Inactive\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.True -> n3.Execute\nEXEC n2.False -> n4.Execute\n\nDATA n1.IsActive -> n2.Condition [Bool]", "source": "lesson:lesson_01:L01_04", "category": "branch"}
{"instruction": "Create a Blueprint that waits 3 seconds after the game starts, then destroys itself.", "output": "BLUEPRINT: BP_TimedDestroy\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_05", "category": "delay"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence node to first print Step 1, then print Step 2, then print Step 3.", "output": "BLUEPRINT: BP_SequenceExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: PrintString [InString=\"Step 2\"]\nNODE n5: PrintString [InString=\"Step 3\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n2.Then_2 -> n5.Execute", "source": "lesson:lesson_01:L01_06", "category": "sequence"}
{"instruction": "Create a Blueprint that toggles an actor's visibility each time the player presses the Interact input action using a FlipFlop node.", "output": "BLUEPRINT: BP_ToggleVisibility\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetActorHiddenInGame [NewHidden=false]\nNODE n4: SetActorHiddenInGame [NewHidden=true]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_01:L01_07", "category": "flipflop"}
{"instruction": "Create a Blueprint that prints Welcome only the first time the player overlaps with the actor using a DoOnce node.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_08", "category": "doonce"}
{"instruction": "Create a Blueprint that on overlap, casts the other actor to a Character class. If the cast succeeds, print Player Found.", "output": "BLUEPRINT: BP_CastExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player Found\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]", "source": "lesson:lesson_01:L01_09", "category": "cast"}
{"instruction": "Create a Blueprint with an array of Actors called TargetActors. On BeginPlay, loop through each actor in the array and destroy it.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\n\nVAR TargetActors: Array = None\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: ForEachLoop\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\n\nDATA n1.TargetActors -> n2.Array [Array]\nDATA n2.ArrayElement -> n3.Target [Actor]", "source": "lesson:lesson_01:L01_10", "category": "foreach"}
{"instruction": "Create a Blueprint with a Gate node. On BeginPlay, open the gate. On Tick, pass through the gate and print Ticking. On pressing the Close input action, close the gate.", "output": "BLUEPRINT: BP_GateExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: Event_Tick\nNODE n4: PrintString [InString=\"Ticking\"]\nNODE n5: Event_InputAction [ActionName=\"Close\"]\n\nEXEC n1.Then -> n2.Open\nEXEC n3.Then -> n2.Enter\nEXEC n2.Exit -> n4.Execute\nEXEC n5.Pressed -> n2.Close", "source": "lesson:lesson_01:L01_11", "category": "gate"}
{"instruction": "Create a Blueprint with a custom event called OnActivate. On BeginPlay, call the custom event. The custom event prints Activated when called.", "output": "BLUEPRINT: BP_CustomEventExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=\"OnActivate\"]\nNODE n3: Event_CustomEvent [EventName=\"OnActivate\"]\nNODE n4: PrintString [InString=\"Activated\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_12", "category": "custom_event"}
{"instruction": "Create a Blueprint with an integer variable Score starting at 0. On overlap, add 10 to the score and print the new score.", "output": "BLUEPRINT: BP_ScoreCounter\nPARENT: Actor\n\nVAR Score: Int = 0\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetVariable [VarName=\"Score\"]\nNODE n3: AddInt\nNODE n4: SetVariable [VarName=\"Score\"]\nNODE n5: PrintString\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nDATA n4.Value -> n5.InString [String]", "source": "lesson:lesson_01:L01_13", "category": "variable_set_get"}
{"instruction": "Create a Blueprint that spawns a projectile actor at the player's location when the Fire input action is pressed.", "output": "BLUEPRINT: BP_ProjectileSpawner\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: GetActorRotation\nNODE n4: SpawnActor [ActorClass=\"BP_Projectile\"]\n\nEXEC n1.Pressed -> n4.Execute\n\nDATA n2.ReturnValue -> n4.SpawnLocation [Vector]\nDATA n3.ReturnValue -> n4.SpawnRotation [Rotator]", "source": "lesson:lesson_01:L01_14", "category": "spawn_actor"}
{"instruction": "Create a Blueprint that plays a sound effect when the actor is overlapped by another actor.", "output": "BLUEPRINT: BP_SoundOnOverlap\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetActorLocation\nNODE n3: PlaySound [Sound=\"OverlapSound\"]\n\nEXEC n1.Then -> n3.Execute\n\nDATA n2.ReturnValue -> n3.Location [Vector]", "source": "lesson:lesson_01:L01_15", "category": "play_sound"}
{"instruction": "Create a Blueprint that on Tick, gets the distance to another actor stored in a variable called TargetActor. If the distance is less than 500, print Close.", "output": "BLUEPRINT: BP_DistanceChecker\nPARENT: Actor\n\nVAR TargetActor: Actor = None\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetDistanceTo\nNODE n3: LessThanFloat\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Close\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\n\nDATA n1.TargetActor -> n2.OtherActor [Actor]\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "source": "lesson:lesson_01:L01_16", "category": "distance_check"}
{"instruction": "Create a Blueprint that prints Started on BeginPlay, prints Tick Count each frame using Event Tick, and prints Goodbye before the actor is destroyed using Event EndPlay.", "output": "BLUEPRINT: BP_LifecycleEvents\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_Tick\nNODE n4: PrintString [InString=\"Tick Count\"]\nNODE n5: Event_EndPlay\nNODE n6: PrintString [InString=\"Goodbye\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_01:L01_17", "category": "multi_event"}
{"instruction": "Create a Blueprint with a boolean variable IsVisible starting as true. On pressing Toggle input, flip IsVisible and call SetActorHiddenInGame with the new value.", "output": "BLUEPRINT: BP_VisibilityToggle\nPARENT: Actor\n\nVAR IsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Toggle\"]\nNODE n2: GetVariable [VarName=\"IsVisible\"]\nNODE n3: NotBool\nNODE n4: SetVariable [VarName=\"IsVisible\"]\nNODE n5: SetActorHiddenInGame\n\nEXEC n1.Pressed -> n4.Execute\nEXEC n4.Then -> n5.Execute\n\nDATA n2.Value -> n3.Input [Bool]\nDATA n3.ReturnValue -> n4.Value [Bool]\nDATA n3.ReturnValue -> n5.NewHidden [Bool]", "source": "lesson:lesson_01:L01_18", "category": "set_visibility"}
{"instruction": "Create a Blueprint that on BeginPlay calculates the result of (5 + 3) multiplied by 2 and prints the result.", "output": "BLUEPRINT: BP_MathExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: AddFloat [A=5.0, B=3.0]\nNODE n3: MultiplyFloat [B=2.0]\nNODE n4: PrintString\n\nEXEC n1.Then -> n4.Execute\n\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_01:L01_19", "category": "math_chain"}
{"instruction": "Create a Blueprint that on BeginPlay prints Ready, waits 2 seconds, prints Set, waits 1 second, then prints Go.", "output": "BLUEPRINT: BP_Countdown\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Delay [Duration=2.0]\nNODE n4: PrintString [InString=\"Set\"]\nNODE n5: Delay [Duration=1.0]\nNODE n6: PrintString [InString=\"Go\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute", "source": "lesson:lesson_01:L01_20", "category": "delay_chain"}
{"instruction": "Create a Blueprint with a boolean variable IsActive. On BeginPlay, use a Branch node to check IsActive. If true, print Active. If false, print Inactive.", "output": "BLUEPRINT: BP_BranchCheck\nPARENT: Actor\nVAR IsActive: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsActive]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Active\"]\nNODE n5: PrintString [InString=\"Inactive\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_02:L02_01", "category": "branch"}
{"instruction": "Create a Blueprint that on overlap checks if the overlapping actor has the tag Enemy. If yes, print Danger. If no, print Safe.", "output": "BLUEPRINT: BP_TagBranch\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: ActorHasTag [Tag=\"Enemy\"]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Danger\"]\nNODE n5: PrintString [InString=\"Safe\"]\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_02:L02_02", "category": "branch"}
{"instruction": "Create a Blueprint with an integer variable Score set to 0. On BeginPlay, set Score to 100 then print the value of Score.", "output": "BLUEPRINT: BP_SetScore\nPARENT: Actor\nVAR Score: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=Score]\nNODE n3: VariableGet [VarName=Score]\nNODE n4: PrintString\nEXEC n1.Then -> n2.Execute\nDATA 100 -> n2.Value [Int]\nEXEC n2.Then -> n4.Execute\nDATA n3.Value -> n4.InString [String]", "source": "lesson:lesson_02:L02_03", "category": "variable_set_get"}
{"instruction": "Create a Blueprint with a float variable Health starting at 100.0. On Event AnyDamage, subtract the damage amount from Health and set the new value.", "output": "BLUEPRINT: BP_HealthTracker\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: Subtract\nNODE n4: VariableSet [VarName=Health]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]", "source": "lesson:lesson_02:L02_04", "category": "variable_set_get"}
{"instruction": "Create a Blueprint with a custom event called OnActivate. On BeginPlay, call the custom event OnActivate. The OnActivate event prints Activated.", "output": "BLUEPRINT: BP_CustomActivate\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=OnActivate]\nNODE n3: Event_Custom [EventName=OnActivate]\nNODE n4: PrintString [InString=\"Activated\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_05", "category": "custom_event"}
{"instruction": "Create a Blueprint with a custom event TakeDamage that takes a float input Amount. When TakeDamage is called, print the Amount value.", "output": "BLUEPRINT: BP_CustomDamage\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Custom [EventName=TakeDamage]\nNODE n2: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n1.Amount -> n2.InString [String]", "source": "lesson:lesson_02:L02_06", "category": "custom_event"}
{"instruction": "Create a Blueprint with a Gate node. On BeginPlay, open the gate. When the player presses the Fire input action, the gate filters execution to print Firing.", "output": "BLUEPRINT: BP_GateExample\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: Event_InputAction [ActionName=\"Fire\"]\nNODE n4: PrintString [InString=\"Firing\"]\nEXEC n1.Then -> n2.Open\nEXEC n3.Pressed -> n2.Enter\nEXEC n2.Exit -> n4.Execute", "source": "lesson:lesson_02:L02_07", "category": "gate"}
{"instruction": "Create a Blueprint where pressing Interact opens a gate and pressing Fire enters the gate to toggle visibility.", "output": "BLUEPRINT: BP_GateToggle\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: Gate\nNODE n3: Event_InputAction [ActionName=\"Fire\"]\nNODE n4: ToggleVisibility\nEXEC n1.Pressed -> n2.Open\nEXEC n3.Pressed -> n2.Enter\nEXEC n2.Exit -> n4.Execute", "source": "lesson:lesson_02:L02_08", "category": "gate"}
{"instruction": "Create a Blueprint that spawns a projectile actor at the player's location when the Fire input is pressed.", "output": "BLUEPRINT: BP_SpawnProjectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]", "source": "lesson:lesson_02:L02_09", "category": "spawn_actor"}
{"instruction": "Create a Blueprint that on BeginPlay spawns 3 enemy actors using a ForEachLoop over an array.", "output": "BLUEPRINT: BP_SpawnEnemies\nPARENT: Actor\nVAR SpawnPoints: Array<Vector>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=SpawnPoints]\nNODE n3: ForEachLoop\nNODE n4: SpawnActorFromClass [ActorClass=BP_Enemy]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.SpawnTransform [Transform]", "source": "lesson:lesson_02:L02_10", "category": "spawn_actor"}
{"instruction": "Create a Blueprint with an array of Actors called Targets. On BeginPlay, use a ForEachLoop to iterate through Targets and call DestroyActor on each one.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: DestroyActor\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]", "source": "lesson:lesson_02:L02_11", "category": "foreach"}
{"instruction": "Create a Blueprint that on BeginPlay loops through an array of strings called Messages and prints each one.", "output": "BLUEPRINT: BP_PrintAll\nPARENT: Actor\nVAR Messages: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Messages]\nNODE n3: ForEachLoop\nNODE n4: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.InString [String]", "source": "lesson:lesson_02:L02_12", "category": "foreach"}
{"instruction": "Create a Blueprint that on Tick gets the distance to the player. If the distance is less than 500, print Close.", "output": "BLUEPRINT: BP_DistanceCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=500.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Close\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute", "source": "lesson:lesson_02:L02_13", "category": "distance_check"}
{"instruction": "Create a Blueprint that on Tick checks distance to the player. If less than 200, print Near. If more than 1000, print Far.", "output": "BLUEPRINT: BP_NearFar\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Near\"]\nNODE n7: GreaterThan [B=1000.0]\nNODE n8: Branch\nNODE n9: PrintString [InString=\"Far\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n8.Execute\nDATA n3.ReturnValue -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute", "source": "lesson:lesson_02:L02_14", "category": "distance_check"}
{"instruction": "Create a Blueprint with a boolean variable IsVisible starting at true. On BeginPlay, set IsVisible to false and call SetVisibility with NewVisibility set to false.", "output": "BLUEPRINT: BP_HideOnStart\nPARENT: Actor\nVAR IsVisible: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=IsVisible]\nNODE n3: SetVisibility [NewVisibility=false]\nEXEC n1.Then -> n2.Execute\nDATA false -> n2.Value [Bool]\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_02:L02_15", "category": "set_visibility"}
{"instruction": "Create a Blueprint that toggles visibility each time the player presses Interact. Use a FlipFlop and SetVisibility nodes.", "output": "BLUEPRINT: BP_ToggleVis\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [NewVisibility=true]\nNODE n4: SetVisibility [NewVisibility=false]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_02:L02_16", "category": "set_visibility"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence node to first print Step 1, then print Step 2, then print Step 3.", "output": "BLUEPRINT: BP_SequenceSteps\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: PrintString [InString=\"Step 2\"]\nNODE n5: PrintString [InString=\"Step 3\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n2.Then_2 -> n5.Execute", "source": "lesson:lesson_02:L02_17", "category": "sequence"}
{"instruction": "Create a Blueprint that on Tick adds a rotation of 1.0 on the Yaw axis to make the actor spin continuously.", "output": "BLUEPRINT: BP_Spinner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalRotation [DeltaRotation=(Pitch=0.0,Yaw=1.0,Roll=0.0)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_02:L02_18", "category": "rotating_actor"}
{"instruction": "Create a Blueprint that when another actor overlaps, prints the name of the overlapping actor using GetDisplayName.", "output": "BLUEPRINT: BP_PrintOverlapper\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetDisplayName\nNODE n3: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.InString [String]", "source": "lesson:lesson_02:L02_19", "category": "overlap_event"}
{"instruction": "Create a Blueprint that plays a sound at the actor's location when BeginPlay fires. Use PlaySoundAtLocation.", "output": "BLUEPRINT: BP_PlayStartSound\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: PlaySoundAtLocation [Sound=StartSound]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Location [Vector]", "source": "lesson:lesson_02:L02_20", "category": "play_sound"}
{"instruction": "Create a Blueprint that prints Welcome only the first time the player overlaps, using a DoOnce node.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_02:L02_21", "category": "doonce"}
{"instruction": "Create a Blueprint that on BeginPlay multiplies 5 times 10, adds 25, and prints the result.", "output": "BLUEPRINT: BP_MathChain\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Multiply [A=5, B=10]\nNODE n3: Add [A=0, B=25]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_02:L02_22", "category": "math_chain"}
{"instruction": "Create a Blueprint that prints Started on BeginPlay and prints Ended on EndPlay.", "output": "BLUEPRINT: BP_StartEnd\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_EndPlay\nNODE n4: PrintString [InString=\"Ended\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_23", "category": "multi_event"}
{"instruction": "Create a Blueprint with three events: BeginPlay prints Ready, pressing Jump prints Jumped, and on overlap prints Touched.", "output": "BLUEPRINT: BP_ThreeEvents\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Event_InputAction [ActionName=\"Jump\"]\nNODE n4: PrintString [InString=\"Jumped\"]\nNODE n5: Event_ActorBeginOverlap\nNODE n6: PrintString [InString=\"Touched\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Pressed -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_02:L02_24", "category": "multi_event"}
{"instruction": "Create a Blueprint that on BeginPlay sets a timer called SpawnTimer that calls a custom event SpawnEnemy every 5 seconds.", "output": "BLUEPRINT: BP_SpawnTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnEnemy\", Time=5.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnEnemy]\nNODE n4: PrintString [InString=\"Enemy Spawned\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_03:L03_01", "category": "timer_basic"}
{"instruction": "Create a Blueprint that starts a looping timer on BeginPlay and clears it when the player presses the Stop input action.", "output": "BLUEPRINT: BP_StoppableTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"DoWork\", Time=2.0, Looping=true]\nNODE n3: Event_InputAction [ActionName=\"Stop\"]\nNODE n4: ClearTimerByFunctionName [FunctionName=\"DoWork\"]\nNODE n5: Event_Custom [EventName=DoWork]\nNODE n6: PrintString [InString=\"Working\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Pressed -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_03:L03_02", "category": "timer_clear"}
{"instruction": "Create a Blueprint that on BeginPlay sets a one-shot timer for 10 seconds. When the timer fires, destroy the actor.", "output": "BLUEPRINT: BP_SelfDestruct\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SelfDestruct\", Time=10.0, Looping=false]\nNODE n3: Event_Custom [EventName=SelfDestruct]\nNODE n4: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_03:L03_03", "category": "timer_oneshot"}
{"instruction": "Create a Blueprint that on overlap starts a retriggerable delay of 3 seconds. When the delay completes, print Timeout. Each new overlap resets the timer.", "output": "BLUEPRINT: BP_RetriggerExample\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: RetriggerableDelay [Duration=3.0]\nNODE n3: PrintString [InString=\"Timeout\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_03:L03_04", "category": "retriggerable_delay"}
{"instruction": "Create a Blueprint with a boolean variable IsActive. On BeginPlay, check IsActive. If true, set a looping timer every 2 seconds. If false, print Disabled.", "output": "BLUEPRINT: BP_ConditionalTimer\nPARENT: Actor\nVAR IsActive: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsActive]\nNODE n3: Branch\nNODE n4: SetTimerByFunctionName [FunctionName=\"Pulse\", Time=2.0, Looping=true]\nNODE n5: PrintString [InString=\"Disabled\"]\nNODE n6: Event_Custom [EventName=Pulse]\nNODE n7: PrintString [InString=\"Pulse\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_03:L03_05", "category": "timer_with_branch"}
{"instruction": "Create a Blueprint that on BeginPlay prints Phase 1, waits 2 seconds, prints Phase 2, waits 3 seconds, prints Phase 3, waits 1 second, then destroys itself.", "output": "BLUEPRINT: BP_PhasedSequence\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Phase 1\"]\nNODE n3: Delay [Duration=2.0]\nNODE n4: PrintString [InString=\"Phase 2\"]\nNODE n5: Delay [Duration=3.0]\nNODE n6: PrintString [InString=\"Phase 3\"]\nNODE n7: Delay [Duration=1.0]\nNODE n8: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute\nEXEC n6.Then -> n7.Execute\nEXEC n7.Completed -> n8.Execute", "source": "lesson:lesson_03:L03_06", "category": "delay_sequence"}
{"instruction": "Create a Blueprint with an integer variable Count starting at 0. Set a looping timer every 1 second. Each time the timer fires, increment Count by 1 and print the count. When Count reaches 5, clear the timer.", "output": "BLUEPRINT: BP_CountdownTimer\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Tick\", Time=1.0, Looping=true]\nNODE n3: Event_Custom [EventName=Tick]\nNODE n4: VariableGet [VarName=Count]\nNODE n5: AddInt [B=1]\nNODE n6: VariableSet [VarName=Count]\nNODE n7: PrintString\nNODE n8: GreaterThan [B=4]\nNODE n9: Branch\nNODE n10: ClearTimerByFunctionName [FunctionName=\"Tick\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Value [Int]\nEXEC n6.Then -> n7.Execute\nDATA n6.Value -> n7.InString [String]\nEXEC n7.Then -> n9.Execute\nDATA n6.Value -> n8.A [Int]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute", "source": "lesson:lesson_03:L03_07", "category": "timer_counter"}
{"instruction": "Create a Blueprint that on BeginPlay hides the actor, waits 5 seconds, then makes it visible.", "output": "BLUEPRINT: BP_DelayedAppear\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetActorHiddenInGame [NewHidden=true]\nNODE n3: Delay [Duration=5.0]\nNODE n4: SetActorHiddenInGame [NewHidden=false]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute", "source": "lesson:lesson_03:L03_08", "category": "delay_with_visibility"}
{"instruction": "Create a Blueprint where pressing Interact toggles a timer on and off. Use a boolean variable TimerRunning to track state.", "output": "BLUEPRINT: BP_ToggleTimer\nPARENT: Actor\nVAR TimerRunning: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: VariableGet [VarName=TimerRunning]\nNODE n3: Branch\nNODE n4: ClearTimerByFunctionName [FunctionName=\"DoTick\"]\nNODE n5: VariableSet [VarName=TimerRunning]\nNODE n6: SetTimerByFunctionName [FunctionName=\"DoTick\", Time=1.0, Looping=true]\nNODE n7: VariableSet [VarName=TimerRunning]\nNODE n8: Event_Custom [EventName=DoTick]\nNODE n9: PrintString [InString=\"Tick\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA false -> n5.Value [Bool]\nEXEC n3.False -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA true -> n7.Value [Bool]\nEXEC n8.Then -> n9.Execute", "source": "lesson:lesson_03:L03_09", "category": "timer_toggle"}
{"instruction": "Create a Blueprint that when overlapped, prints Entered, waits 2 seconds, then prints Welcome. Use a DoOnce so this only happens the first time.", "output": "BLUEPRINT: BP_DelayedWelcome\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Entered\"]\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Welcome\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_03:L03_10", "category": "delay_overlap"}
{"instruction": "Create a Blueprint that on BeginPlay sets a looping timer every 3 seconds. Each time the timer fires, spawn an actor of class BP_Coin at the actor's location.", "output": "BLUEPRINT: BP_CoinSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnCoin\", Time=3.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnCoin]\nNODE n4: GetActorLocation\nNODE n5: SpawnActorFromClass [ActorClass=BP_Coin]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]", "source": "lesson:lesson_03:L03_11", "category": "timer_spawner"}
{"instruction": "Create a Blueprint that on BeginPlay checks a boolean IsFast. If true, wait 1 second then print Done. If false, wait 5 seconds then print Done.", "output": "BLUEPRINT: BP_ConditionalDelay\nPARENT: Actor\nVAR IsFast: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsFast]\nNODE n3: Branch\nNODE n4: Delay [Duration=1.0]\nNODE n5: Delay [Duration=5.0]\nNODE n6: PrintString [InString=\"Done\"]\nNODE n7: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute\nEXEC n4.Completed -> n6.Execute\nEXEC n5.Completed -> n7.Execute", "source": "lesson:lesson_03:L03_12", "category": "delay_chain_branch"}
{"instruction": "Create a Blueprint with a float variable Health at 50.0. On BeginPlay start a looping timer every 2 seconds. Each tick add 5 to Health and print the value. When Health reaches 100 or more, clear the timer and print Full Health.", "output": "BLUEPRINT: BP_HealthRegen\nPARENT: Actor\nVAR Health: Float = 50.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Regen\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=Regen]\nNODE n4: VariableGet [VarName=Health]\nNODE n5: AddFloat [B=5.0]\nNODE n6: VariableSet [VarName=Health]\nNODE n7: PrintString\nNODE n8: GreaterThan [B=99.9]\nNODE n9: Branch\nNODE n10: ClearTimerByFunctionName [FunctionName=\"Regen\"]\nNODE n11: PrintString [InString=\"Full Health\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n7.Execute\nDATA n6.Value -> n7.InString [String]\nEXEC n7.Then -> n9.Execute\nDATA n6.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute\nEXEC n10.Then -> n11.Execute", "source": "lesson:lesson_03:L03_13", "category": "timer_health_regen"}
{"instruction": "Create a Blueprint that when the player presses Interact, prints Action then starts a retriggerable delay of 2 seconds. When the delay completes print Idle. Each press resets the delay.", "output": "BLUEPRINT: BP_IdleDetector\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: PrintString [InString=\"Action\"]\nNODE n3: RetriggerableDelay [Duration=2.0]\nNODE n4: PrintString [InString=\"Idle\"]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute", "source": "lesson:lesson_03:L03_14", "category": "retriggerable_interaction"}
{"instruction": "Create a Blueprint that on BeginPlay starts a looping timer every 4 seconds. Each time the timer fires, play a sound at the actor's location.", "output": "BLUEPRINT: BP_RepeatingSound\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"PlayBeep\", Time=4.0, Looping=true]\nNODE n3: Event_Custom [EventName=PlayBeep]\nNODE n4: GetActorLocation\nNODE n5: PlaySoundAtLocation [Sound=BeepSound]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Location [Vector]", "source": "lesson:lesson_03:L03_15", "category": "timer_with_sound"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence node. The first output prints Spawned. The second output waits 10 seconds then calls DestroyActor.", "output": "BLUEPRINT: BP_TimedLife\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Spawned\"]\nNODE n4: Delay [Duration=10.0]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_03:L03_16", "category": "delay_destroy_sequence"}
{"instruction": "Create a Blueprint with a Gate node. On BeginPlay, open the gate and start a looping timer. The timer enters the gate. The gate exit prints Pulse. Pressing Stop closes the gate.", "output": "BLUEPRINT: BP_GatedTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"TimerTick\", Time=1.0, Looping=true]\nNODE n4: Event_Custom [EventName=TimerTick]\nNODE n5: PrintString [InString=\"Pulse\"]\nNODE n6: Event_InputAction [ActionName=\"Stop\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n6.Pressed -> n2.Close", "source": "lesson:lesson_03:L03_17", "category": "timer_with_gate"}
{"instruction": "Create a Blueprint where pressing Interact uses a FlipFlop. On the A output, wait 1 second then print On. On the B output, wait 1 second then print Off.", "output": "BLUEPRINT: BP_DelayedToggle\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: Delay [Duration=1.0]\nNODE n4: PrintString [InString=\"On\"]\nNODE n5: Delay [Duration=1.0]\nNODE n6: PrintString [InString=\"Off\"]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n2.B -> n5.Execute\nEXEC n5.Completed -> n6.Execute", "source": "lesson:lesson_03:L03_18", "category": "delay_flipflop"}
{"instruction": "Create a Blueprint that starts a 5-second self-destruct timer on BeginPlay. If the player overlaps the actor before the timer fires, clear the timer and print Saved.", "output": "BLUEPRINT: BP_DefuseBomb\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Explode\", Time=5.0, Looping=false]\nNODE n3: Event_Custom [EventName=Explode]\nNODE n4: DestroyActor\nNODE n5: Event_ActorBeginOverlap\nNODE n6: ClearTimerByFunctionName [FunctionName=\"Explode\"]\nNODE n7: PrintString [InString=\"Saved\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_03:L03_19", "category": "timer_overlap_clear"}
{"instruction": "Create a Blueprint that on BeginPlay prints Initializing and waits 3 seconds then prints Ready. On Tick prints Running. On EndPlay prints Shutting Down.", "output": "BLUEPRINT: BP_LifecycleDelayed\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Initializing\"]\nNODE n3: Delay [Duration=3.0]\nNODE n4: PrintString [InString=\"Ready\"]\nNODE n5: Event_Tick\nNODE n6: PrintString [InString=\"Running\"]\nNODE n7: Event_EndPlay\nNODE n8: PrintString [InString=\"Shutting Down\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_03:L03_20", "category": "delay_multi_event"}
{"instruction": "Create a Blueprint that on BeginPlay adds an upward impulse of 1000 units to launch the actor into the air.", "output": "BLUEPRINT: BP_Launcher\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: AddImpulse [Impulse=(X=0,Y=0,Z=1000)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_04:L04_01", "category": "physics_impulse"}
{"instruction": "Create a Blueprint that on Tick adds a constant forward force of 500 units to the actor.", "output": "BLUEPRINT: BP_ConstantPush\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorForwardVector\nNODE n3: MultiplyFloat [B=500.0]\nNODE n4: AddForce\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.A [Vector]\nDATA n3.ReturnValue -> n4.Force [Vector]", "source": "lesson:lesson_04:L04_02", "category": "physics_force"}
{"instruction": "Create a Blueprint that pressing Interact toggles physics simulation on and off using SetSimulatePhysics.", "output": "BLUEPRINT: BP_PhysicsToggle\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetSimulatePhysics [Simulate=true]\nNODE n4: SetSimulatePhysics [Simulate=false]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_04:L04_03", "category": "physics_toggle"}
{"instruction": "Create a Blueprint that on Tick moves the actor forward by 2 units per frame using AddActorLocalOffset.", "output": "BLUEPRINT: BP_SlowMover\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalOffset [DeltaLocation=(X=2.0,Y=0,Z=0)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_04:L04_04", "category": "movement_offset"}
{"instruction": "Create a Blueprint that on overlap teleports the overlapping actor to location (0, 0, 500) using SetActorLocation.", "output": "BLUEPRINT: BP_Teleporter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: MakeVector [X=0, Y=0, Z=500]\nNODE n3: SetActorLocation\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n3.Target [Actor]\nDATA n2.ReturnValue -> n3.NewLocation [Vector]", "source": "lesson:lesson_04:L04_05", "category": "movement_teleport"}
{"instruction": "Create a Blueprint that when overlapped, enables physics on itself and adds an upward impulse of 2000.", "output": "BLUEPRINT: BP_OverlapLaunch\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: AddImpulse [Impulse=(X=0,Y=0,Z=2000)]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_04:L04_06", "category": "physics_overlap_launch"}
{"instruction": "Create a Blueprint with a vector variable TargetLocation. On Tick, lerp the actor's position toward TargetLocation at alpha 0.05.", "output": "BLUEPRINT: BP_SmoothMover\nPARENT: Actor\nVAR TargetLocation: Vector\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: VariableGet [VarName=TargetLocation]\nNODE n4: Lerp [Alpha=0.05]\nNODE n5: SetActorLocation\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n4.A [Vector]\nDATA n3.Value -> n4.B [Vector]\nDATA n4.ReturnValue -> n5.NewLocation [Vector]", "source": "lesson:lesson_04:L04_07", "category": "movement_lerp"}
{"instruction": "Create a Blueprint that on Tick reads the MoveForward input axis value and moves the actor forward by that amount using AddActorLocalOffset.", "output": "BLUEPRINT: BP_InputMover\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetInputAxisValue [AxisName=\"MoveForward\"]\nNODE n3: MakeVector [Y=0, Z=0]\nNODE n4: AddActorLocalOffset\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.X [Float]\nDATA n3.ReturnValue -> n4.DeltaLocation [Vector]", "source": "lesson:lesson_04:L04_08", "category": "movement_input"}
{"instruction": "Create a Blueprint that on Hit adds an impulse in the opposite direction of the hit normal multiplied by 500.", "output": "BLUEPRINT: BP_Bouncer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Hit\nNODE n2: MultiplyFloat [B=-500.0]\nNODE n3: AddImpulse\nEXEC n1.Then -> n3.Execute\nDATA n1.HitNormal -> n2.A [Vector]\nDATA n2.ReturnValue -> n3.Impulse [Vector]", "source": "lesson:lesson_04:L04_09", "category": "physics_bounce"}
{"instruction": "Create a Blueprint with two vector variables PointA and PointB and a boolean AtA starting true. On Tick, if AtA is true move toward PointA, otherwise move toward PointB. When distance to target is less than 50, flip AtA.", "output": "BLUEPRINT: BP_Patrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR AtA: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=AtA]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=PointA]\nNODE n5: VariableGet [VarName=PointB]\nNODE n6: GetActorLocation\nNODE n7: Lerp [Alpha=0.02]\nNODE n8: Lerp [Alpha=0.02]\nNODE n9: SetActorLocation\nNODE n10: SetActorLocation\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n9.Execute\nEXEC n3.False -> n10.Execute\nDATA n6.ReturnValue -> n7.A [Vector]\nDATA n4.Value -> n7.B [Vector]\nDATA n7.ReturnValue -> n9.NewLocation [Vector]\nDATA n6.ReturnValue -> n8.A [Vector]\nDATA n5.Value -> n8.B [Vector]\nDATA n8.ReturnValue -> n10.NewLocation [Vector]", "source": "lesson:lesson_04:L04_10", "category": "movement_patrol"}
{"instruction": "Create a Blueprint that on BeginPlay waits 3 seconds, then enables physics simulation and prints Physics Enabled.", "output": "BLUEPRINT: BP_DelayedPhysics\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: SetSimulatePhysics [Simulate=true]\nNODE n4: PrintString [InString=\"Physics Enabled\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_04:L04_11", "category": "physics_delayed"}
{"instruction": "Create a Blueprint that on Tick rotates 1 degree on Yaw and moves forward 1 unit. This makes the actor move in a circle.", "output": "BLUEPRINT: BP_CircleMover\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=1.0,Roll=0)]\nNODE n3: AddActorLocalOffset [DeltaLocation=(X=1.0,Y=0,Z=0)]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_04:L04_12", "category": "movement_rotate_and_move"}
{"instruction": "Create a Blueprint with a boolean IsHeavy. On overlap, if IsHeavy add force of 5000 upward, else add force of 1000 upward.", "output": "BLUEPRINT: BP_ConditionalForce\nPARENT: Actor\nVAR IsHeavy: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=IsHeavy]\nNODE n3: Branch\nNODE n4: AddImpulse [Impulse=(X=0,Y=0,Z=5000)]\nNODE n5: AddImpulse [Impulse=(X=0,Y=0,Z=1000)]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_04:L04_13", "category": "physics_conditional_force"}
{"instruction": "Create a Blueprint with a float variable Speed set to 5.0. On Tick, multiply DeltaSeconds by Speed and move the actor forward by that amount.", "output": "BLUEPRINT: BP_VariableSpeed\nPARENT: Actor\nVAR Speed: Float = 5.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Speed]\nNODE n3: MultiplyFloat\nNODE n4: MakeVector [Y=0, Z=0]\nNODE n5: AddActorLocalOffset\nEXEC n1.Then -> n5.Execute\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.Value -> n3.B [Float]\nDATA n3.ReturnValue -> n4.X [Float]\nDATA n4.ReturnValue -> n5.DeltaLocation [Vector]", "source": "lesson:lesson_04:L04_14", "category": "movement_speed_variable"}
{"instruction": "Create a Blueprint that on overlap adds a downward force of 3000 to the overlapping actor every tick while they remain overlapped. On end overlap, stop.", "output": "BLUEPRINT: BP_GravityZone\nPARENT: Actor\nVAR IsOverlapping: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableSet [VarName=IsOverlapping]\nNODE n3: Event_ActorEndOverlap\nNODE n4: VariableSet [VarName=IsOverlapping]\nEXEC n1.Then -> n2.Execute\nDATA true -> n2.Value [Bool]\nEXEC n3.Then -> n4.Execute\nDATA false -> n4.Value [Bool]", "source": "lesson:lesson_04:L04_15", "category": "physics_gravity_zone"}
{"instruction": "Create a Blueprint that on Tick gets the actor location. If the Z position is below 0, set it to 0 using SetActorLocation. Print Clamped when this happens.", "output": "BLUEPRINT: BP_FloorClamp\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: BreakVector\nNODE n4: LessThan [B=0.0]\nNODE n5: Branch\nNODE n6: MakeVector [Z=0.0]\nNODE n7: SetActorLocation\nNODE n8: PrintString [InString=\"Clamped\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.Input [Vector]\nDATA n3.Z -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n3.X -> n6.X [Float]\nDATA n3.Y -> n6.Y [Float]\nDATA n6.ReturnValue -> n7.NewLocation [Vector]\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_04:L04_16", "category": "movement_clamp"}
{"instruction": "Create a Blueprint where pressing Fire uses a MultiGate with 3 outputs. Output 0 adds impulse right, output 1 adds impulse left, output 2 adds impulse up.", "output": "BLUEPRINT: BP_MultiImpulse\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: MultiGate\nNODE n3: AddImpulse [Impulse=(X=0,Y=500,Z=0)]\nNODE n4: AddImpulse [Impulse=(X=0,Y=-500,Z=0)]\nNODE n5: AddImpulse [Impulse=(X=0,Y=0,Z=500)]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Out_0 -> n3.Execute\nEXEC n2.Out_1 -> n4.Execute\nEXEC n2.Out_2 -> n5.Execute", "source": "lesson:lesson_04:L04_17", "category": "physics_multigate"}
{"instruction": "Create a Blueprint that on Tick moves the actor up and down using a sine wave. Get game time, apply sine, multiply by 100, set the Z location.", "output": "BLUEPRINT: BP_SineWave\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetGameTimeInSeconds\nNODE n3: Sin\nNODE n4: MultiplyFloat [B=100.0]\nNODE n5: GetActorLocation\nNODE n6: BreakVector\nNODE n7: MakeVector\nNODE n8: SetActorLocation\nEXEC n1.Then -> n8.Execute\nDATA n2.ReturnValue -> n3.Input [Float]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n5.ReturnValue -> n6.Input [Vector]\nDATA n6.X -> n7.X [Float]\nDATA n6.Y -> n7.Y [Float]\nDATA n4.ReturnValue -> n7.Z [Float]\nDATA n7.ReturnValue -> n8.NewLocation [Vector]", "source": "lesson:lesson_04:L04_18", "category": "movement_sine_wave"}
{"instruction": "Create a Blueprint that on BeginPlay enables physics and adds a forward impulse of 3000. After 5 seconds, destroy itself.", "output": "BLUEPRINT: BP_Projectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: GetActorForwardVector\nNODE n4: MultiplyFloat [B=3000.0]\nNODE n5: AddImpulse\nNODE n6: Delay [Duration=5.0]\nNODE n7: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.A [Vector]\nDATA n4.ReturnValue -> n5.Impulse [Vector]\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "source": "lesson:lesson_04:L04_19", "category": "physics_projectile"}
{"instruction": "Create a Blueprint with a float variable Speed at 100. On Tick, multiply Speed by DeltaSeconds, move actor forward by that amount. On pressing SpeedUp, add 50 to Speed.", "output": "BLUEPRINT: BP_Accelerator\nPARENT: Actor\nVAR Speed: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Speed]\nNODE n3: MultiplyFloat\nNODE n4: MakeVector [Y=0, Z=0]\nNODE n5: AddActorLocalOffset\nNODE n6: Event_InputAction [ActionName=\"SpeedUp\"]\nNODE n7: VariableGet [VarName=Speed]\nNODE n8: AddFloat [B=50.0]\nNODE n9: VariableSet [VarName=Speed]\nEXEC n1.Then -> n5.Execute\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.Value -> n3.B [Float]\nDATA n3.ReturnValue -> n4.X [Float]\nDATA n4.ReturnValue -> n5.DeltaLocation [Vector]\nEXEC n6.Pressed -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Value [Float]", "source": "lesson:lesson_04:L04_20", "category": "movement_scale_speed"}
{"instruction": "Create a Blueprint with an actor variable Target. On BeginPlay, check if Target is valid. If valid, print Target Found. If not, print No Target.", "output": "BLUEPRINT: BP_ValidCheck\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Target Found\"]\nNODE n6: PrintString [InString=\"No Target\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_05:L05_01", "category": "isvalid_basic"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If cast succeeds, print Player. If cast fails, print Not A Player.", "output": "BLUEPRINT: BP_SafeCast\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player\"]\nNODE n4: PrintString [InString=\"Not A Player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute", "source": "lesson:lesson_05:L05_02", "category": "isvalid_cast"}
{"instruction": "Create a Blueprint with an actor variable Target. On pressing Fire, check if Target is valid. If valid, destroy Target. If not, print Nothing To Destroy.", "output": "BLUEPRINT: BP_SafeDestroy\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: DestroyActor\nNODE n6: PrintString [InString=\"Nothing To Destroy\"]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.Value -> n5.Target [Actor]\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_05:L05_03", "category": "isvalid_destroy"}
{"instruction": "Create a Blueprint that on overlap, casts to Pawn. If the cast succeeds and the pawn is valid, get its location and print it.", "output": "BLUEPRINT: BP_PawnDetector\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetActorLocation\nNODE n6: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n2.AsCharacter -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n6.Execute\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_05:L05_04", "category": "isvalid_overlap_cast"}
{"instruction": "Create a Blueprint that starts a timer on BeginPlay. The timer checks if a variable Target is valid. If valid, get distance to target and print it. If not valid, print Searching.", "output": "BLUEPRINT: BP_TargetTracker\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"CheckTarget\", Time=1.0, Looping=true]\nNODE n3: Event_Custom [EventName=CheckTarget]\nNODE n4: VariableGet [VarName=Target]\nNODE n5: IsValid\nNODE n6: Branch\nNODE n7: GetDistanceTo\nNODE n8: PrintString\nNODE n9: PrintString [InString=\"Searching\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.Input [Object]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n8.Execute\nDATA n4.Value -> n7.OtherActor [Actor]\nDATA n7.ReturnValue -> n8.InString [String]\nEXEC n6.False -> n9.Execute", "source": "lesson:lesson_05:L05_05", "category": "isvalid_timer_check"}
{"instruction": "Create a Blueprint with an array variable Items. On BeginPlay, loop through Items with ForEachLoop. For each item, check IsValid before printing its name.", "output": "BLUEPRINT: BP_SafeArrayLoop\nPARENT: Actor\nVAR Items: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Items]\nNODE n3: ForEachLoop\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: GetDisplayName\nNODE n7: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n3.ArrayElement -> n6.Target [Actor]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_05:L05_06", "category": "isvalid_array"}
{"instruction": "Create a Blueprint that on pressing Fire spawns an actor. Check if spawn was valid. If yes print Spawned. If no print Spawn Failed.", "output": "BLUEPRINT: BP_SafeSpawn\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Spawned\"]\nNODE n7: PrintString [InString=\"Spawn Failed\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_05:L05_07", "category": "isvalid_spawn_check"}
{"instruction": "Create a Blueprint that on BeginPlay gets the player character. Check if valid. If valid, print the player's location.", "output": "BLUEPRINT: BP_FindPlayer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetActorLocation\nNODE n6: PrintString\nNODE n7: PrintString [InString=\"No Player\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n6.Execute\nDATA n2.ReturnValue -> n5.Target [Actor]\nDATA n5.ReturnValue -> n6.InString [String]\nEXEC n4.False -> n7.Execute", "source": "lesson:lesson_05:L05_08", "category": "isvalid_get_player"}
{"instruction": "Create a Blueprint with an actor variable Enemy. On Tick, check if Enemy is valid. If valid and distance less than 300, print Danger.", "output": "BLUEPRINT: BP_EnemyProximity\nPARENT: Actor\nVAR Enemy: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Enemy]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=300.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Danger\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.Value -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute", "source": "lesson:lesson_05:L05_09", "category": "isvalid_before_distance"}
{"instruction": "Create a Blueprint that on overlap uses DoOnce, then casts to Character. On success print First Player Contact.", "output": "BLUEPRINT: BP_FirstContact\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: CastToCharacter\nNODE n4: PrintString [InString=\"First Player Contact\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nDATA n1.OtherActor -> n3.Object [Actor]\nEXEC n3.CastSucceeded -> n4.Execute", "source": "lesson:lesson_05:L05_10", "category": "isvalid_doonce_cast"}
{"instruction": "Create a Blueprint that on overlap casts the other actor to PlayerController. If success, print Controller Found.", "output": "BLUEPRINT: BP_ControllerCast\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToPlayerController\nNODE n3: PrintString [InString=\"Controller Found\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute", "source": "lesson:lesson_05:L05_11", "category": "cast_to_controller"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence. First output checks if variable A is valid. Second output checks if variable B is valid. Print the status of each.", "output": "BLUEPRINT: BP_MultiValidCheck\nPARENT: Actor\nVAR A: Actor = None\nVAR B: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: VariableGet [VarName=A]\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: PrintString [InString=\"A Valid\"]\nNODE n7: PrintString [InString=\"A Invalid\"]\nNODE n8: VariableGet [VarName=B]\nNODE n9: IsValid\nNODE n10: Branch\nNODE n11: PrintString [InString=\"B Valid\"]\nNODE n12: PrintString [InString=\"B Invalid\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n5.Execute\nDATA n3.Value -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute\nEXEC n2.Then_1 -> n10.Execute\nDATA n8.Value -> n9.Input [Object]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n11.Execute\nEXEC n10.False -> n12.Execute", "source": "lesson:lesson_05:L05_12", "category": "isvalid_sequence_checks"}
{"instruction": "Create a Blueprint that on BeginPlay spawns an actor, checks if valid, and if so stores it in a variable SpawnedActor.", "output": "BLUEPRINT: BP_SpawnAndStore\nPARENT: Actor\nVAR SpawnedActor: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Item]\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: VariableSet [VarName=SpawnedActor]\nNODE n7: PrintString [InString=\"Stored\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA n3.ReturnValue -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_05:L05_13", "category": "isvalid_set_after_spawn"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If cast succeeds, store the character in a variable LastPlayer and print Saved Player.", "output": "BLUEPRINT: BP_SavePlayer\nPARENT: Actor\nVAR LastPlayer: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableSet [VarName=LastPlayer]\nNODE n4: PrintString [InString=\"Saved Player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nDATA n2.AsCharacter -> n3.Value [Actor]\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_05:L05_14", "category": "cast_with_variable"}
{"instruction": "Create a Blueprint that on pressing Fire checks if variable Target is valid. If valid, destroy Target and set Target to None. Print the result either way.", "output": "BLUEPRINT: BP_CleanDestroy\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: DestroyActor\nNODE n6: VariableSet [VarName=Target]\nNODE n7: PrintString [InString=\"Destroyed\"]\nNODE n8: PrintString [InString=\"No Target\"]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.Value -> n5.Target [Actor]\nEXEC n5.Then -> n6.Execute\nDATA None -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute\nEXEC n4.False -> n8.Execute", "source": "lesson:lesson_05:L05_15", "category": "isvalid_conditional_destroy"}
{"instruction": "Create a Blueprint with a Gate. On BeginPlay check if variable Controller is valid. If valid, open the gate. On Tick, enter the gate. Gate exit prints Active.", "output": "BLUEPRINT: BP_ValidGate\nPARENT: Actor\nVAR Controller: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Controller]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: Gate\nNODE n6: Event_Tick\nNODE n7: PrintString [InString=\"Active\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Open\nEXEC n6.Then -> n5.Enter\nEXEC n5.Exit -> n7.Execute", "source": "lesson:lesson_05:L05_16", "category": "isvalid_gate_pattern"}
{"instruction": "Create a Blueprint that on overlap first tries CastToCharacter. If that fails, try CastToPawn. If both fail, print Unknown Actor.", "output": "BLUEPRINT: BP_FallbackCast\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Character\"]\nNODE n4: CastToPawn\nNODE n5: PrintString [InString=\"Pawn\"]\nNODE n6: PrintString [InString=\"Unknown Actor\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute\nDATA n1.OtherActor -> n4.Object [Actor]\nEXEC n4.CastSucceeded -> n5.Execute\nEXEC n4.CastFailed -> n6.Execute", "source": "lesson:lesson_05:L05_17", "category": "isvalid_multi_cast"}
{"instruction": "Create a Blueprint with an actor array Enemies. On pressing Fire, loop through Enemies, check each is valid, and destroy valid ones. Print how many were destroyed.", "output": "BLUEPRINT: BP_DestroyValid\nPARENT: Actor\nVAR Enemies: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Enemies]\nNODE n3: ForEachLoop\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: DestroyActor\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA n3.ArrayElement -> n6.Target [Actor]", "source": "lesson:lesson_05:L05_18", "category": "isvalid_foreach_destroy"}
{"instruction": "Create a Blueprint that on Tick gets the player pawn, checks if valid, then gets distance. If distance less than 500 and player is valid, print Alert.", "output": "BLUEPRINT: BP_SafeAlert\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=500.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Alert\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute", "source": "lesson:lesson_05:L05_19", "category": "isvalid_safe_distance"}
{"instruction": "Create a Blueprint that on BeginPlay gets player pawn, validates it, casts to Character, and if all checks pass stores it in a variable Player and prints Connected.", "output": "BLUEPRINT: BP_FullValidation\nPARENT: Actor\nVAR Player: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetPlayerPawn\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: CastToCharacter\nNODE n6: VariableSet [VarName=Player]\nNODE n7: PrintString [InString=\"Connected\"]\nNODE n8: PrintString [InString=\"No Player Found\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.ReturnValue -> n5.Object [Actor]\nEXEC n5.CastSucceeded -> n6.Execute\nDATA n5.AsCharacter -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute\nEXEC n4.False -> n8.Execute", "source": "lesson:lesson_05:L05_20", "category": "isvalid_complete_pattern"}
{"instruction": "Create a Blueprint that on BeginPlay runs a ForLoop from 0 to 9 and prints the index each iteration.", "output": "BLUEPRINT: BP_ForLoopPrint\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]", "source": "lesson:lesson_06:L06_01", "category": "forloop_basic"}
{"instruction": "Create a Blueprint that on BeginPlay uses a ForLoop 0 to 4 to spawn 5 actors in a row, each 200 units apart on the X axis.", "output": "BLUEPRINT: BP_RowSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=4]\nNODE n3: MultiplyFloat [B=200.0]\nNODE n4: MakeVector [Y=0, Z=0]\nNODE n5: SpawnActorFromClass [ActorClass=BP_Item]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n5.Execute\nDATA n2.Index -> n3.A [Float]\nDATA n3.ReturnValue -> n4.X [Float]\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]", "source": "lesson:lesson_06:L06_02", "category": "forloop_spawn"}
{"instruction": "Create a Blueprint with integer Total at 0. On BeginPlay use ForLoop 1 to 10 to sum all numbers. After completion print the total.", "output": "BLUEPRINT: BP_SumLoop\nPARENT: Actor\nVAR Total: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=10]\nNODE n3: VariableGet [VarName=Total]\nNODE n4: AddInt\nNODE n5: VariableSet [VarName=Total]\nNODE n6: VariableGet [VarName=Total]\nNODE n7: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n5.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n2.Index -> n4.B [Int]\nDATA n4.ReturnValue -> n5.Value [Int]\nEXEC n2.Completed -> n7.Execute\nDATA n6.Value -> n7.InString [String]", "source": "lesson:lesson_06:L06_03", "category": "forloop_sum"}
{"instruction": "Create a Blueprint with integer Count at 0. On BeginPlay use a WhileLoop while Count less than 5 to increment and print Count.", "output": "BLUEPRINT: BP_WhileCount\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Count]\nNODE n4: LessThan [B=5]\nNODE n5: VariableGet [VarName=Count]\nNODE n6: AddInt [B=1]\nNODE n7: VariableSet [VarName=Count]\nNODE n8: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n7.Execute\nDATA n5.Value -> n6.A [Int]\nDATA n6.ReturnValue -> n7.Value [Int]\nEXEC n7.Then -> n8.Execute\nDATA n7.Value -> n8.InString [String]", "source": "lesson:lesson_06:L06_04", "category": "whileloop_basic"}
{"instruction": "Create a Blueprint that loops 0 to 19. For each index check if even using modulo. If even print the index.", "output": "BLUEPRINT: BP_EvenPrinter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=19]\nNODE n3: Modulo [B=2]\nNODE n4: EqualEqual [B=0]\nNODE n5: Branch\nNODE n6: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n5.Execute\nDATA n2.Index -> n3.A [Int]\nDATA n3.ReturnValue -> n4.A [Int]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA n2.Index -> n6.InString [String]", "source": "lesson:lesson_06:L06_05", "category": "forloop_even"}
{"instruction": "Create a Blueprint with actor array Targets. On pressing Fire, ForEachLoop destroys all targets then prints All Destroyed.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: DestroyActor\nNODE n5: PrintString [InString=\"All Destroyed\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]\nEXEC n3.Completed -> n5.Execute", "source": "lesson:lesson_06:L06_06", "category": "foreach_destroy"}
{"instruction": "Create a Blueprint that on BeginPlay uses two nested ForLoops 0 to 2 to spawn actors in a 3x3 grid with 100 unit spacing.", "output": "BLUEPRINT: BP_GridSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=2]\nNODE n3: ForLoop [FirstIndex=0, LastIndex=2]\nNODE n4: MultiplyFloat [B=100.0]\nNODE n5: MultiplyFloat [B=100.0]\nNODE n6: MakeVector [Z=0]\nNODE n7: SpawnActorFromClass [ActorClass=BP_Tile]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nEXEC n3.LoopBody -> n7.Execute\nDATA n2.Index -> n4.A [Float]\nDATA n3.Index -> n5.A [Float]\nDATA n4.ReturnValue -> n6.X [Float]\nDATA n5.ReturnValue -> n6.Y [Float]\nDATA n6.ReturnValue -> n7.SpawnTransform [Transform]", "source": "lesson:lesson_06:L06_07", "category": "forloop_grid"}
{"instruction": "Create a Blueprint that on BeginPlay runs ForLoop 1 to 3 printing each index. After the loop waits 2 seconds then prints Done.", "output": "BLUEPRINT: BP_LoopThenWait\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=3]\nNODE n3: PrintString\nNODE n4: Delay [Duration=2.0]\nNODE n5: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_06:L06_08", "category": "forloop_delay_after"}
{"instruction": "Create a Blueprint with actor array AllActors. On BeginPlay loop through all. For each check distance less than 500 and print name of nearby ones.", "output": "BLUEPRINT: BP_NearbyFilter\nPARENT: Actor\nVAR AllActors: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=AllActors]\nNODE n3: ForEachLoop\nNODE n4: GetDistanceTo\nNODE n5: LessThan [B=500.0]\nNODE n6: Branch\nNODE n7: GetDisplayName\nNODE n8: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n6.Execute\nDATA n3.ArrayElement -> n4.OtherActor [Actor]\nDATA n4.ReturnValue -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n8.Execute\nDATA n3.ArrayElement -> n7.Target [Actor]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:lesson_06:L06_09", "category": "foreach_filter"}
{"instruction": "Create a Blueprint that on BeginPlay uses ForLoop from 10 down to 1 printing each number. After loop prints Liftoff.", "output": "BLUEPRINT: BP_Countdown\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=10, LastIndex=1]\nNODE n3: PrintString\nNODE n4: PrintString [InString=\"Liftoff\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute", "source": "lesson:lesson_06:L06_10", "category": "forloop_countdown"}
{"instruction": "Create a Blueprint with actor array Lights. On pressing Toggle loop through all and call ToggleVisibility on each.", "output": "BLUEPRINT: BP_ToggleLights\nPARENT: Actor\nVAR Lights: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Toggle\"]\nNODE n2: VariableGet [VarName=Lights]\nNODE n3: ForEachLoop\nNODE n4: ToggleVisibility\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]", "source": "lesson:lesson_06:L06_11", "category": "foreach_toggle_vis"}
{"instruction": "Create a Blueprint with float Value at 1000. Use WhileLoop to keep halving Value while greater than 1. Print the final value.", "output": "BLUEPRINT: BP_HalveLoop\nPARENT: Actor\nVAR Value: Float = 1000.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Value]\nNODE n4: GreaterThan [B=1.0]\nNODE n5: VariableGet [VarName=Value]\nNODE n6: DivideFloat [B=2.0]\nNODE n7: VariableSet [VarName=Value]\nNODE n8: VariableGet [VarName=Value]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n2.Completed -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:lesson_06:L06_12", "category": "whileloop_halving"}
{"instruction": "Create a Blueprint that on BeginPlay loops 10 times. Each iteration generates random X and Y within 1000 units and spawns an actor there.", "output": "BLUEPRINT: BP_RandomSpawner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: RandomFloat [Min=-1000, Max=1000]\nNODE n4: RandomFloat [Min=-1000, Max=1000]\nNODE n5: MakeVector [Z=0]\nNODE n6: SpawnActorFromClass [ActorClass=BP_Item]\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n6.Execute\nDATA n3.ReturnValue -> n5.X [Float]\nDATA n4.ReturnValue -> n5.Y [Float]\nDATA n5.ReturnValue -> n6.SpawnTransform [Transform]", "source": "lesson:lesson_06:L06_13", "category": "forloop_random_spawn"}
{"instruction": "Create a Blueprint with float array Values and float MaxVal at 0. Loop through Values tracking maximum. After loop print max.", "output": "BLUEPRINT: BP_FindMax\nPARENT: Actor\nVAR Values: Array<Float>\nVAR MaxVal: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Values]\nNODE n3: ForEachLoop\nNODE n4: VariableGet [VarName=MaxVal]\nNODE n5: Max\nNODE n6: VariableSet [VarName=MaxVal]\nNODE n7: VariableGet [VarName=MaxVal]\nNODE n8: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n6.Execute\nDATA n3.ArrayElement -> n5.A [Float]\nDATA n4.Value -> n5.B [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n3.Completed -> n8.Execute\nDATA n7.Value -> n8.InString [String]", "source": "lesson:lesson_06:L06_14", "category": "foreach_max"}
{"instruction": "Create a Blueprint with float Health at 100. Use WhileLoop while Health > 0. Each iteration subtract random 1-20 and print Health.", "output": "BLUEPRINT: BP_DamageLoop\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Health]\nNODE n4: GreaterThan [B=0.0]\nNODE n5: VariableGet [VarName=Health]\nNODE n6: RandomFloat [Min=1, Max=20]\nNODE n7: SubtractFloat\nNODE n8: VariableSet [VarName=Health]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n8.Execute\nDATA n5.Value -> n7.A [Float]\nDATA n6.ReturnValue -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:lesson_06:L06_15", "category": "whileloop_damage"}
{"instruction": "Create a Blueprint with actor array Targets. Loop through finding the closest one. Print the closest actor name.", "output": "BLUEPRINT: BP_FindClosest\nPARENT: Actor\nVAR Targets: Array<Actor>\nVAR ClosestDist: Float = 999999.0\nVAR ClosestActor: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: GetDistanceTo\nNODE n5: VariableGet [VarName=ClosestDist]\nNODE n6: LessThan\nNODE n7: Branch\nNODE n8: VariableSet [VarName=ClosestDist]\nNODE n9: VariableSet [VarName=ClosestActor]\nNODE n10: VariableGet [VarName=ClosestActor]\nNODE n11: GetDisplayName\nNODE n12: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n7.Execute\nDATA n3.ArrayElement -> n4.OtherActor [Actor]\nDATA n4.ReturnValue -> n6.A [Float]\nDATA n5.Value -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nDATA n4.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n3.ArrayElement -> n9.Value [Actor]\nEXEC n3.Completed -> n12.Execute\nDATA n10.Value -> n11.Target [Actor]\nDATA n11.ReturnValue -> n12.InString [String]", "source": "lesson:lesson_06:L06_16", "category": "foreach_closest"}
{"instruction": "Create a Blueprint that on BeginPlay uses Sequence. First output runs ForLoop 0-4 printing each. Second output prints Loop Done.", "output": "BLUEPRINT: BP_SequenceLoop\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: ForLoop [FirstIndex=0, LastIndex=4]\nNODE n4: PrintString\nNODE n5: PrintString [InString=\"Loop Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.Index -> n4.InString [String]\nEXEC n2.Then_1 -> n5.Execute", "source": "lesson:lesson_06:L06_17", "category": "forloop_sequence"}
{"instruction": "Create a Blueprint with string array Messages. On overlap use DoOnce then ForEachLoop to print all messages once.", "output": "BLUEPRINT: BP_OneTimeMessages\nPARENT: Actor\nVAR Messages: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: VariableGet [VarName=Messages]\nNODE n4: ForEachLoop\nNODE n5: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n4.Execute\nDATA n3.Value -> n4.Array [Array]\nEXEC n4.LoopBody -> n5.Execute\nDATA n4.ArrayElement -> n5.InString [String]", "source": "lesson:lesson_06:L06_18", "category": "foreach_doonce"}
{"instruction": "Create a Blueprint with actor array Enemies. On BeginPlay loop through enemies and print each one's display name.", "output": "BLUEPRINT: BP_ListEnemies\nPARENT: Actor\nVAR Enemies: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Enemies]\nNODE n3: ForEachLoop\nNODE n4: GetDisplayName\nNODE n5: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_06:L06_19", "category": "forloop_health_bars"}
{"instruction": "Create a Blueprint that on BeginPlay runs ForLoop 0 to 9. Prints the index. After completion prints Total: 10 and destroys self.", "output": "BLUEPRINT: BP_CountAndDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=0, LastIndex=9]\nNODE n3: PrintString\nNODE n4: PrintString [InString=\"Total: 10\"]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\nDATA n2.Index -> n3.InString [String]\nEXEC n2.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute", "source": "lesson:lesson_06:L06_20", "category": "forloop_complete"}
{"instruction": "Create a Blueprint with a string variable PlayerName set to Hero. On BeginPlay print Welcome followed by the player name.", "output": "BLUEPRINT: BP_WelcomeName\nPARENT: Actor\nVAR PlayerName: String = \"Hero\"\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=PlayerName]\nNODE n3: Concatenate [A=\"Welcome \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_01", "category": "string_concat"}
{"instruction": "Create a Blueprint with an integer variable Score at 0. On overlap add 10 to Score and print Score: followed by the value.", "output": "BLUEPRINT: BP_ScoreDisplay\nPARENT: Actor\nVAR Score: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=Score]\nNODE n3: AddInt [B=10]\nNODE n4: VariableSet [VarName=Score]\nNODE n5: Concatenate [A=\"Score: \"]\nNODE n6: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_02", "category": "string_score"}
{"instruction": "Create a Blueprint with float Health at 100. On AnyDamage subtract damage, print Health: followed by the new value.", "output": "BLUEPRINT: BP_HealthDisplay\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: VariableSet [VarName=Health]\nNODE n5: Concatenate [A=\"Health: \"]\nNODE n6: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_03", "category": "string_health"}
{"instruction": "Create a Blueprint that on Tick gets actor location, breaks it into components, and prints the vector as a string.", "output": "BLUEPRINT: BP_LocationDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.InString [String]", "source": "lesson:lesson_07:L07_04", "category": "debug_location"}
{"instruction": "Create a Blueprint that on overlap gets the display name of the overlapping actor and prints Overlapped by: followed by the name.", "output": "BLUEPRINT: BP_NameOverlap\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetDisplayName\nNODE n3: Concatenate [A=\"Overlapped by: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_05", "category": "string_overlap_name"}
{"instruction": "Create a Blueprint that on Tick gets distance to the player pawn and prints Distance: followed by the value.", "output": "BLUEPRINT: BP_DistDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: Concatenate [A=\"Distance: \"]\nNODE n5: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_07:L07_06", "category": "debug_distance"}
{"instruction": "Create a Blueprint with integer Count at 0. On overlap increment Count and print Overlap Count: followed by the number.", "output": "BLUEPRINT: BP_OverlapCounter\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=Count]\nNODE n3: AddInt [B=1]\nNODE n4: VariableSet [VarName=Count]\nNODE n5: Concatenate [A=\"Overlap Count: \"]\nNODE n6: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_07", "category": "string_counter"}
{"instruction": "Create a Blueprint that on Tick calculates FPS by dividing 1 by DeltaSeconds and prints FPS: followed by the value.", "output": "BLUEPRINT: BP_FPSCounter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: DivideFloat [A=1.0]\nNODE n3: Concatenate [A=\"FPS: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n1.DeltaSeconds -> n2.B [Float]\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_08", "category": "debug_fps"}
{"instruction": "Create a Blueprint that starts a 3-second timer on BeginPlay. Print Timer Started. When it fires print Timer Fired at: followed by game time.", "output": "BLUEPRINT: BP_TimerLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=3.0, Looping=false]\nNODE n3: PrintString [InString=\"Timer Started\"]\nNODE n4: Event_Custom [EventName=OnTimer]\nNODE n5: GetGameTimeInSeconds\nNODE n6: Concatenate [A=\"Timer Fired at: \"]\nNODE n7: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n4.Then -> n7.Execute\nDATA n5.ReturnValue -> n6.B [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_07:L07_09", "category": "string_timer_log"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If success print Player: followed by display name. If fail print Not a player.", "output": "BLUEPRINT: BP_CastLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetDisplayName\nNODE n4: Concatenate [A=\"Player: \"]\nNODE n5: PrintString\nNODE n6: PrintString [InString=\"Not a player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n5.Execute\nDATA n2.AsCharacter -> n3.Target [Actor]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]\nEXEC n2.CastFailed -> n6.Execute", "source": "lesson:lesson_07:L07_10", "category": "string_cast_result"}
{"instruction": "Create a Blueprint with string Name set to Player and int Level set to 1. On BeginPlay print the name followed by Level: and the number.", "output": "BLUEPRINT: BP_PlayerInfo\nPARENT: Actor\nVAR Name: String = \"Player\"\nVAR Level: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Name]\nNODE n3: VariableGet [VarName=Level]\nNODE n4: Concatenate [B=\" Level: \"]\nNODE n5: Concatenate\nNODE n6: PrintString\nEXEC n1.Then -> n6.Execute\nDATA n2.Value -> n4.A [String]\nDATA n3.Value -> n5.B [String]\nDATA n4.ReturnValue -> n5.A [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_11", "category": "string_multi_var"}
{"instruction": "Create a Blueprint that on pressing Fire spawns an actor, gets its location, and prints Spawned at: followed by the location.", "output": "BLUEPRINT: BP_SpawnLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n4: GetActorLocation\nNODE n5: Concatenate [A=\"Spawned at: \"]\nNODE n6: PrintString\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]\nEXEC n3.Then -> n6.Execute\nDATA n3.ReturnValue -> n4.Target [Actor]\nDATA n4.ReturnValue -> n5.B [String]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_07:L07_12", "category": "debug_spawn_log"}
{"instruction": "Create a Blueprint that on BeginPlay runs a ForLoop 1 to 5. Each iteration prints Item followed by the index number.", "output": "BLUEPRINT: BP_IndexPrinter\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: ForLoop [FirstIndex=1, LastIndex=5]\nNODE n3: Concatenate [A=\"Item \"]\nNODE n4: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n4.Execute\nDATA n2.Index -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_13", "category": "string_loop_index"}
{"instruction": "Create a Blueprint with bool IsReady. On BeginPlay branch on IsReady. True path prints Path: Ready. False path prints Path: Not Ready.", "output": "BLUEPRINT: BP_PathDebug\nPARENT: Actor\nVAR IsReady: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsReady]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Path: Ready\"]\nNODE n5: PrintString [InString=\"Path: Not Ready\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_07:L07_14", "category": "debug_branch_path"}
{"instruction": "Create a Blueprint that on AnyDamage prints Took X damage, Health: Y where X is damage amount and Y is remaining health.", "output": "BLUEPRINT: BP_DamageLog\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: VariableSet [VarName=Health]\nNODE n5: Concatenate [A=\"Took \"]\nNODE n6: Concatenate [B=\" damage\"]\nNODE n7: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n7.Execute\nDATA n1.Damage -> n5.B [String]\nDATA n5.ReturnValue -> n6.A [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_07:L07_15", "category": "string_damage_log"}
{"instruction": "Create a Blueprint with an actor array Items. On BeginPlay print Item Count: followed by the array length.", "output": "BLUEPRINT: BP_ArrayCount\nPARENT: Actor\nVAR Items: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Items]\nNODE n3: ArrayLength\nNODE n4: Concatenate [A=\"Item Count: \"]\nNODE n5: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.Array [Array]\nDATA n3.ReturnValue -> n4.B [String]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_07:L07_16", "category": "debug_array_count"}
{"instruction": "Create a Blueprint that on BeginPlay gets game time in seconds and prints Game started at: followed by the time.", "output": "BLUEPRINT: BP_TimeDisplay\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetGameTimeInSeconds\nNODE n3: Concatenate [A=\"Game started at: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_17", "category": "string_time_display"}
{"instruction": "Create a Blueprint with a Gate. When the gate opens print Gate: Open. When it closes print Gate: Closed. On Tick enter the gate, exit prints Active.", "output": "BLUEPRINT: BP_GateDebug\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: PrintString [InString=\"Gate: Open\"]\nNODE n4: Event_InputAction [ActionName=\"Close\"]\nNODE n5: PrintString [InString=\"Gate: Closed\"]\nNODE n6: Event_Tick\nNODE n7: PrintString [InString=\"Active\"]\nEXEC n1.Pressed -> n2.Open\nEXEC n1.Pressed -> n3.Execute\nEXEC n4.Pressed -> n2.Close\nEXEC n4.Pressed -> n5.Execute\nEXEC n6.Then -> n2.Enter\nEXEC n2.Exit -> n7.Execute", "source": "lesson:lesson_07:L07_18", "category": "debug_gate_status"}
{"instruction": "Create a Blueprint that on BeginPlay generates a random integer 1-100 and prints Random number: followed by the value.", "output": "BLUEPRINT: BP_RandomLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: RandomInteger [Min=1, Max=100]\nNODE n3: Concatenate [A=\"Random number: \"]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_07:L07_19", "category": "string_random_log"}
{"instruction": "Create a Blueprint that on BeginPlay prints BEGIN at: with game time. On EndPlay prints END at: with game time.", "output": "BLUEPRINT: BP_LifecycleLog\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetGameTimeInSeconds\nNODE n3: Concatenate [A=\"BEGIN at: \"]\nNODE n4: PrintString\nNODE n5: Event_EndPlay\nNODE n6: GetGameTimeInSeconds\nNODE n7: Concatenate [A=\"END at: \"]\nNODE n8: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.B [String]\nDATA n3.ReturnValue -> n4.InString [String]\nEXEC n5.Then -> n8.Execute\nDATA n6.ReturnValue -> n7.B [String]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:lesson_07:L07_20", "category": "debug_lifecycle"}
{"instruction": "Create a Blueprint that on BeginPlay creates a widget of class WBP_HUD and adds it to the viewport.", "output": "BLUEPRINT: BP_ShowHUD\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]", "source": "lesson:lesson_08:L08_01", "category": "ui_create_basic"}
{"instruction": "Create a Blueprint with a widget variable HUDWidget. On pressing Escape, remove it from the viewport.", "output": "BLUEPRINT: BP_RemoveHUD\nPARENT: Actor\nVAR HUDWidget: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Escape\"]\nNODE n2: VariableGet [VarName=HUDWidget]\nNODE n3: RemoveFromParent\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Target [Widget]", "source": "lesson:lesson_08:L08_02", "category": "ui_remove"}
{"instruction": "Create a Blueprint with a widget variable MenuWidget and bool MenuOpen. On pressing Menu, toggle: if open remove widget and set false, if closed create widget and set true.", "output": "BLUEPRINT: BP_ToggleMenu\nPARENT: Actor\nVAR MenuWidget: Widget = None\nVAR MenuOpen: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Menu\"]\nNODE n2: VariableGet [VarName=MenuOpen]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=MenuWidget]\nNODE n5: RemoveFromParent\nNODE n6: VariableSet [VarName=MenuOpen]\nNODE n7: CreateWidget [WidgetClass=WBP_Menu]\nNODE n8: AddToViewport\nNODE n9: VariableSet [VarName=MenuWidget]\nNODE n10: VariableSet [VarName=MenuOpen]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute\nDATA false -> n6.Value [Bool]\nEXEC n3.False -> n7.Execute\nEXEC n7.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Target [Widget]\nEXEC n8.Then -> n9.Execute\nDATA n7.ReturnValue -> n9.Value [Widget]\nEXEC n9.Then -> n10.Execute\nDATA true -> n10.Value [Bool]", "source": "lesson:lesson_08:L08_03", "category": "ui_toggle"}
{"instruction": "Create a Blueprint that on BeginPlay waits 3 seconds, then creates a widget WBP_Welcome and adds it to viewport. After 5 more seconds, remove it.", "output": "BLUEPRINT: BP_TimedWidget\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: CreateWidget [WidgetClass=WBP_Welcome]\nNODE n4: AddToViewport\nNODE n5: Delay [Duration=5.0]\nNODE n6: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute\nDATA n3.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_04", "category": "ui_delayed"}
{"instruction": "Create a Blueprint that on overlap creates a widget WBP_Tooltip and adds to viewport. On end overlap, remove it.", "output": "BLUEPRINT: BP_OverlapTooltip\nPARENT: Actor\nVAR TooltipWidget: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CreateWidget [WidgetClass=WBP_Tooltip]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=TooltipWidget]\nNODE n5: Event_ActorEndOverlap\nNODE n6: VariableGet [VarName=TooltipWidget]\nNODE n7: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n7.Execute\nDATA n6.Value -> n7.Target [Widget]", "source": "lesson:lesson_08:L08_05", "category": "ui_overlap_show"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If the cast succeeds, create widget WBP_PlayerHUD and add to viewport.", "output": "BLUEPRINT: BP_PlayerHUD\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: CreateWidget [WidgetClass=WBP_PlayerHUD]\nNODE n4: AddToViewport\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]", "source": "lesson:lesson_08:L08_06", "category": "ui_with_cast"}
{"instruction": "Create a Blueprint that on overlap uses DoOnce, creates widget WBP_Tutorial and adds to viewport.", "output": "BLUEPRINT: BP_TutorialPopup\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: CreateWidget [WidgetClass=WBP_Tutorial]\nNODE n4: AddToViewport\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]", "source": "lesson:lesson_08:L08_07", "category": "ui_doonce"}
{"instruction": "Create a Blueprint with bool ShowHUD. On BeginPlay, if ShowHUD is true create WBP_HUD and add to viewport. If false, print HUD Disabled.", "output": "BLUEPRINT: BP_ConditionalHUD\nPARENT: Actor\nVAR ShowHUD: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=ShowHUD]\nNODE n3: Branch\nNODE n4: CreateWidget [WidgetClass=WBP_HUD]\nNODE n5: AddToViewport\nNODE n6: PrintString [InString=\"HUD Disabled\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n3.False -> n6.Execute", "source": "lesson:lesson_08:L08_08", "category": "ui_branch_show"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence. First output creates WBP_Background and adds to viewport. Second output creates WBP_Foreground and adds to viewport.", "output": "BLUEPRINT: BP_LayeredUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: CreateWidget [WidgetClass=WBP_Background]\nNODE n4: AddToViewport\nNODE n5: CreateWidget [WidgetClass=WBP_Foreground]\nNODE n6: AddToViewport\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n2.Then_1 -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_09", "category": "ui_sequence_multi"}
{"instruction": "Create a Blueprint with widget variable CurrentUI. On pressing Close, check if CurrentUI is valid. If valid, remove from parent and set to None.", "output": "BLUEPRINT: BP_SafeRemoveUI\nPARENT: Actor\nVAR CurrentUI: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Close\"]\nNODE n2: VariableGet [VarName=CurrentUI]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: RemoveFromParent\nNODE n6: VariableSet [VarName=CurrentUI]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA n2.Value -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute\nDATA None -> n6.Value [Widget]", "source": "lesson:lesson_08:L08_10", "category": "ui_valid_remove"}
{"instruction": "Create a Blueprint that on BeginPlay sets a 5-second timer. When it fires, create WBP_Alert and add to viewport. Print Alert Shown.", "output": "BLUEPRINT: BP_TimedAlert\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"ShowAlert\", Time=5.0, Looping=false]\nNODE n3: Event_Custom [EventName=ShowAlert]\nNODE n4: CreateWidget [WidgetClass=WBP_Alert]\nNODE n5: AddToViewport\nNODE n6: PrintString [InString=\"Alert Shown\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_08:L08_11", "category": "ui_timer_show"}
{"instruction": "Create a Blueprint with two widget variables ScreenA and ScreenB. On pressing Swap, use FlipFlop. A shows ScreenA and hides ScreenB. B does the opposite.", "output": "BLUEPRINT: BP_SwapScreens\nPARENT: Actor\nVAR ScreenA: Widget = None\nVAR ScreenB: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Swap\"]\nNODE n2: FlipFlop\nNODE n3: VariableGet [VarName=ScreenA]\nNODE n4: AddToViewport\nNODE n5: VariableGet [VarName=ScreenB]\nNODE n6: RemoveFromParent\nNODE n7: VariableGet [VarName=ScreenB]\nNODE n8: AddToViewport\nNODE n9: VariableGet [VarName=ScreenA]\nNODE n10: RemoveFromParent\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n4.Execute\nDATA n3.Value -> n4.Target [Widget]\nEXEC n4.Then -> n6.Execute\nDATA n5.Value -> n6.Target [Widget]\nEXEC n2.B -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]\nEXEC n8.Then -> n10.Execute\nDATA n9.Value -> n10.Target [Widget]", "source": "lesson:lesson_08:L08_12", "category": "ui_flipflop_swap"}
{"instruction": "Create a Blueprint that on Tick checks distance to player. If less than 300, create and show WBP_Interact widget using DoOnce.", "output": "BLUEPRINT: BP_ProximityUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=300.0]\nNODE n5: Branch\nNODE n6: DoOnce\nNODE n7: CreateWidget [WidgetClass=WBP_Interact]\nNODE n8: AddToViewport\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.Completed -> n7.Execute\nEXEC n7.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Target [Widget]", "source": "lesson:lesson_08:L08_13", "category": "ui_distance_trigger"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_HUD, stores it in variable MyHUD, and adds to viewport. Print HUD Ready.", "output": "BLUEPRINT: BP_StoredHUD\nPARENT: Actor\nVAR MyHUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: VariableSet [VarName=MyHUD]\nNODE n4: AddToViewport\nNODE n5: PrintString [InString=\"HUD Ready\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute", "source": "lesson:lesson_08:L08_14", "category": "ui_create_store"}
{"instruction": "Create a Blueprint that creates WBP_HUD on BeginPlay. On EndPlay, check if widget is valid and remove it.", "output": "BLUEPRINT: BP_CleanupUI\nPARENT: Actor\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_EndPlay\nNODE n6: VariableGet [VarName=HUD]\nNODE n7: IsValid\nNODE n8: Branch\nNODE n9: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.Input [Object]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA n6.Value -> n9.Target [Widget]", "source": "lesson:lesson_08:L08_15", "category": "ui_endplay_cleanup"}
{"instruction": "Create a Blueprint with a Gate. Opening the gate creates and shows WBP_Panel. Closing the gate removes it.", "output": "BLUEPRINT: BP_GatedUI\nPARENT: Actor\nVAR Panel: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Panel]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Panel]\nNODE n6: Event_InputAction [ActionName=\"Close\"]\nNODE n7: VariableGet [VarName=Panel]\nNODE n8: RemoveFromParent\nEXEC n1.Pressed -> n2.Open\nEXEC n2.Exit -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n6.Pressed -> n2.Close\nEXEC n6.Pressed -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]", "source": "lesson:lesson_08:L08_16", "category": "ui_gate_controlled"}
{"instruction": "Create a Blueprint with a string array MenuItems. On BeginPlay, loop through MenuItems and print each item name. After loop, create WBP_Menu and add to viewport.", "output": "BLUEPRINT: BP_DynamicMenu\nPARENT: Actor\nVAR MenuItems: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=MenuItems]\nNODE n3: ForEachLoop\nNODE n4: PrintString\nNODE n5: CreateWidget [WidgetClass=WBP_Menu]\nNODE n6: AddToViewport\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.InString [String]\nEXEC n3.Completed -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]", "source": "lesson:lesson_08:L08_17", "category": "ui_foreach_create"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_Dialog and adds to viewport. On pressing Confirm, remove the dialog and print Confirmed.", "output": "BLUEPRINT: BP_Dialog\nPARENT: Actor\nVAR Dialog: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_Dialog]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=Dialog]\nNODE n5: Event_InputAction [ActionName=\"Confirm\"]\nNODE n6: VariableGet [VarName=Dialog]\nNODE n7: RemoveFromParent\nNODE n8: PrintString [InString=\"Confirmed\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Pressed -> n7.Execute\nDATA n6.Value -> n7.Target [Widget]\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_08:L08_18", "category": "ui_input_close"}
{"instruction": "Create a Blueprint where pressing Next uses MultiGate with 3 outputs. Each output creates a different widget: WBP_Page1, WBP_Page2, WBP_Page3 and adds to viewport.", "output": "BLUEPRINT: BP_PagedUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Next\"]\nNODE n2: MultiGate\nNODE n3: CreateWidget [WidgetClass=WBP_Page1]\nNODE n4: AddToViewport\nNODE n5: CreateWidget [WidgetClass=WBP_Page2]\nNODE n6: AddToViewport\nNODE n7: CreateWidget [WidgetClass=WBP_Page3]\nNODE n8: AddToViewport\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.Out_0 -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n2.Out_1 -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]\nEXEC n2.Out_2 -> n7.Execute\nEXEC n7.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Target [Widget]", "source": "lesson:lesson_08:L08_19", "category": "ui_multigate"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_Loading and adds to viewport. After 3 seconds, remove loading widget, create WBP_MainMenu, and add to viewport. Print Ready.", "output": "BLUEPRINT: BP_LoadingFlow\nPARENT: Actor\nVAR LoadingWidget: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_Loading]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=LoadingWidget]\nNODE n5: Delay [Duration=3.0]\nNODE n6: VariableGet [VarName=LoadingWidget]\nNODE n7: RemoveFromParent\nNODE n8: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n9: AddToViewport\nNODE n10: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n7.Execute\nDATA n6.Value -> n7.Target [Widget]\nEXEC n7.Then -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Target [Widget]\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_08:L08_20", "category": "ui_complete_flow"}
{"instruction": "Create a Blueprint with bool IsAlive and bool HasWeapon. On BeginPlay check IsAlive. If true, check HasWeapon. If has weapon print Armed. If no weapon print Unarmed. If not alive print Dead.", "output": "BLUEPRINT: BP_NestedCheck\nPARENT: Actor\nVAR IsAlive: Bool = true\nVAR HasWeapon: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsAlive]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=HasWeapon]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Armed\"]\nNODE n7: PrintString [InString=\"Unarmed\"]\nNODE n8: PrintString [InString=\"Dead\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute\nEXEC n3.False -> n8.Execute", "source": "lesson:lesson_09:L09_01", "category": "nested_branch_basic"}
{"instruction": "Create a Blueprint with float Health. On BeginPlay if Health > 75 print Healthy. Else if Health > 25 print Wounded. Else print Critical.", "output": "BLUEPRINT: BP_HealthStatus\nPARENT: Actor\nVAR Health: Float = 50.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Health]\nNODE n3: GreaterThan [B=75.0]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Healthy\"]\nNODE n6: GreaterThan [B=25.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Wounded\"]\nNODE n9: PrintString [InString=\"Critical\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n7.Execute\nDATA n2.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute", "source": "lesson:lesson_09:L09_02", "category": "nested_branch_three"}
{"instruction": "Create a Blueprint with integer Level. On BeginPlay use Switch on Int. Case 1 prints Easy. Case 2 prints Medium. Case 3 prints Hard. Default prints Unknown.", "output": "BLUEPRINT: BP_DifficultySwitch\nPARENT: Actor\nVAR Level: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Level]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Easy\"]\nNODE n5: PrintString [InString=\"Medium\"]\nNODE n6: PrintString [InString=\"Hard\"]\nNODE n7: PrintString [InString=\"Unknown\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute\nEXEC n3.Default -> n7.Execute", "source": "lesson:lesson_09:L09_03", "category": "switch_int"}
{"instruction": "Create a Blueprint with string Command. On BeginPlay use Switch on String. If Attack print Attacking. If Defend print Defending. If Heal print Healing. Default print Idle.", "output": "BLUEPRINT: BP_CommandSwitch\nPARENT: Actor\nVAR Command: String = \"Attack\"\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Command]\nNODE n3: SwitchOnString\nNODE n4: PrintString [InString=\"Attacking\"]\nNODE n5: PrintString [InString=\"Defending\"]\nNODE n6: PrintString [InString=\"Healing\"]\nNODE n7: PrintString [InString=\"Idle\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [String]\nEXEC n3.Case_Attack -> n4.Execute\nEXEC n3.Case_Defend -> n5.Execute\nEXEC n3.Case_Heal -> n6.Execute\nEXEC n3.Default -> n7.Execute", "source": "lesson:lesson_09:L09_04", "category": "switch_string"}
{"instruction": "Create a Blueprint with bool HasKey and bool DoorUnlocked. On overlap, if HasKey AND DoorUnlocked print Enter. Else print Blocked.", "output": "BLUEPRINT: BP_DoorCheck\nPARENT: Actor\nVAR HasKey: Bool = true\nVAR DoorUnlocked: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=HasKey]\nNODE n3: VariableGet [VarName=DoorUnlocked]\nNODE n4: BooleanAND\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Enter\"]\nNODE n7: PrintString [InString=\"Blocked\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n4.A [Bool]\nDATA n3.Value -> n4.B [Bool]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_09:L09_05", "category": "branch_and_or"}
{"instruction": "Create a Blueprint with bool IsInvisible. On Tick, if NOT IsInvisible, print Visible.", "output": "BLUEPRINT: BP_VisCheck\nPARENT: Actor\nVAR IsInvisible: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=IsInvisible]\nNODE n3: NOT\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Visible\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Bool]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute", "source": "lesson:lesson_09:L09_06", "category": "branch_not"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If cast succeeds check distance less than 200. If close print Too Close. If far print In Range. If cast fails print Not Player.", "output": "BLUEPRINT: BP_RangeCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Too Close\"]\nNODE n7: PrintString [InString=\"In Range\"]\nNODE n8: PrintString [InString=\"Not Player\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n5.Execute\nDATA n2.AsCharacter -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute\nEXEC n2.CastFailed -> n8.Execute", "source": "lesson:lesson_09:L09_07", "category": "nested_overlap_cast"}
{"instruction": "Create a Blueprint with float PlayerHealth and float EnemyHealth. On BeginPlay if PlayerHealth greater than EnemyHealth print Advantage. Else print Disadvantage.", "output": "BLUEPRINT: BP_HealthCompare\nPARENT: Actor\nVAR PlayerHealth: Float = 80.0\nVAR EnemyHealth: Float = 60.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=PlayerHealth]\nNODE n3: VariableGet [VarName=EnemyHealth]\nNODE n4: GreaterThan\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Advantage\"]\nNODE n7: PrintString [InString=\"Disadvantage\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n4.A [Float]\nDATA n3.Value -> n4.B [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_09:L09_08", "category": "branch_compare_vars"}
{"instruction": "Create a Blueprint with integer WeaponSlot. On pressing Fire, switch on WeaponSlot. Case 1 prints Sword. Case 2 prints Bow. Case 3 prints Staff.", "output": "BLUEPRINT: BP_WeaponSelect\nPARENT: Actor\nVAR WeaponSlot: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=WeaponSlot]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Sword\"]\nNODE n5: PrintString [InString=\"Bow\"]\nNODE n6: PrintString [InString=\"Staff\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute", "source": "lesson:lesson_09:L09_09", "category": "switch_int_action"}
{"instruction": "Create a Blueprint with float Health at 100. Start a looping timer every 2 seconds. Each tick subtract 10. If Health > 50 print OK. Else if Health > 0 print Warning. Else clear timer and print Dead.", "output": "BLUEPRINT: BP_HealthDrain\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Drain\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=Drain]\nNODE n4: VariableGet [VarName=Health]\nNODE n5: SubtractFloat [B=10.0]\nNODE n6: VariableSet [VarName=Health]\nNODE n7: GreaterThan [B=50.0]\nNODE n8: Branch\nNODE n9: PrintString [InString=\"OK\"]\nNODE n10: GreaterThan [B=0.0]\nNODE n11: Branch\nNODE n12: PrintString [InString=\"Warning\"]\nNODE n13: ClearTimerByFunctionName [FunctionName=\"Drain\"]\nNODE n14: PrintString [InString=\"Dead\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nEXEC n8.False -> n11.Execute\nDATA n6.Value -> n10.A [Float]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute\nEXEC n11.False -> n13.Execute\nEXEC n13.Then -> n14.Execute", "source": "lesson:lesson_09:L09_10", "category": "nested_timer_branch"}
{"instruction": "Create a Blueprint with integer Score. On BeginPlay if Score equals 100 print Perfect. Else print Try Again.", "output": "BLUEPRINT: BP_ScoreCheck\nPARENT: Actor\nVAR Score: Int = 100\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Score]\nNODE n3: EqualEqual [B=100]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Perfect\"]\nNODE n6: PrintString [InString=\"Try Again\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_09:L09_11", "category": "branch_equal"}
{"instruction": "Create a Blueprint with bool A, bool B, bool C. On BeginPlay check A. If true check B. If B true check C. If all three true print All True. Each false branch prints the failing variable name.", "output": "BLUEPRINT: BP_TripleCheck\nPARENT: Actor\nVAR A: Bool = true\nVAR B: Bool = true\nVAR C: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=A]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=B]\nNODE n5: Branch\nNODE n6: VariableGet [VarName=C]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"All True\"]\nNODE n9: PrintString [InString=\"C Failed\"]\nNODE n10: PrintString [InString=\"B Failed\"]\nNODE n11: PrintString [InString=\"A Failed\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n5.Execute\nDATA n4.Value -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n6.Value -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\nEXEC n5.False -> n10.Execute\nEXEC n3.False -> n11.Execute", "source": "lesson:lesson_09:L09_12", "category": "nested_three_vars"}
{"instruction": "Create a Blueprint with integer Mode. On BeginPlay switch on Mode. Case 1 sets a 1-second looping timer. Case 2 sets a 5-second looping timer. The timer prints Tick.", "output": "BLUEPRINT: BP_ModeTimer\nPARENT: Actor\nVAR Mode: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Mode]\nNODE n3: SwitchOnInt\nNODE n4: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=1.0, Looping=true]\nNODE n5: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=5.0, Looping=true]\nNODE n6: Event_Custom [EventName=OnTick]\nNODE n7: PrintString [InString=\"Tick\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_09:L09_13", "category": "switch_with_timer"}
{"instruction": "Create a Blueprint with float Value. On BeginPlay if Value greater than 100, set to 100. If less than 0, set to 0. Print the final value.", "output": "BLUEPRINT: BP_ClampValue\nPARENT: Actor\nVAR Value: Float = 150.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Value]\nNODE n3: GreaterThan [B=100.0]\nNODE n4: Branch\nNODE n5: VariableSet [VarName=Value]\nNODE n6: LessThan [B=0.0]\nNODE n7: Branch\nNODE n8: VariableSet [VarName=Value]\nNODE n9: VariableGet [VarName=Value]\nNODE n10: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nDATA 100.0 -> n5.Value [Float]\nEXEC n5.Then -> n10.Execute\nEXEC n4.False -> n7.Execute\nDATA n2.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nDATA 0.0 -> n8.Value [Float]\nEXEC n8.Then -> n10.Execute\nEXEC n7.False -> n10.Execute\nDATA n9.Value -> n10.InString [String]", "source": "lesson:lesson_09:L09_14", "category": "branch_clamp"}
{"instruction": "Create a Blueprint with bool IsDay and bool HasTorch. On overlap if IsDay OR HasTorch print Can See. Else print Darkness.", "output": "BLUEPRINT: BP_VisionCheck\nPARENT: Actor\nVAR IsDay: Bool = false\nVAR HasTorch: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=IsDay]\nNODE n3: VariableGet [VarName=HasTorch]\nNODE n4: BooleanOR\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Can See\"]\nNODE n7: PrintString [InString=\"Darkness\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n4.A [Bool]\nDATA n3.Value -> n4.B [Bool]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_09:L09_15", "category": "branch_or_pattern"}
{"instruction": "Create a Blueprint with string DamageType and float Armor. On AnyDamage if DamageType equals Fire and Armor less than 50 print Burned. If DamageType equals Fire and armor 50+ print Resisted. If not fire print Hit.", "output": "BLUEPRINT: BP_DamageResponse\nPARENT: Actor\nVAR Armor: Float = 30.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: EqualEqual [B=\"Fire\"]\nNODE n3: Branch\nNODE n4: VariableGet [VarName=Armor]\nNODE n5: LessThan [B=50.0]\nNODE n6: Branch\nNODE n7: PrintString [InString=\"Burned\"]\nNODE n8: PrintString [InString=\"Resisted\"]\nNODE n9: PrintString [InString=\"Hit\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Condition [Bool]\nEXEC n3.True -> n6.Execute\nDATA n4.Value -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n7.Execute\nEXEC n6.False -> n8.Execute\nEXEC n3.False -> n9.Execute", "source": "lesson:lesson_09:L09_16", "category": "nested_damage_type"}
{"instruction": "Create a Blueprint with integer EnemyType. On BeginPlay switch on EnemyType. Case 1 spawns BP_Goblin. Case 2 spawns BP_Skeleton. Case 3 spawns BP_Dragon. All spawn at actor location.", "output": "BLUEPRINT: BP_EnemySpawner\nPARENT: Actor\nVAR EnemyType: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=EnemyType]\nNODE n3: SwitchOnInt\nNODE n4: GetActorLocation\nNODE n5: SpawnActorFromClass [ActorClass=BP_Goblin]\nNODE n6: SpawnActorFromClass [ActorClass=BP_Skeleton]\nNODE n7: SpawnActorFromClass [ActorClass=BP_Dragon]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n5.Execute\nEXEC n3.Case_2 -> n6.Execute\nEXEC n3.Case_3 -> n7.Execute\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]\nDATA n4.ReturnValue -> n6.SpawnTransform [Transform]\nDATA n4.ReturnValue -> n7.SpawnTransform [Transform]", "source": "lesson:lesson_09:L09_17", "category": "switch_spawn"}
{"instruction": "Create a Blueprint with float Temperature. On BeginPlay if Temperature less than 0 print Freezing. If between 0 and 30 print Normal. If above 30 print Hot.", "output": "BLUEPRINT: BP_TempCheck\nPARENT: Actor\nVAR Temperature: Float = 20.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Temperature]\nNODE n3: LessThan [B=0.0]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Freezing\"]\nNODE n6: GreaterThan [B=30.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Hot\"]\nNODE n9: PrintString [InString=\"Normal\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n7.Execute\nDATA n2.Value -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute", "source": "lesson:lesson_09:L09_18", "category": "branch_range_check"}
{"instruction": "Create a Blueprint with actor variable Target. On Tick check if Target is valid. If valid check distance less than 500. If close print Tracking. If far print Searching. If invalid print No Target.", "output": "BLUEPRINT: BP_TargetStatus\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=500.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Tracking\"]\nNODE n9: PrintString [InString=\"Searching\"]\nNODE n10: PrintString [InString=\"No Target\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.Value -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\nEXEC n4.False -> n10.Execute", "source": "lesson:lesson_09:L09_19", "category": "nested_valid_branch"}
{"instruction": "Create a Blueprint with integer Screen. On pressing Menu switch on Screen. Case 0 creates WBP_MainMenu. Case 1 creates WBP_Inventory. Case 2 creates WBP_Map. Add each to viewport.", "output": "BLUEPRINT: BP_ScreenSwitch\nPARENT: Actor\nVAR Screen: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Menu\"]\nNODE n2: VariableGet [VarName=Screen]\nNODE n3: SwitchOnInt\nNODE n4: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n5: AddToViewport\nNODE n6: CreateWidget [WidgetClass=WBP_Inventory]\nNODE n7: AddToViewport\nNODE n8: CreateWidget [WidgetClass=WBP_Map]\nNODE n9: AddToViewport\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_0 -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n3.Case_1 -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Target [Widget]\nEXEC n3.Case_2 -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Target [Widget]", "source": "lesson:lesson_09:L09_20", "category": "switch_with_ui"}
{"instruction": "Create a Blueprint for a health pickup. On overlap cast to Character. If cast succeeds add 25 to a Health variable, play a sound, and destroy the actor.", "output": "BLUEPRINT: BP_HealthPickup\nPARENT: Actor\nVAR Health: Float = 25.0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableGet [VarName=Health]\nNODE n4: PlaySoundAtLocation [Sound=PickupSound]\nNODE n5: GetActorLocation\nNODE n6: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n5.ReturnValue -> n4.Location [Vector]\nEXEC n4.Then -> n6.Execute", "source": "lesson:lesson_10:L10_01", "category": "pickup_full"}
{"instruction": "Create a Blueprint for a trap. On overlap enable physics on the overlapping actor, add downward impulse of 5000, wait 2 seconds, then destroy self.", "output": "BLUEPRINT: BP_TrapFloor\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: AddImpulse [Impulse=(X=0,Y=0,Z=-5000)]\nNODE n4: Delay [Duration=2.0]\nNODE n5: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nEXEC n2.Then -> n3.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute", "source": "lesson:lesson_10:L10_02", "category": "trap_floor"}
{"instruction": "Create a Blueprint for an interactive door. On pressing Interact check distance to player. If less than 200 use FlipFlop. A path rotates door 90 degrees and prints Open. B path rotates back and prints Closed.", "output": "BLUEPRINT: BP_InteractiveDoor\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: FlipFlop\nNODE n7: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=90,Roll=0)]\nNODE n8: PrintString [InString=\"Open\"]\nNODE n9: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=-90,Roll=0)]\nNODE n10: PrintString [InString=\"Closed\"]\nEXEC n1.Pressed -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.A -> n7.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n6.B -> n9.Execute\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_10:L10_03", "category": "door_interact"}
{"instruction": "Create a Blueprint that spawns enemies in waves. On BeginPlay set a looping timer every 5 seconds. Each tick increment a WaveCount variable, spawn BP_Enemy at actor location, and print the wave number. After 5 waves clear the timer.", "output": "BLUEPRINT: BP_WaveSpawner\nPARENT: Actor\nVAR WaveCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnWave\", Time=5.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnWave]\nNODE n4: VariableGet [VarName=WaveCount]\nNODE n5: AddInt [B=1]\nNODE n6: VariableSet [VarName=WaveCount]\nNODE n7: GetActorLocation\nNODE n8: SpawnActorFromClass [ActorClass=BP_Enemy]\nNODE n9: PrintString\nNODE n10: GreaterThan [B=4]\nNODE n11: Branch\nNODE n12: ClearTimerByFunctionName [FunctionName=\"SpawnWave\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Value [Int]\nEXEC n6.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.SpawnTransform [Transform]\nEXEC n8.Then -> n9.Execute\nDATA n6.Value -> n9.InString [String]\nEXEC n9.Then -> n11.Execute\nDATA n6.Value -> n10.A [Int]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute", "source": "lesson:lesson_10:L10_04", "category": "spawner_waves"}
{"instruction": "Create a Blueprint for a checkpoint. On overlap cast to Character. If success, use DoOnce, save the actor location to a variable SavedLocation, play a sound, and print Checkpoint Saved.", "output": "BLUEPRINT: BP_Checkpoint\nPARENT: Actor\nVAR SavedLocation: Vector\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: DoOnce\nNODE n4: GetActorLocation\nNODE n5: VariableSet [VarName=SavedLocation]\nNODE n6: PlaySoundAtLocation [Sound=CheckpointSound]\nNODE n7: PrintString [InString=\"Checkpoint Saved\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n3.Completed -> n5.Execute\nDATA n4.ReturnValue -> n5.Value [Vector]\nEXEC n5.Then -> n6.Execute\nDATA n4.ReturnValue -> n6.Location [Vector]\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_05", "category": "checkpoint"}
{"instruction": "Create a Blueprint for a damage zone. On overlap start a looping timer every 1 second. Each tick subtract 10 from Health variable and print the health. On end overlap clear the timer.", "output": "BLUEPRINT: BP_DamageZone\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: SetTimerByFunctionName [FunctionName=\"DealDamage\", Time=1.0, Looping=true]\nNODE n3: Event_ActorEndOverlap\nNODE n4: ClearTimerByFunctionName [FunctionName=\"DealDamage\"]\nNODE n5: Event_Custom [EventName=DealDamage]\nNODE n6: VariableGet [VarName=Health]\nNODE n7: SubtractFloat [B=10.0]\nNODE n8: VariableSet [VarName=Health]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:lesson_10:L10_06", "category": "damage_zone"}
{"instruction": "Create a Blueprint for a collectible coin. On overlap cast to Character. If success, increment a CoinCount variable, play sound at location, print the count, and destroy self.", "output": "BLUEPRINT: BP_Coin\nPARENT: Actor\nVAR CoinCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableGet [VarName=CoinCount]\nNODE n4: AddInt [B=1]\nNODE n5: VariableSet [VarName=CoinCount]\nNODE n6: GetActorLocation\nNODE n7: PlaySoundAtLocation [Sound=CoinSound]\nNODE n8: PrintString\nNODE n9: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n5.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n4.ReturnValue -> n5.Value [Int]\nEXEC n5.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Location [Vector]\nEXEC n7.Then -> n8.Execute\nDATA n5.Value -> n8.InString [String]\nEXEC n8.Then -> n9.Execute", "source": "lesson:lesson_10:L10_07", "category": "collectible_counter"}
{"instruction": "Create a Blueprint for a disappearing platform. On BeginPlay use a Sequence. First output makes it visible. Second output waits 3 seconds, hides it, waits 2 seconds, shows it again, looping with a timer.", "output": "BLUEPRINT: BP_BlinkPlatform\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetActorHiddenInGame [NewHidden=false]\nNODE n3: SetTimerByFunctionName [FunctionName=\"Blink\", Time=5.0, Looping=true]\nNODE n4: Event_Custom [EventName=Blink]\nNODE n5: SetActorHiddenInGame [NewHidden=true]\nNODE n6: Delay [Duration=2.0]\nNODE n7: SetActorHiddenInGame [NewHidden=false]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Then -> n6.Execute\nEXEC n6.Completed -> n7.Execute", "source": "lesson:lesson_10:L10_08", "category": "timed_platform"}
{"instruction": "Create a Blueprint for a simple enemy. On Tick get distance to player. If less than 500 print Alert and move toward player using Lerp. If more than 500 print Patrolling.", "output": "BLUEPRINT: BP_SimpleEnemy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=500.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Alert\"]\nNODE n7: GetActorLocation\nNODE n8: Lerp [Alpha=0.02]\nNODE n9: SetActorLocation\nNODE n10: PrintString [InString=\"Patrolling\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.Then -> n9.Execute\nDATA n7.ReturnValue -> n8.A [Vector]\nDATA n8.ReturnValue -> n9.NewLocation [Vector]\nEXEC n5.False -> n10.Execute", "source": "lesson:lesson_10:L10_09", "category": "enemy_proximity"}
{"instruction": "Create a Blueprint for a speed power-up. On overlap cast to Character. If success, set variable SpeedBoost to true, wait 5 seconds, set SpeedBoost to false, print Boost Expired, and destroy self.", "output": "BLUEPRINT: BP_SpeedBoost\nPARENT: Actor\nVAR SpeedBoost: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableSet [VarName=SpeedBoost]\nNODE n4: Delay [Duration=5.0]\nNODE n5: VariableSet [VarName=SpeedBoost]\nNODE n6: PrintString [InString=\"Boost Expired\"]\nNODE n7: DestroyActor\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nDATA true -> n3.Value [Bool]\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nDATA false -> n5.Value [Bool]\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_10", "category": "power_up"}
{"instruction": "Create a Blueprint with integer PickupType. On overlap switch on PickupType. Case 1 adds 25 health. Case 2 adds 50 health. Case 3 adds 10 to armor. All cases play a sound and destroy self.", "output": "BLUEPRINT: BP_MultiPickup\nPARENT: Actor\nVAR PickupType: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=PickupType]\nNODE n3: SwitchOnInt\nNODE n4: PrintString [InString=\"Health +25\"]\nNODE n5: PrintString [InString=\"Health +50\"]\nNODE n6: PrintString [InString=\"Armor +10\"]\nNODE n7: GetActorLocation\nNODE n8: PlaySoundAtLocation [Sound=PickupSound]\nNODE n9: DestroyActor\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n3.Case_2 -> n5.Execute\nEXEC n3.Case_3 -> n6.Execute\nEXEC n4.Then -> n8.Execute\nEXEC n5.Then -> n8.Execute\nEXEC n6.Then -> n8.Execute\nDATA n7.ReturnValue -> n8.Location [Vector]\nEXEC n8.Then -> n9.Execute", "source": "lesson:lesson_10:L10_11", "category": "multi_pickup"}
{"instruction": "Create a Blueprint for a turret. On BeginPlay set a looping timer every 2 seconds. Each tick get distance to player. If less than 1000, spawn BP_Projectile at actor location and print Firing.", "output": "BLUEPRINT: BP_Turret\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"TurretTick\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=TurretTick]\nNODE n4: GetPlayerPawn\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=1000.0]\nNODE n7: Branch\nNODE n8: GetActorLocation\nNODE n9: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n10: PrintString [InString=\"Firing\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n7.Execute\nDATA n4.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n9.Execute\nDATA n8.ReturnValue -> n9.SpawnTransform [Transform]\nEXEC n9.Then -> n10.Execute", "source": "lesson:lesson_10:L10_12", "category": "turret_basic"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_HealthBar and adds to viewport. On AnyDamage subtract damage from Health variable. If Health less than 0 remove widget and destroy actor.", "output": "BLUEPRINT: BP_HealthHUD\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR HealthBar: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HealthBar]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HealthBar]\nNODE n5: Event_AnyDamage\nNODE n6: VariableGet [VarName=Health]\nNODE n7: SubtractFloat\nNODE n8: VariableSet [VarName=Health]\nNODE n9: LessThan [B=0.0]\nNODE n10: Branch\nNODE n11: VariableGet [VarName=HealthBar]\nNODE n12: RemoveFromParent\nNODE n13: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n5.Damage -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n10.Execute\nDATA n8.Value -> n9.A [Float]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n12.Execute\nDATA n11.Value -> n12.Target [Widget]\nEXEC n12.Then -> n13.Execute", "source": "lesson:lesson_10:L10_13", "category": "hud_health"}
{"instruction": "Create a Blueprint for a projectile. On BeginPlay enable physics, add forward impulse of 3000, set a 5-second self-destruct timer. On Hit print Impact and destroy self.", "output": "BLUEPRINT: BP_Projectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetSimulatePhysics [Simulate=true]\nNODE n3: GetActorForwardVector\nNODE n4: MultiplyFloat [B=3000.0]\nNODE n5: AddImpulse\nNODE n6: SetTimerByFunctionName [FunctionName=\"SelfDestruct\", Time=5.0, Looping=false]\nNODE n7: Event_Custom [EventName=SelfDestruct]\nNODE n8: DestroyActor\nNODE n9: Event_Hit\nNODE n10: PrintString [InString=\"Impact\"]\nNODE n11: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n5.Execute\nDATA n3.ReturnValue -> n4.A [Vector]\nDATA n4.ReturnValue -> n5.Impulse [Vector]\nEXEC n5.Then -> n6.Execute\nEXEC n7.Then -> n8.Execute\nEXEC n9.Then -> n10.Execute\nEXEC n10.Then -> n11.Execute", "source": "lesson:lesson_10:L10_14", "category": "projectile_full"}
{"instruction": "Create a Blueprint for a pressure plate. On overlap open a Gate. The gate exit activates a looping timer that prints Active every 1 second. On end overlap close the gate and clear the timer.", "output": "BLUEPRINT: BP_PressurePlate\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"Activate\", Time=1.0, Looping=true]\nNODE n4: Event_Custom [EventName=Activate]\nNODE n5: PrintString [InString=\"Active\"]\nNODE n6: Event_ActorEndOverlap\nNODE n7: ClearTimerByFunctionName [FunctionName=\"Activate\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n6.Then -> n2.Close\nEXEC n6.Then -> n7.Execute", "source": "lesson:lesson_10:L10_15", "category": "pressure_plate"}
{"instruction": "Create a Blueprint with vector SpawnPoint. On BeginPlay save actor location to SpawnPoint. When Health reaches 0, reset Health to 100, teleport to SpawnPoint, and print Respawned.", "output": "BLUEPRINT: BP_Respawn\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR SpawnPoint: Vector\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: VariableSet [VarName=SpawnPoint]\nNODE n4: Event_AnyDamage\nNODE n5: VariableGet [VarName=Health]\nNODE n6: SubtractFloat\nNODE n7: VariableSet [VarName=Health]\nNODE n8: LessThan [B=1.0]\nNODE n9: Branch\nNODE n10: VariableSet [VarName=Health]\nNODE n11: VariableGet [VarName=SpawnPoint]\nNODE n12: SetActorLocation\nNODE n13: PrintString [InString=\"Respawned\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Vector]\nEXEC n4.Then -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n4.Damage -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute\nDATA 100.0 -> n10.Value [Float]\nEXEC n10.Then -> n12.Execute\nDATA n11.Value -> n12.NewLocation [Vector]\nEXEC n12.Then -> n13.Execute", "source": "lesson:lesson_10:L10_16", "category": "respawn_system"}
{"instruction": "Create a Blueprint for a platform that moves between two points. Use a float variable Alpha going from 0 to 1 on Tick. Lerp between PointA and PointB using Alpha. When Alpha reaches 1, reverse direction.", "output": "BLUEPRINT: BP_MovingPlatform\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nVAR Direction: Float = 1.0\nVAR Speed: Float = 0.5\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: VariableGet [VarName=Direction]\nNODE n4: VariableGet [VarName=Speed]\nNODE n5: MultiplyFloat\nNODE n6: AddFloat\nNODE n7: VariableSet [VarName=Alpha]\nNODE n8: VariableGet [VarName=PointA]\nNODE n9: VariableGet [VarName=PointB]\nNODE n10: Lerp\nNODE n11: SetActorLocation\nEXEC n1.Then -> n7.Execute\nDATA n1.DeltaSeconds -> n5.A [Float]\nDATA n4.Value -> n5.B [Float]\nDATA n3.Value -> n5.B [Float]\nDATA n2.Value -> n6.A [Float]\nDATA n5.ReturnValue -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n11.Execute\nDATA n8.Value -> n10.A [Vector]\nDATA n9.Value -> n10.B [Vector]\nDATA n7.Value -> n10.Alpha [Float]\nDATA n10.ReturnValue -> n11.NewLocation [Vector]", "source": "lesson:lesson_10:L10_17", "category": "moving_platform"}
{"instruction": "Create a Blueprint that requires 3 overlaps in sequence. Use integer StepCount starting at 0. Each overlap increments StepCount. When StepCount equals 3, print Sequence Complete and play a sound.", "output": "BLUEPRINT: BP_TriggerSequence\nPARENT: Actor\nVAR StepCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=StepCount]\nNODE n3: AddInt [B=1]\nNODE n4: VariableSet [VarName=StepCount]\nNODE n5: EqualEqual [B=3]\nNODE n6: Branch\nNODE n7: PrintString [InString=\"Sequence Complete\"]\nNODE n8: GetActorLocation\nNODE n9: PlaySoundAtLocation [Sound=CompleteSound]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n7.Execute\nEXEC n7.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Location [Vector]", "source": "lesson:lesson_10:L10_18", "category": "trigger_sequence"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_Loading widget and adds to viewport. Waits 3 seconds. Removes loading widget. Creates WBP_MainMenu and adds to viewport. Prints Ready.", "output": "BLUEPRINT: BP_LoadScreen\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_Loading]\nNODE n3: AddToViewport\nNODE n4: Delay [Duration=3.0]\nNODE n5: RemoveFromParent\nNODE n6: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n7: AddToViewport\nNODE n8: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nEXEC n4.Completed -> n5.Execute\nDATA n2.ReturnValue -> n5.Target [Widget]\nEXEC n5.Then -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Target [Widget]\nEXEC n7.Then -> n8.Execute", "source": "lesson:lesson_10:L10_19", "category": "loading_screen"}
{"instruction": "Create a Blueprint with int Score at 0 and float Health at 100. On BeginPlay create WBP_HUD. On overlap add 10 to Score and print it. On AnyDamage subtract damage from Health. If Health below 0, remove HUD, print Game Over, destroy actor.", "output": "BLUEPRINT: BP_GameLoop\nPARENT: Actor\nVAR Score: Int = 0\nVAR Health: Float = 100.0\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_ActorBeginOverlap\nNODE n6: VariableGet [VarName=Score]\nNODE n7: AddInt [B=10]\nNODE n8: VariableSet [VarName=Score]\nNODE n9: PrintString\nNODE n10: Event_AnyDamage\nNODE n11: VariableGet [VarName=Health]\nNODE n12: SubtractFloat\nNODE n13: VariableSet [VarName=Health]\nNODE n14: LessThan [B=0.0]\nNODE n15: Branch\nNODE n16: VariableGet [VarName=HUD]\nNODE n17: RemoveFromParent\nNODE n18: PrintString [InString=\"Game Over\"]\nNODE n19: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Int]\nDATA n7.ReturnValue -> n8.Value [Int]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]\nEXEC n10.Then -> n13.Execute\nDATA n11.Value -> n12.A [Float]\nDATA n10.Damage -> n12.B [Float]\nDATA n12.ReturnValue -> n13.Value [Float]\nEXEC n13.Then -> n15.Execute\nDATA n13.Value -> n14.A [Float]\nDATA n14.ReturnValue -> n15.Condition [Bool]\nEXEC n15.True -> n17.Execute\nDATA n16.Value -> n17.Target [Widget]\nEXEC n17.Then -> n18.Execute\nEXEC n18.Then -> n19.Execute", "source": "lesson:lesson_10:L10_20", "category": "full_game_loop"}
{"instruction": "Create a Blueprint with a string array Inventory. On BeginPlay add Sword to the array and print the array length.", "output": "BLUEPRINT: BP_AddToArray\nPARENT: Actor\nVAR Inventory: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Inventory]\nNODE n3: ArrayAdd [Item=\"Sword\"]\nNODE n4: ArrayLength\nNODE n5: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.Then -> n5.Execute\nDATA n2.Value -> n4.Array [Array]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_11:L11_01", "category": "array_add"}
{"instruction": "Create a Blueprint with actor array Enemies. On pressing Clear, remove the first element from the array and print Removed.", "output": "BLUEPRINT: BP_RemoveFirst\nPARENT: Actor\nVAR Enemies: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Clear\"]\nNODE n2: VariableGet [VarName=Enemies]\nNODE n3: ArrayRemoveIndex [Index=0]\nNODE n4: PrintString [InString=\"Removed\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_11:L11_02", "category": "array_remove"}
{"instruction": "Create a Blueprint with string array Items. On BeginPlay get the element at index 0 and print it.", "output": "BLUEPRINT: BP_GetFirst\nPARENT: Actor\nVAR Items: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Items]\nNODE n3: ArrayGet [Index=0]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Array [Array]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_11:L11_03", "category": "array_get"}
{"instruction": "Create a Blueprint with string array Tags. On BeginPlay check if Tags contains Player. If yes print Is Player. If no print Not Player.", "output": "BLUEPRINT: BP_ContainsCheck\nPARENT: Actor\nVAR Tags: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Tags]\nNODE n3: ArrayContains [Item=\"Player\"]\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Is Player\"]\nNODE n6: PrintString [InString=\"Not Player\"]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.Array [Array]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n5.Execute\nEXEC n4.False -> n6.Execute", "source": "lesson:lesson_11:L11_04", "category": "array_contains"}
{"instruction": "Create a Blueprint with actor array Items. On BeginPlay get array length. If length greater than 0 print Has Items. Else print Empty.", "output": "BLUEPRINT: BP_LengthCheck\nPARENT: Actor\nVAR Items: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Items]\nNODE n3: ArrayLength\nNODE n4: GreaterThan [B=0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Has Items\"]\nNODE n7: PrintString [InString=\"Empty\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.Array [Array]\nDATA n3.ReturnValue -> n4.A [Int]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n7.Execute", "source": "lesson:lesson_11:L11_05", "category": "array_length_check"}
{"instruction": "Create a Blueprint with string array Names. On BeginPlay use ForEachLoop to print every name in the array.", "output": "BLUEPRINT: BP_PrintNames\nPARENT: Actor\nVAR Names: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Names]\nNODE n3: ForEachLoop\nNODE n4: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.InString [String]", "source": "lesson:lesson_11:L11_06", "category": "array_foreach_print"}
{"instruction": "Create a Blueprint with actor array Targets. On pressing Reset, clear the array and print Cleared.", "output": "BLUEPRINT: BP_ClearArray\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Reset\"]\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ArrayClear\nNODE n4: PrintString [InString=\"Cleared\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_11:L11_07", "category": "array_clear"}
{"instruction": "Create a Blueprint with actor array Visitors. On overlap add the other actor to Visitors and print the array length.", "output": "BLUEPRINT: BP_TrackVisitors\nPARENT: Actor\nVAR Visitors: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=Visitors]\nNODE n3: ArrayAdd\nNODE n4: ArrayLength\nNODE n5: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n3.Item [Actor]\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.Then -> n5.Execute\nDATA n2.Value -> n4.Array [Array]\nDATA n4.ReturnValue -> n5.InString [String]", "source": "lesson:lesson_11:L11_08", "category": "array_add_overlap"}
{"instruction": "Create a Blueprint with actor array Enemies. On pressing Kill, ForEachLoop through all enemies and destroy each one. After loop print All Destroyed.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\nVAR Enemies: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Kill\"]\nNODE n2: VariableGet [VarName=Enemies]\nNODE n3: ForEachLoop\nNODE n4: DestroyActor\nNODE n5: PrintString [InString=\"All Destroyed\"]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]\nEXEC n3.Completed -> n5.Execute", "source": "lesson:lesson_11:L11_09", "category": "array_foreach_destroy"}
{"instruction": "Create a Blueprint with actor array Targets. On BeginPlay ForEachLoop checking distance. Track closest in variable Nearest. After loop print nearest name.", "output": "BLUEPRINT: BP_FindNearest\nPARENT: Actor\nVAR Targets: Array<Actor>\nVAR Nearest: Actor = None\nVAR BestDist: Float = 999999.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: GetDistanceTo\nNODE n5: VariableGet [VarName=BestDist]\nNODE n6: LessThan\nNODE n7: Branch\nNODE n8: VariableSet [VarName=BestDist]\nNODE n9: VariableSet [VarName=Nearest]\nNODE n10: VariableGet [VarName=Nearest]\nNODE n11: GetDisplayName\nNODE n12: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n7.Execute\nDATA n3.ArrayElement -> n4.OtherActor [Actor]\nDATA n4.ReturnValue -> n6.A [Float]\nDATA n5.Value -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nDATA n4.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n3.ArrayElement -> n9.Value [Actor]\nEXEC n3.Completed -> n12.Execute\nDATA n10.Value -> n11.Target [Actor]\nDATA n11.ReturnValue -> n12.InString [String]", "source": "lesson:lesson_11:L11_10", "category": "array_find_nearest"}
{"instruction": "Create a Blueprint with string array Quotes. On pressing Random, get array length, generate random index, get element at that index, print it.", "output": "BLUEPRINT: BP_RandomQuote\nPARENT: Actor\nVAR Quotes: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Random\"]\nNODE n2: VariableGet [VarName=Quotes]\nNODE n3: ArrayLength\nNODE n4: RandomInteger [Min=0]\nNODE n5: ArrayGet\nNODE n6: PrintString\nEXEC n1.Pressed -> n6.Execute\nDATA n2.Value -> n3.Array [Array]\nDATA n3.ReturnValue -> n4.Max [Int]\nDATA n4.ReturnValue -> n5.Index [Int]\nDATA n2.Value -> n5.Array [Array]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_11:L11_11", "category": "array_random"}
{"instruction": "Create a Blueprint with vector array SpawnPoints. On BeginPlay ForEachLoop spawning BP_Enemy at each point. After loop print all spawned count.", "output": "BLUEPRINT: BP_SpawnFromArray\nPARENT: Actor\nVAR SpawnPoints: Array<Vector>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=SpawnPoints]\nNODE n3: ForEachLoop\nNODE n4: SpawnActorFromClass [ActorClass=BP_Enemy]\nNODE n5: VariableGet [VarName=SpawnPoints]\nNODE n6: ArrayLength\nNODE n7: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.SpawnTransform [Transform]\nEXEC n3.Completed -> n7.Execute\nDATA n5.Value -> n6.Array [Array]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:lesson_11:L11_12", "category": "array_loop_spawn"}
{"instruction": "Create a Blueprint with actor array TrackedActors. On overlap add actor. On end overlap remove actor from array. Print count after each change.", "output": "BLUEPRINT: BP_TrackOverlap\nPARENT: Actor\nVAR TrackedActors: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=TrackedActors]\nNODE n3: ArrayAdd\nNODE n4: ArrayLength\nNODE n5: PrintString\nNODE n6: Event_ActorEndOverlap\nNODE n7: VariableGet [VarName=TrackedActors]\nNODE n8: ArrayRemove\nNODE n9: ArrayLength\nNODE n10: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n3.Item [Actor]\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.Then -> n5.Execute\nDATA n2.Value -> n4.Array [Array]\nDATA n4.ReturnValue -> n5.InString [String]\nEXEC n6.Then -> n8.Execute\nDATA n6.OtherActor -> n8.Item [Actor]\nDATA n7.Value -> n8.Array [Array]\nEXEC n8.Then -> n10.Execute\nDATA n7.Value -> n9.Array [Array]\nDATA n9.ReturnValue -> n10.InString [String]", "source": "lesson:lesson_11:L11_13", "category": "array_remove_overlap"}
{"instruction": "Create a Blueprint with int array Scores. Start a looping timer every 2 seconds. Each tick generate random 1-100 and add to Scores. Print array length. After 5 items clear timer.", "output": "BLUEPRINT: BP_TimerArray\nPARENT: Actor\nVAR Scores: Array<Int>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"AddScore\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=AddScore]\nNODE n4: RandomInteger [Min=1, Max=100]\nNODE n5: VariableGet [VarName=Scores]\nNODE n6: ArrayAdd\nNODE n7: ArrayLength\nNODE n8: PrintString\nNODE n9: GreaterThan [B=4]\nNODE n10: Branch\nNODE n11: ClearTimerByFunctionName [FunctionName=\"AddScore\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.ReturnValue -> n6.Item [Int]\nDATA n5.Value -> n6.Array [Array]\nEXEC n6.Then -> n8.Execute\nDATA n5.Value -> n7.Array [Array]\nDATA n7.ReturnValue -> n8.InString [String]\nEXEC n8.Then -> n10.Execute\nDATA n7.ReturnValue -> n9.A [Int]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n11.Execute", "source": "lesson:lesson_11:L11_14", "category": "array_timer_add"}
{"instruction": "Create a Blueprint with string array Log. On BeginPlay get array length, subtract 1, get element at that index. Print the last element.", "output": "BLUEPRINT: BP_LastElement\nPARENT: Actor\nVAR Log: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Log]\nNODE n3: ArrayLength\nNODE n4: SubtractInt [B=1]\nNODE n5: ArrayGet\nNODE n6: PrintString\nEXEC n1.Then -> n6.Execute\nDATA n2.Value -> n3.Array [Array]\nDATA n3.ReturnValue -> n4.A [Int]\nDATA n4.ReturnValue -> n5.Index [Int]\nDATA n2.Value -> n5.Array [Array]\nDATA n5.ReturnValue -> n6.InString [String]", "source": "lesson:lesson_11:L11_15", "category": "array_last_element"}
{"instruction": "Create a Blueprint with actor array AllActors. On BeginPlay ForEachLoop. Check distance less than 500 for each. If close, add to a NearbyActors array. After loop print nearby count.", "output": "BLUEPRINT: BP_FilterNearby\nPARENT: Actor\nVAR AllActors: Array<Actor>\nVAR NearbyActors: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=AllActors]\nNODE n3: ForEachLoop\nNODE n4: GetDistanceTo\nNODE n5: LessThan [B=500.0]\nNODE n6: Branch\nNODE n7: VariableGet [VarName=NearbyActors]\nNODE n8: ArrayAdd\nNODE n9: VariableGet [VarName=NearbyActors]\nNODE n10: ArrayLength\nNODE n11: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n6.Execute\nDATA n3.ArrayElement -> n4.OtherActor [Actor]\nDATA n4.ReturnValue -> n5.A [Float]\nDATA n5.ReturnValue -> n6.Condition [Bool]\nEXEC n6.True -> n8.Execute\nDATA n3.ArrayElement -> n8.Item [Actor]\nDATA n7.Value -> n8.Array [Array]\nEXEC n3.Completed -> n11.Execute\nDATA n9.Value -> n10.Array [Array]\nDATA n10.ReturnValue -> n11.InString [String]", "source": "lesson:lesson_11:L11_16", "category": "array_filter_distance"}
{"instruction": "Create a Blueprint with int PickupType and string array CollectedTypes. On overlap switch on PickupType. Case 1 adds Health. Case 2 adds Ammo. Case 3 adds Shield. Print array length.", "output": "BLUEPRINT: BP_TypeCollector\nPARENT: Actor\nVAR PickupType: Int = 1\nVAR CollectedTypes: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: VariableGet [VarName=PickupType]\nNODE n3: SwitchOnInt\nNODE n4: VariableGet [VarName=CollectedTypes]\nNODE n5: ArrayAdd [Item=\"Health\"]\nNODE n6: ArrayAdd [Item=\"Ammo\"]\nNODE n7: ArrayAdd [Item=\"Shield\"]\nNODE n8: ArrayLength\nNODE n9: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n5.Execute\nDATA n4.Value -> n5.Array [Array]\nEXEC n3.Case_2 -> n6.Execute\nDATA n4.Value -> n6.Array [Array]\nEXEC n3.Case_3 -> n7.Execute\nDATA n4.Value -> n7.Array [Array]\nEXEC n5.Then -> n9.Execute\nEXEC n6.Then -> n9.Execute\nEXEC n7.Then -> n9.Execute\nDATA n4.Value -> n8.Array [Array]\nDATA n8.ReturnValue -> n9.InString [String]", "source": "lesson:lesson_11:L11_17", "category": "array_switch_add"}
{"instruction": "Create a Blueprint with actor array Queue. On pressing Next, check if array length equals 0. If empty print Queue Empty. If not, get first element, remove index 0, print the element name.", "output": "BLUEPRINT: BP_QueueProcess\nPARENT: Actor\nVAR Queue: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Next\"]\nNODE n2: VariableGet [VarName=Queue]\nNODE n3: ArrayLength\nNODE n4: EqualEqual [B=0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Queue Empty\"]\nNODE n7: ArrayGet [Index=0]\nNODE n8: ArrayRemoveIndex [Index=0]\nNODE n9: GetDisplayName\nNODE n10: PrintString\nEXEC n1.Pressed -> n5.Execute\nDATA n2.Value -> n3.Array [Array]\nDATA n3.ReturnValue -> n4.A [Int]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n8.Execute\nDATA n2.Value -> n7.Array [Array]\nDATA n7.ReturnValue -> n9.Target [Actor]\nDATA n2.Value -> n8.Array [Array]\nEXEC n8.Then -> n10.Execute\nDATA n9.ReturnValue -> n10.InString [String]", "source": "lesson:lesson_11:L11_18", "category": "array_empty_check"}
{"instruction": "Create a Blueprint with actor array Targets. On BeginPlay ForEachLoop. For each, check IsValid. If valid print name. After loop print Done.", "output": "BLUEPRINT: BP_ValidCheck\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: IsValid\nNODE n5: Branch\nNODE n6: GetDisplayName\nNODE n7: PrintString\nNODE n8: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n5.Execute\nDATA n3.ArrayElement -> n4.Input [Object]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n3.ArrayElement -> n6.Target [Actor]\nDATA n6.ReturnValue -> n7.InString [String]\nEXEC n3.Completed -> n8.Execute", "source": "lesson:lesson_11:L11_19", "category": "array_foreach_valid"}
{"instruction": "Create a Blueprint with string array Inventory. On BeginPlay add Sword, Shield, Potion to the array. Then ForEachLoop printing each item. After loop print the total count.", "output": "BLUEPRINT: BP_BuildInventory\nPARENT: Actor\nVAR Inventory: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Inventory]\nNODE n3: ArrayAdd [Item=\"Sword\"]\nNODE n4: ArrayAdd [Item=\"Shield\"]\nNODE n5: ArrayAdd [Item=\"Potion\"]\nNODE n6: ForEachLoop\nNODE n7: PrintString\nNODE n8: ArrayLength\nNODE n9: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.Then -> n4.Execute\nDATA n2.Value -> n4.Array [Array]\nEXEC n4.Then -> n5.Execute\nDATA n2.Value -> n5.Array [Array]\nEXEC n5.Then -> n6.Execute\nDATA n2.Value -> n6.Array [Array]\nEXEC n6.LoopBody -> n7.Execute\nDATA n6.ArrayElement -> n7.InString [String]\nEXEC n6.Completed -> n9.Execute\nDATA n2.Value -> n8.Array [Array]\nDATA n8.ReturnValue -> n9.InString [String]", "source": "lesson:lesson_11:L11_20", "category": "array_build_inventory"}
{"instruction": "Create a Blueprint with two vector variables PointA and PointB. On Tick, lerp the actor position between them using a float Alpha that increases each frame.", "output": "BLUEPRINT: BP_SimplePatrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: AddFloat [B=0.01]\nNODE n4: VariableSet [VarName=Alpha]\nNODE n5: VariableGet [VarName=PointA]\nNODE n6: VariableGet [VarName=PointB]\nNODE n7: Lerp\nNODE n8: SetActorLocation\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.DeltaSeconds -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nEXEC n4.Then -> n8.Execute\nDATA n5.Value -> n7.A [Vector]\nDATA n6.Value -> n7.B [Vector]\nDATA n4.Value -> n7.Alpha [Float]\nDATA n7.ReturnValue -> n8.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_01", "category": "patrol_simple"}
{"instruction": "Create a Blueprint that moves between PointA and PointB. Use Alpha going 0 to 1. When Alpha exceeds 1, set direction to -1. When below 0, set direction to 1.", "output": "BLUEPRINT: BP_PingPong\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nVAR Direction: Float = 1.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: VariableGet [VarName=Direction]\nNODE n4: MultiplyFloat\nNODE n5: AddFloat\nNODE n6: VariableSet [VarName=Alpha]\nNODE n7: GreaterThan [B=1.0]\nNODE n8: Branch\nNODE n9: VariableSet [VarName=Direction]\nNODE n10: LessThan [B=0.0]\nNODE n11: Branch\nNODE n12: VariableSet [VarName=Direction]\nNODE n13: VariableGet [VarName=PointA]\nNODE n14: VariableGet [VarName=PointB]\nNODE n15: Lerp\nNODE n16: SetActorLocation\nEXEC n1.Then -> n6.Execute\nDATA n1.DeltaSeconds -> n4.A [Float]\nDATA n3.Value -> n4.B [Float]\nDATA n2.Value -> n5.A [Float]\nDATA n4.ReturnValue -> n5.B [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA -1.0 -> n9.Value [Float]\nEXEC n8.False -> n11.Execute\nDATA n6.Value -> n10.A [Float]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute\nDATA 1.0 -> n12.Value [Float]\nEXEC n11.False -> n16.Execute\nEXEC n9.Then -> n16.Execute\nEXEC n12.Then -> n16.Execute\nDATA n13.Value -> n15.A [Vector]\nDATA n14.Value -> n15.B [Vector]\nDATA n6.Value -> n15.Alpha [Float]\nDATA n15.ReturnValue -> n16.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_02", "category": "patrol_ping_pong"}
{"instruction": "Create a Blueprint with vectors PointA and PointB and bool GoingToB. On Tick, if GoingToB lerp toward PointB. If distance to PointB less than 50 set GoingToB false. Else lerp toward PointA.", "output": "BLUEPRINT: BP_TwoPointPatrol\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR GoingToB: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=GoingToB]\nNODE n3: Branch\nNODE n4: GetActorLocation\nNODE n5: VariableGet [VarName=PointB]\nNODE n6: Lerp [Alpha=0.02]\nNODE n7: SetActorLocation\nNODE n8: GetActorLocation\nNODE n9: VariableGet [VarName=PointA]\nNODE n10: Lerp [Alpha=0.02]\nNODE n11: SetActorLocation\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n7.Execute\nDATA n4.ReturnValue -> n6.A [Vector]\nDATA n5.Value -> n6.B [Vector]\nDATA n6.ReturnValue -> n7.NewLocation [Vector]\nEXEC n3.False -> n11.Execute\nDATA n8.ReturnValue -> n10.A [Vector]\nDATA n9.Value -> n10.B [Vector]\nDATA n10.ReturnValue -> n11.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_03", "category": "patrol_two_point"}
{"instruction": "Create a Blueprint with integer Rolls at 0. On BeginPlay use WhileLoop while Rolls less than 10. Each loop generate random int 1-6 and print it. Increment Rolls.", "output": "BLUEPRINT: BP_DiceRolls\nPARENT: Actor\nVAR Rolls: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Rolls]\nNODE n4: LessThan [B=10]\nNODE n5: RandomInteger [Min=1, Max=6]\nNODE n6: PrintString\nNODE n7: VariableGet [VarName=Rolls]\nNODE n8: AddInt [B=1]\nNODE n9: VariableSet [VarName=Rolls]\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Int]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n6.Execute\nDATA n5.ReturnValue -> n6.InString [String]\nEXEC n6.Then -> n9.Execute\nDATA n7.Value -> n8.A [Int]\nDATA n8.ReturnValue -> n9.Value [Int]", "source": "lesson:correction_v3a:C3A_04", "category": "while_random_simple"}
{"instruction": "Create a Blueprint with float Total at 0. Use WhileLoop while Total less than 100. Each iteration add random float 1-25 to Total and print it.", "output": "BLUEPRINT: BP_Accumulator\nPARENT: Actor\nVAR Total: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: WhileLoop\nNODE n3: VariableGet [VarName=Total]\nNODE n4: LessThan [B=100.0]\nNODE n5: VariableGet [VarName=Total]\nNODE n6: RandomFloat [Min=1.0, Max=25.0]\nNODE n7: AddFloat\nNODE n8: VariableSet [VarName=Total]\nNODE n9: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n3.Value -> n4.A [Float]\nDATA n4.ReturnValue -> n2.Condition [Bool]\nEXEC n2.LoopBody -> n8.Execute\nDATA n5.Value -> n7.A [Float]\nDATA n6.ReturnValue -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n9.Execute\nDATA n8.Value -> n9.InString [String]", "source": "lesson:correction_v3a:C3A_05", "category": "while_accumulate"}
{"instruction": "Create a Blueprint that on overlap first casts to Character. If fails, cast to Pawn. If that also fails, print Unknown.", "output": "BLUEPRINT: BP_CastChain\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Character Found\"]\nNODE n4: CastToPawn\nNODE n5: PrintString [InString=\"Pawn Found\"]\nNODE n6: PrintString [InString=\"Unknown\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute\nDATA n1.OtherActor -> n4.Object [Actor]\nEXEC n4.CastSucceeded -> n5.Execute\nEXEC n4.CastFailed -> n6.Execute", "source": "lesson:correction_v3a:C3A_06", "category": "cast_chain"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If success, store in variable Player and print Found Player. If fail, cast to Pawn. If that succeeds store in variable NPC.", "output": "BLUEPRINT: BP_CastAndStore\nPARENT: Actor\nVAR Player: Actor = None\nVAR NPC: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: VariableSet [VarName=Player]\nNODE n4: PrintString [InString=\"Found Player\"]\nNODE n5: CastToPawn\nNODE n6: VariableSet [VarName=NPC]\nNODE n7: PrintString [InString=\"Found NPC\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nDATA n2.AsCharacter -> n3.Value [Actor]\nEXEC n3.Then -> n4.Execute\nEXEC n2.CastFailed -> n5.Execute\nDATA n1.OtherActor -> n5.Object [Actor]\nEXEC n5.CastSucceeded -> n6.Execute\nDATA n5.AsPawn -> n6.Value [Actor]\nEXEC n6.Then -> n7.Execute", "source": "lesson:correction_v3a:C3A_07", "category": "cast_store"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If success and IsValid, get player location and print it. If cast fails print Not A Character.", "output": "BLUEPRINT: BP_SafeCastLocation\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetActorLocation\nNODE n6: PrintString\nNODE n7: PrintString [InString=\"Not A Character\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n2.AsCharacter -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n6.Execute\nDATA n2.AsCharacter -> n5.Target [Actor]\nDATA n5.ReturnValue -> n6.InString [String]\nEXEC n2.CastFailed -> n7.Execute", "source": "lesson:correction_v3a:C3A_08", "category": "cast_with_isvalid"}
{"instruction": "Create a Blueprint with a Gate. Pressing Open opens the gate and creates WBP_Panel widget. Pressing Close closes the gate and removes the widget.", "output": "BLUEPRINT: BP_GateWidget\nPARENT: Actor\nVAR Panel: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Open\"]\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Panel]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Panel]\nNODE n6: Event_InputAction [ActionName=\"Close\"]\nNODE n7: VariableGet [VarName=Panel]\nNODE n8: RemoveFromParent\nEXEC n1.Pressed -> n2.Open\nEXEC n2.Exit -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n6.Pressed -> n2.Close\nEXEC n6.Pressed -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]", "source": "lesson:correction_v3a:C3A_09", "category": "gate_widget_basic"}
{"instruction": "Create a Blueprint that on BeginPlay opens a Gate and starts a looping timer. The timer enters the gate. The gate exit creates WBP_Notification and adds to viewport. Pressing Stop closes gate and clears timer.", "output": "BLUEPRINT: BP_GateTimerUI\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: SetTimerByFunctionName [FunctionName=\"Pulse\", Time=3.0, Looping=true]\nNODE n4: Event_Custom [EventName=Pulse]\nNODE n5: CreateWidget [WidgetClass=WBP_Notification]\nNODE n6: AddToViewport\nNODE n7: Event_InputAction [ActionName=\"Stop\"]\nNODE n8: ClearTimerByFunctionName [FunctionName=\"Pulse\"]\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n4.Then -> n2.Enter\nEXEC n2.Exit -> n5.Execute\nEXEC n5.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.Target [Widget]\nEXEC n7.Pressed -> n2.Close\nEXEC n7.Pressed -> n8.Execute", "source": "lesson:correction_v3a:C3A_10", "category": "gate_timer_widget"}
{"instruction": "Create a Blueprint with integer SpawnCount at 0. On pressing Spawn, increment SpawnCount, spawn BP_Item at actor location, print Spawned # followed by the count.", "output": "BLUEPRINT: BP_CountedSpawn\nPARENT: Actor\nVAR SpawnCount: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Spawn\"]\nNODE n2: VariableGet [VarName=SpawnCount]\nNODE n3: AddInt [B=1]\nNODE n4: VariableSet [VarName=SpawnCount]\nNODE n5: GetActorLocation\nNODE n6: SpawnActorFromClass [ActorClass=BP_Item]\nNODE n7: Concatenate [A=\"Spawned # \"]\nNODE n8: PrintString\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nEXEC n4.Then -> n6.Execute\nDATA n5.ReturnValue -> n6.SpawnTransform [Transform]\nEXEC n6.Then -> n8.Execute\nDATA n4.Value -> n7.B [String]\nDATA n7.ReturnValue -> n8.InString [String]", "source": "lesson:correction_v3a:C3A_12", "category": "spawn_count_log"}
{"instruction": "Create a Blueprint with float Health. On AnyDamage subtract damage from Health. If Health less than 0 set to 0. If greater than 100 set to 100. Print the clamped value.", "output": "BLUEPRINT: BP_ClampHealth\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: SubtractFloat\nNODE n4: Clamp [Min=0.0, Max=100.0]\nNODE n5: VariableSet [VarName=Health]\nNODE n6: PrintString\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n6.Execute\nDATA n5.Value -> n6.InString [String]", "source": "lesson:correction_v3a:C3A_13", "category": "clamp_health"}
{"instruction": "Create a Blueprint that on Tick gets actor location. If Z less than 0 set Z to 0. If Z greater than 500 set Z to 500. Set the clamped location.", "output": "BLUEPRINT: BP_ClampZ\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetActorLocation\nNODE n3: BreakVector\nNODE n4: Clamp [Min=0.0, Max=500.0]\nNODE n5: MakeVector\nNODE n6: SetActorLocation\nEXEC n1.Then -> n6.Execute\nDATA n2.ReturnValue -> n3.Input [Vector]\nDATA n3.X -> n5.X [Float]\nDATA n3.Y -> n5.Y [Float]\nDATA n3.Z -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Z [Float]\nDATA n5.ReturnValue -> n6.NewLocation [Vector]", "source": "lesson:correction_v3a:C3A_14", "category": "clamp_position_z"}
{"instruction": "Create a Blueprint with float Speed at 50. On pressing SpeedUp add 25 to Speed. Clamp Speed between 0 and 200. Print Speed: followed by the value.", "output": "BLUEPRINT: BP_ClampSpeed\nPARENT: Actor\nVAR Speed: Float = 50.0\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"SpeedUp\"]\nNODE n2: VariableGet [VarName=Speed]\nNODE n3: AddFloat [B=25.0]\nNODE n4: Clamp [Min=0.0, Max=200.0]\nNODE n5: VariableSet [VarName=Speed]\nNODE n6: Concatenate [A=\"Speed: \"]\nNODE n7: PrintString\nEXEC n1.Pressed -> n5.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n7.Execute\nDATA n5.Value -> n6.B [String]\nDATA n6.ReturnValue -> n7.InString [String]", "source": "lesson:correction_v3a:C3A_15", "category": "clamp_speed"}
{"instruction": "Create a Blueprint that prints Ready on BeginPlay.", "output": "BLUEPRINT: BP_Ready\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nEXEC n1.Then -> n2.Execute", "source": "lesson:correction_v3b:C3B_01", "category": "clean_simple"}
{"instruction": "Create a Blueprint that destroys itself on BeginPlay.", "output": "BLUEPRINT: BP_SelfDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: DestroyActor\nEXEC n1.Then -> n2.Execute", "source": "lesson:correction_v3b:C3B_02", "category": "clean_destroy"}
{"instruction": "Create a Blueprint with integer Count at 0. On BeginPlay set Count to 5 and print the value.", "output": "BLUEPRINT: BP_SetCount\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=Count]\nNODE n3: PrintString\nEXEC n1.Then -> n2.Execute\nDATA 5 -> n2.Value [Int]\nEXEC n2.Then -> n3.Execute\nDATA n2.Value -> n3.InString [String]", "source": "lesson:correction_v3b:C3B_03", "category": "clean_variable"}
{"instruction": "Create a Blueprint with bool IsReady. On BeginPlay if IsReady print Go. Else print Wait.", "output": "BLUEPRINT: BP_ReadyCheck\nPARENT: Actor\nVAR IsReady: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsReady]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Go\"]\nNODE n5: PrintString [InString=\"Wait\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:correction_v3b:C3B_04", "category": "clean_branch"}
{"instruction": "Create a Blueprint that on overlap prints Touched and destroys the overlapping actor.", "output": "BLUEPRINT: BP_TouchDestroy\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: PrintString [InString=\"Touched\"]\nNODE n3: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n1.OtherActor -> n3.Target [Actor]", "source": "lesson:correction_v3b:C3B_05", "category": "clean_overlap"}
{"instruction": "Create a Blueprint that on BeginPlay waits 2 seconds then prints Done.", "output": "BLUEPRINT: BP_DelayPrint\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=2.0]\nNODE n3: PrintString [InString=\"Done\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:correction_v3b:C3B_06", "category": "clean_delay"}
{"instruction": "Create a Blueprint that on BeginPlay starts a looping timer every 3 seconds. The timer prints Tick.", "output": "BLUEPRINT: BP_TickTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTick\", Time=3.0, Looping=true]\nNODE n3: Event_Custom [EventName=OnTick]\nNODE n4: PrintString [InString=\"Tick\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:correction_v3b:C3B_07", "category": "clean_timer"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If success print Player. If fail print Other.", "output": "BLUEPRINT: BP_CastCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player\"]\nNODE n4: PrintString [InString=\"Other\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n3.Execute\nEXEC n2.CastFailed -> n4.Execute", "source": "lesson:correction_v3b:C3B_08", "category": "clean_cast"}
{"instruction": "Create a Blueprint with vectors PointA and PointB and float Alpha. On Tick add DeltaSeconds times 0.3 to Alpha. Lerp between PointA and PointB using Alpha. Set actor location to result.", "output": "BLUEPRINT: BP_LerpPlatform\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: MultiplyFloat [B=0.3]\nNODE n4: AddFloat\nNODE n5: VariableSet [VarName=Alpha]\nNODE n6: VariableGet [VarName=PointA]\nNODE n7: VariableGet [VarName=PointB]\nNODE n8: Lerp\nNODE n9: SetActorLocation\nEXEC n1.Then -> n5.Execute\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.Value -> n4.A [Float]\nDATA n3.ReturnValue -> n4.B [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n9.Execute\nDATA n6.Value -> n8.A [Vector]\nDATA n7.Value -> n8.B [Vector]\nDATA n5.Value -> n8.Alpha [Float]\nDATA n8.ReturnValue -> n9.NewLocation [Vector]", "source": "lesson:correction_v4a:C4A_01", "category": "lerp_ab_basic"}
{"instruction": "Create a Blueprint with vectors Start and End, float T at 0, and float Dir at 1. On Tick, add DeltaSeconds times Dir to T. If T greater than 1 set Dir to -1. If T less than 0 set Dir to 1. Lerp and set location.", "output": "BLUEPRINT: BP_ReverseLerp\nPARENT: Actor\nVAR Start: Vector\nVAR End: Vector\nVAR T: Float = 0.0\nVAR Dir: Float = 1.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=T]\nNODE n3: VariableGet [VarName=Dir]\nNODE n4: MultiplyFloat\nNODE n5: AddFloat\nNODE n6: VariableSet [VarName=T]\nNODE n7: GreaterThan [B=1.0]\nNODE n8: Branch\nNODE n9: VariableSet [VarName=Dir]\nNODE n10: LessThan [B=0.0]\nNODE n11: Branch\nNODE n12: VariableSet [VarName=Dir]\nNODE n13: VariableGet [VarName=Start]\nNODE n14: VariableGet [VarName=End]\nNODE n15: Lerp\nNODE n16: SetActorLocation\nEXEC n1.Then -> n6.Execute\nDATA n1.DeltaSeconds -> n4.A [Float]\nDATA n3.Value -> n4.B [Float]\nDATA n2.Value -> n5.A [Float]\nDATA n4.ReturnValue -> n5.B [Float]\nDATA n5.ReturnValue -> n6.Value [Float]\nEXEC n6.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA -1.0 -> n9.Value [Float]\nEXEC n9.Then -> n16.Execute\nEXEC n8.False -> n11.Execute\nDATA n6.Value -> n10.A [Float]\nDATA n10.ReturnValue -> n11.Condition [Bool]\nEXEC n11.True -> n12.Execute\nDATA 1.0 -> n12.Value [Float]\nEXEC n12.Then -> n16.Execute\nEXEC n11.False -> n16.Execute\nDATA n13.Value -> n15.A [Vector]\nDATA n14.Value -> n15.B [Vector]\nDATA n6.Value -> n15.Alpha [Float]\nDATA n15.ReturnValue -> n16.NewLocation [Vector]", "source": "lesson:correction_v4a:C4A_02", "category": "lerp_reverse"}
{"instruction": "Create a Blueprint that on Tick increases Alpha by DeltaSeconds. Clamp Alpha between 0 and 1. Lerp between PointA and PointB. Set actor location.", "output": "BLUEPRINT: BP_ClampedLerp\nPARENT: Actor\nVAR PointA: Vector\nVAR PointB: Vector\nVAR Alpha: Float = 0.0\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: VariableGet [VarName=Alpha]\nNODE n3: AddFloat\nNODE n4: Clamp [Min=0.0, Max=1.0]\nNODE n5: VariableSet [VarName=Alpha]\nNODE n6: VariableGet [VarName=PointA]\nNODE n7: VariableGet [VarName=PointB]\nNODE n8: Lerp\nNODE n9: SetActorLocation\nEXEC n1.Then -> n5.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.DeltaSeconds -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]\nDATA n4.ReturnValue -> n5.Value [Float]\nEXEC n5.Then -> n9.Execute\nDATA n6.Value -> n8.A [Vector]\nDATA n7.Value -> n8.B [Vector]\nDATA n5.Value -> n8.Alpha [Float]\nDATA n8.ReturnValue -> n9.NewLocation [Vector]", "source": "lesson:correction_v4a:C4A_03", "category": "lerp_clamp"}
{"instruction": "Create a Blueprint. On pressing Interact get distance to player pawn. If less than 200, use FlipFlop. A path adds 90 degrees yaw rotation. B path adds -90 degrees yaw rotation.", "output": "BLUEPRINT: BP_FlipDoor\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: FlipFlop\nNODE n7: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=90,Roll=0)]\nNODE n8: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=-90,Roll=0)]\nEXEC n1.Pressed -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n6.A -> n7.Execute\nEXEC n6.B -> n8.Execute", "source": "lesson:correction_v4a:C4A_04", "category": "door_flipflop"}
{"instruction": "Create a Blueprint with bool IsOpen. On pressing Use, check distance to player less than 300. If close, branch on IsOpen. If closed, rotate 90 yaw, set IsOpen true, play sound. If open, rotate -90 yaw, set IsOpen false.", "output": "BLUEPRINT: BP_SoundDoor\nPARENT: Actor\nVAR IsOpen: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Use\"]\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=300.0]\nNODE n5: Branch\nNODE n6: VariableGet [VarName=IsOpen]\nNODE n7: Branch\nNODE n8: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=90,Roll=0)]\nNODE n9: VariableSet [VarName=IsOpen]\nNODE n10: PlaySoundAtLocation [Sound=DoorOpen]\nNODE n11: AddActorLocalRotation [DeltaRotation=(Pitch=0,Yaw=-90,Roll=0)]\nNODE n12: VariableSet [VarName=IsOpen]\nEXEC n1.Pressed -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n7.Execute\nDATA n6.Value -> n7.Condition [Bool]\nEXEC n7.False -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA true -> n9.Value [Bool]\nEXEC n9.Then -> n10.Execute\nEXEC n7.True -> n11.Execute\nEXEC n11.Then -> n12.Execute\nDATA false -> n12.Value [Bool]", "source": "lesson:correction_v4a:C4A_05", "category": "door_with_sound"}
{"instruction": "Create a Blueprint with float Health at 100 and vector SpawnPoint. On BeginPlay save location to SpawnPoint. On AnyDamage subtract damage from Health. If Health less than 0, set Health to 100, teleport to SpawnPoint, print Respawned.", "output": "BLUEPRINT: BP_BasicRespawn\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR SpawnPoint: Vector\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: VariableSet [VarName=SpawnPoint]\nNODE n4: Event_AnyDamage\nNODE n5: VariableGet [VarName=Health]\nNODE n6: SubtractFloat\nNODE n7: VariableSet [VarName=Health]\nNODE n8: LessThan [B=0.0]\nNODE n9: Branch\nNODE n10: VariableSet [VarName=Health]\nNODE n11: VariableGet [VarName=SpawnPoint]\nNODE n12: SetActorLocation\nNODE n13: PrintString [InString=\"Respawned\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Vector]\nEXEC n4.Then -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n4.Damage -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n10.Execute\nDATA 100.0 -> n10.Value [Float]\nEXEC n10.Then -> n12.Execute\nDATA n11.Value -> n12.NewLocation [Vector]\nEXEC n12.Then -> n13.Execute", "source": "lesson:correction_v4a:C4A_06", "category": "respawn_basic"}
{"instruction": "Create a Blueprint with Health at 100, vector Spawn, and int Deaths at 0. On BeginPlay save location. On AnyDamage subtract. If dead, increment Deaths, reset Health, teleport, print death count.", "output": "BLUEPRINT: BP_DeathCounter\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR Spawn: Vector\nVAR Deaths: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: VariableSet [VarName=Spawn]\nNODE n4: Event_AnyDamage\nNODE n5: VariableGet [VarName=Health]\nNODE n6: SubtractFloat\nNODE n7: VariableSet [VarName=Health]\nNODE n8: LessThan [B=0.0]\nNODE n9: Branch\nNODE n10: VariableGet [VarName=Deaths]\nNODE n11: AddInt [B=1]\nNODE n12: VariableSet [VarName=Deaths]\nNODE n13: VariableSet [VarName=Health]\nNODE n14: VariableGet [VarName=Spawn]\nNODE n15: SetActorLocation\nNODE n16: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Value [Vector]\nEXEC n4.Then -> n7.Execute\nDATA n5.Value -> n6.A [Float]\nDATA n4.Damage -> n6.B [Float]\nDATA n6.ReturnValue -> n7.Value [Float]\nEXEC n7.Then -> n9.Execute\nDATA n7.Value -> n8.A [Float]\nDATA n8.ReturnValue -> n9.Condition [Bool]\nEXEC n9.True -> n12.Execute\nDATA n10.Value -> n11.A [Int]\nDATA n11.ReturnValue -> n12.Value [Int]\nEXEC n12.Then -> n13.Execute\nDATA 100.0 -> n13.Value [Float]\nEXEC n13.Then -> n15.Execute\nDATA n14.Value -> n15.NewLocation [Vector]\nEXEC n15.Then -> n16.Execute\nDATA n12.Value -> n16.InString [String]", "source": "lesson:correction_v4a:C4A_07", "category": "respawn_with_counter"}
{"instruction": "Create a Blueprint. On BeginPlay start looping timer every 2 seconds. Timer checks distance to player pawn. If less than 1000, spawn BP_Projectile at actor location and print Firing.", "output": "BLUEPRINT: BP_SimpleTurret\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Fire\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=Fire]\nNODE n4: GetPlayerPawn\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=1000.0]\nNODE n7: Branch\nNODE n8: GetActorLocation\nNODE n9: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n10: PrintString [InString=\"Firing\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n7.Execute\nDATA n4.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n9.Execute\nDATA n8.ReturnValue -> n9.SpawnTransform [Transform]\nEXEC n9.Then -> n10.Execute", "source": "lesson:correction_v4a:C4A_08", "category": "turret_simple"}
{"instruction": "Create a Blueprint with int Ammo at 10. Timer every 1.5 seconds. If distance less than 800 and Ammo greater than 0, spawn projectile, subtract 1 from Ammo, print ammo count. If Ammo is 0 clear timer.", "output": "BLUEPRINT: BP_AmmoTurret\nPARENT: Actor\nVAR Ammo: Int = 10\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Shoot\", Time=1.5, Looping=true]\nNODE n3: Event_Custom [EventName=Shoot]\nNODE n4: GetPlayerPawn\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=800.0]\nNODE n7: Branch\nNODE n8: VariableGet [VarName=Ammo]\nNODE n9: GreaterThan [B=0]\nNODE n10: Branch\nNODE n11: GetActorLocation\nNODE n12: SpawnActorFromClass [ActorClass=BP_Projectile]\nNODE n13: VariableGet [VarName=Ammo]\nNODE n14: SubtractInt [B=1]\nNODE n15: VariableSet [VarName=Ammo]\nNODE n16: PrintString\nNODE n17: EqualEqual [B=0]\nNODE n18: Branch\nNODE n19: ClearTimerByFunctionName [FunctionName=\"Shoot\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n7.Execute\nDATA n4.ReturnValue -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n10.Execute\nDATA n8.Value -> n9.A [Int]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n12.Execute\nDATA n11.ReturnValue -> n12.SpawnTransform [Transform]\nEXEC n12.Then -> n15.Execute\nDATA n13.Value -> n14.A [Int]\nDATA n14.ReturnValue -> n15.Value [Int]\nEXEC n15.Then -> n16.Execute\nDATA n15.Value -> n16.InString [String]\nEXEC n16.Then -> n18.Execute\nDATA n15.Value -> n17.A [Int]\nDATA n17.ReturnValue -> n18.Condition [Bool]\nEXEC n18.True -> n19.Execute", "source": "lesson:correction_v4a:C4A_09", "category": "turret_with_ammo"}
{"instruction": "Create a Blueprint. On pressing Show, open a Gate and create WBP_Info widget, add to viewport, store in variable. On pressing Hide, close the gate and remove widget from parent.", "output": "BLUEPRINT: BP_GateShowHide\nPARENT: Actor\nVAR Info: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Show\"]\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Info]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Info]\nNODE n6: Event_InputAction [ActionName=\"Hide\"]\nNODE n7: VariableGet [VarName=Info]\nNODE n8: RemoveFromParent\nEXEC n1.Pressed -> n2.Open\nEXEC n2.Exit -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n6.Pressed -> n2.Close\nEXEC n6.Pressed -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]", "source": "lesson:correction_v4a:C4A_10", "category": "gate_create_remove"}
{"instruction": "Create a Blueprint. On overlap open Gate and create WBP_Prompt, add to viewport. On end overlap close Gate and remove widget. Gate exit prints Active.", "output": "BLUEPRINT: BP_OverlapGateUI\nPARENT: Actor\nVAR Prompt: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: Gate\nNODE n3: CreateWidget [WidgetClass=WBP_Prompt]\nNODE n4: AddToViewport\nNODE n5: VariableSet [VarName=Prompt]\nNODE n6: PrintString [InString=\"Active\"]\nNODE n7: Event_ActorEndOverlap\nNODE n8: VariableGet [VarName=Prompt]\nNODE n9: RemoveFromParent\nEXEC n1.Then -> n2.Open\nEXEC n1.Then -> n3.Execute\nEXEC n3.Then -> n4.Execute\nDATA n3.ReturnValue -> n4.Target [Widget]\nEXEC n4.Then -> n5.Execute\nDATA n3.ReturnValue -> n5.Value [Widget]\nEXEC n2.Exit -> n6.Execute\nEXEC n7.Then -> n2.Close\nEXEC n7.Then -> n9.Execute\nDATA n8.Value -> n9.Target [Widget]", "source": "lesson:correction_v4a:C4A_11", "category": "gate_overlap_widget"}
{"instruction": "Create a Blueprint that on BeginPlay creates WBP_HUD and stores it. On EndPlay check if widget IsValid. If valid, remove from parent.", "output": "BLUEPRINT: BP_CleanHUD\nPARENT: Actor\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_EndPlay\nNODE n6: VariableGet [VarName=HUD]\nNODE n7: IsValid\nNODE n8: Branch\nNODE n9: RemoveFromParent\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.Input [Object]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nDATA n6.Value -> n9.Target [Widget]", "source": "lesson:correction_v4a:C4A_12", "category": "endplay_widget_cleanup"}
{"instruction": "Create a Blueprint with widget variables ScreenA and ScreenB. On pressing Swap use FlipFlop. A path shows ScreenA and hides ScreenB. B path shows ScreenB and hides ScreenA.", "output": "BLUEPRINT: BP_SwapUI\nPARENT: Actor\nVAR ScreenA: Widget = None\nVAR ScreenB: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Swap\"]\nNODE n2: FlipFlop\nNODE n3: VariableGet [VarName=ScreenA]\nNODE n4: AddToViewport\nNODE n5: VariableGet [VarName=ScreenB]\nNODE n6: RemoveFromParent\nNODE n7: VariableGet [VarName=ScreenB]\nNODE n8: AddToViewport\nNODE n9: VariableGet [VarName=ScreenA]\nNODE n10: RemoveFromParent\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n4.Execute\nDATA n3.Value -> n4.Target [Widget]\nEXEC n4.Then -> n6.Execute\nDATA n5.Value -> n6.Target [Widget]\nEXEC n2.B -> n8.Execute\nDATA n7.Value -> n8.Target [Widget]\nEXEC n8.Then -> n10.Execute\nDATA n9.Value -> n10.Target [Widget]", "source": "lesson:correction_v4a:C4A_13", "category": "flipflop_widget_swap"}
{"instruction": "Create a Blueprint with float Health at 100 and widget variable HUD. On BeginPlay create WBP_HUD and add to viewport. On AnyDamage subtract from Health. If Health below 0, remove HUD and destroy actor.", "output": "BLUEPRINT: BP_HUDDeath\nPARENT: Actor\nVAR Health: Float = 100.0\nVAR HUD: Widget = None\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CreateWidget [WidgetClass=WBP_HUD]\nNODE n3: AddToViewport\nNODE n4: VariableSet [VarName=HUD]\nNODE n5: Event_AnyDamage\nNODE n6: VariableGet [VarName=Health]\nNODE n7: SubtractFloat\nNODE n8: VariableSet [VarName=Health]\nNODE n9: LessThan [B=0.0]\nNODE n10: Branch\nNODE n11: VariableGet [VarName=HUD]\nNODE n12: RemoveFromParent\nNODE n13: DestroyActor\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Target [Widget]\nEXEC n3.Then -> n4.Execute\nDATA n2.ReturnValue -> n4.Value [Widget]\nEXEC n5.Then -> n8.Execute\nDATA n6.Value -> n7.A [Float]\nDATA n5.Damage -> n7.B [Float]\nDATA n7.ReturnValue -> n8.Value [Float]\nEXEC n8.Then -> n10.Execute\nDATA n8.Value -> n9.A [Float]\nDATA n9.ReturnValue -> n10.Condition [Bool]\nEXEC n10.True -> n12.Execute\nDATA n11.Value -> n12.Target [Widget]\nEXEC n12.Then -> n13.Execute", "source": "lesson:correction_v4a:C4A_14", "category": "hud_damage_death"}
{"instruction": "Create a Blueprint that on BeginPlay starts a looping timer every 2 seconds. The timer event prints Tick.", "output": "BLUEPRINT: BP_TimerPrint\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"OnTimer\", Time=2.0, Looping=true]\nNODE n3: Event_Custom [EventName=OnTimer]\nNODE n4: PrintString [InString=\"Tick\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:correction_v5a:C5A_01", "category": "timer_function_print"}
{"instruction": "Create a Blueprint that on BeginPlay starts a looping timer every 5 seconds called SpawnEnemy. The timer spawns BP_Enemy at actor location.", "output": "BLUEPRINT: BP_TimerSpawn\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"SpawnEnemy\", Time=5.0, Looping=true]\nNODE n3: Event_Custom [EventName=SpawnEnemy]\nNODE n4: GetActorLocation\nNODE n5: SpawnActorFromClass [ActorClass=BP_Enemy]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.SpawnTransform [Transform]", "source": "lesson:correction_v5a:C5A_02", "category": "timer_function_spawn"}
{"instruction": "Create a Blueprint with int Count at 0. On BeginPlay start looping timer every 1 second called Increment. Timer adds 1 to Count and prints the value.", "output": "BLUEPRINT: BP_TimerCount\nPARENT: Actor\nVAR Count: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: SetTimerByFunctionName [FunctionName=\"Increment\", Time=1.0, Looping=true]\nNODE n3: Event_Custom [EventName=Increment]\nNODE n4: VariableGet [VarName=Count]\nNODE n5: AddInt [B=1]\nNODE n6: VariableSet [VarName=Count]\nNODE n7: PrintString\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n6.Execute\nDATA n4.Value -> n5.A [Int]\nDATA n5.ReturnValue -> n6.Value [Int]\nEXEC n6.Then -> n7.Execute\nDATA n6.Value -> n7.InString [String]", "source": "lesson:correction_v5a:C5A_03", "category": "timer_function_counter"}
{"instruction": "Create a Blueprint that on overlap casts to Character. If cast succeeds, check IsValid. If valid, check distance less than 500. If close print Near Player. Else print Far Player. If invalid print Invalid.", "output": "BLUEPRINT: BP_NestedValidCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=500.0]\nNODE n7: Branch\nNODE n8: PrintString [InString=\"Near Player\"]\nNODE n9: PrintString [InString=\"Far Player\"]\nNODE n10: PrintString [InString=\"Invalid\"]\nEXEC n1.Then -> n2.Execute\nDATA n1.OtherActor -> n2.Object [Actor]\nEXEC n2.CastSucceeded -> n4.Execute\nDATA n2.AsCharacter -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.AsCharacter -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nEXEC n7.False -> n9.Execute\nEXEC n4.False -> n10.Execute\nEXEC n2.CastFailed -> n10.Execute", "source": "lesson:correction_v5a:C5A_04", "category": "nested_isvalid_branch"}
{"instruction": "Create a Blueprint with actor variable Target. On pressing Fire check IsValid on Target. If valid, check distance less than 1000. If close, destroy Target and print Destroyed. If far print Too Far. If invalid print No Target.", "output": "BLUEPRINT: BP_ValidFireCheck\nPARENT: Actor\nVAR Target: Actor = None\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: VariableGet [VarName=Target]\nNODE n3: IsValid\nNODE n4: Branch\nNODE n5: GetDistanceTo\nNODE n6: LessThan [B=1000.0]\nNODE n7: Branch\nNODE n8: DestroyActor\nNODE n9: PrintString [InString=\"Destroyed\"]\nNODE n10: PrintString [InString=\"Too Far\"]\nNODE n11: PrintString [InString=\"No Target\"]\nEXEC n1.Pressed -> n4.Execute\nDATA n2.Value -> n3.Input [Object]\nDATA n3.ReturnValue -> n4.Condition [Bool]\nEXEC n4.True -> n7.Execute\nDATA n2.Value -> n5.OtherActor [Actor]\nDATA n5.ReturnValue -> n6.A [Float]\nDATA n6.ReturnValue -> n7.Condition [Bool]\nEXEC n7.True -> n8.Execute\nDATA n2.Value -> n8.Target [Actor]\nEXEC n8.Then -> n9.Execute\nEXEC n7.False -> n10.Execute\nEXEC n4.False -> n11.Execute", "source": "lesson:correction_v5a:C5A_05", "category": "nested_valid_destroy"}
{"instruction": "Create a Blueprint with int ScreenID. On pressing Menu, switch on ScreenID. Case 1 creates WBP_MainMenu and adds to viewport. Case 2 creates WBP_Settings. Case 3 creates WBP_Inventory.", "output": "BLUEPRINT: BP_SwitchUI\nPARENT: Actor\nVAR ScreenID: Int = 1\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Menu\"]\nNODE n2: VariableGet [VarName=ScreenID]\nNODE n3: SwitchOnInt\nNODE n4: CreateWidget [WidgetClass=WBP_MainMenu]\nNODE n5: AddToViewport\nNODE n6: CreateWidget [WidgetClass=WBP_Settings]\nNODE n7: AddToViewport\nNODE n8: CreateWidget [WidgetClass=WBP_Inventory]\nNODE n9: AddToViewport\nEXEC n1.Pressed -> n3.Execute\nDATA n2.Value -> n3.Selection [Int]\nEXEC n3.Case_1 -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n3.Case_2 -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Target [Widget]\nEXEC n3.Case_3 -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Target [Widget]", "source": "lesson:correction_v5a:C5A_06", "category": "switch_create_widget"}
{"instruction": "Create a Blueprint with string Mode. On BeginPlay switch on Mode. If Attack create WBP_Crosshair. If Build create WBP_BuildMenu. If Inventory create WBP_InventoryGrid. Each added to viewport.", "output": "BLUEPRINT: BP_ModeUI\nPARENT: Actor\nVAR Mode: String = \"Attack\"\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Mode]\nNODE n3: SwitchOnString\nNODE n4: CreateWidget [WidgetClass=WBP_Crosshair]\nNODE n5: AddToViewport\nNODE n6: CreateWidget [WidgetClass=WBP_BuildMenu]\nNODE n7: AddToViewport\nNODE n8: CreateWidget [WidgetClass=WBP_InventoryGrid]\nNODE n9: AddToViewport\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Selection [String]\nEXEC n3.Case_Attack -> n4.Execute\nEXEC n4.Then -> n5.Execute\nDATA n4.ReturnValue -> n5.Target [Widget]\nEXEC n3.Case_Build -> n6.Execute\nEXEC n6.Then -> n7.Execute\nDATA n6.ReturnValue -> n7.Target [Widget]\nEXEC n3.Case_Inventory -> n8.Execute\nEXEC n8.Then -> n9.Execute\nDATA n8.ReturnValue -> n9.Target [Widget]", "source": "lesson:correction_v5a:C5A_07", "category": "switch_string_widget"}
{"instruction": "Create a Blueprint that on BeginPlay prints Spawned. On EndPlay prints Destroyed. On Tick prints Alive every frame.", "output": "BLUEPRINT: BP_Lifecycle\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Spawned\"]\nNODE n3: Event_EndPlay\nNODE n4: PrintString [InString=\"Destroyed\"]\nNODE n5: Event_Tick\nNODE n6: PrintString [InString=\"Alive\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:correction_v5a:C5A_08", "category": "lifecycle_full"}
{"instruction": "Create a Blueprint that on BeginPlay prints Started and starts a looping 3 second timer. Timer prints Heartbeat. On EndPlay clears the timer and prints Shutdown.", "output": "BLUEPRINT: BP_LifecycleTimer\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: SetTimerByFunctionName [FunctionName=\"Beat\", Time=3.0, Looping=true]\nNODE n4: Event_Custom [EventName=Beat]\nNODE n5: PrintString [InString=\"Heartbeat\"]\nNODE n6: Event_EndPlay\nNODE n7: ClearTimerByFunctionName [FunctionName=\"Beat\"]\nNODE n8: PrintString [InString=\"Shutdown\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n6.Then -> n7.Execute\nEXEC n7.Then -> n8.Execute", "source": "lesson:correction_v5a:C5A_09", "category": "lifecycle_with_timer"}
{"instruction": "Create a Blueprint that on Tick gets distance to player pawn. If less than 500 print Alert. If less than 200 print Danger. Else print Safe.", "output": "BLUEPRINT: BP_ProximityAlert\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Danger\"]\nNODE n7: LessThan [B=500.0]\nNODE n8: Branch\nNODE n9: PrintString [InString=\"Alert\"]\nNODE n10: PrintString [InString=\"Safe\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n8.Execute\nDATA n3.ReturnValue -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute\nEXEC n8.False -> n10.Execute", "source": "lesson:correction_v5a:C5A_10", "category": "enemy_distance_alert"}
{"instruction": "Create a Blueprint with bool IsChasing. On Tick get distance to player pawn. If less than 800 set IsChasing true and print Chasing. Else set IsChasing false and print Idle.", "output": "BLUEPRINT: BP_ChaseLogic\nPARENT: Actor\nVAR IsChasing: Bool = false\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=800.0]\nNODE n5: Branch\nNODE n6: VariableSet [VarName=IsChasing]\nNODE n7: PrintString [InString=\"Chasing\"]\nNODE n8: VariableSet [VarName=IsChasing]\nNODE n9: PrintString [InString=\"Idle\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nDATA true -> n6.Value [Bool]\nEXEC n6.Then -> n7.Execute\nEXEC n5.False -> n8.Execute\nDATA false -> n8.Value [Bool]\nEXEC n8.Then -> n9.Execute", "source": "lesson:correction_v5a:C5A_11", "category": "enemy_chase_or_idle"}
{"instruction": "Create a Blueprint that prints Hello World when the game starts.", "output": "BLUEPRINT: BP_HelloWorld\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Hello World\"]\n\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_01:L01_01", "category": "print_hello"}
{"instruction": "Create a Blueprint for an actor that continuously rotates at 90 degrees per second on the Yaw axis.", "output": "BLUEPRINT: BP_RotatingActor\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: MakeRotator [X=0, Y=0, Z=90]\nNODE n3: MultiplyFloat\nNODE n4: AddActorLocalRotation\n\nEXEC n1.Then -> n4.Execute\n\nDATA n1.DeltaSeconds -> n3.A [Float]\nDATA n2.ReturnValue -> n3.B [Rotator]\nDATA n3.ReturnValue -> n4.DeltaRotation [Rotator]", "source": "lesson:lesson_01:L01_02", "category": "rotating_actor"}
{"instruction": "Create a Blueprint that prints Entered when another actor overlaps it and prints Exited when the overlap ends.", "output": "BLUEPRINT: BP_OverlapZone\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: PrintString [InString=\"Entered\"]\nNODE n3: Event_ActorEndOverlap\nNODE n4: PrintString [InString=\"Exited\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_03", "category": "overlap_event"}
{"instruction": "Create a Blueprint with a boolean variable IsActive. On BeginPlay, check if IsActive is true. If true, print Active. If false, print Inactive.", "output": "BLUEPRINT: BP_BranchExample\nPARENT: Actor\n\nVAR IsActive: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Branch\nNODE n3: PrintString [InString=\"Active\"]\nNODE n4: PrintString [InString=\"Inactive\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.True -> n3.Execute\nEXEC n2.False -> n4.Execute\n\nDATA n1.IsActive -> n2.Condition [Bool]", "source": "lesson:lesson_01:L01_04", "category": "branch"}
{"instruction": "Create a Blueprint that waits 3 seconds after the game starts, then destroys itself.", "output": "BLUEPRINT: BP_TimedDestroy\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Delay [Duration=3.0]\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_05", "category": "delay"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence node to first print Step 1, then print Step 2, then print Step 3.", "output": "BLUEPRINT: BP_SequenceExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: PrintString [InString=\"Step 2\"]\nNODE n5: PrintString [InString=\"Step 3\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n2.Then_2 -> n5.Execute", "source": "lesson:lesson_01:L01_06", "category": "sequence"}
{"instruction": "Create a Blueprint that toggles an actor's visibility each time the player presses the Interact input action using a FlipFlop node.", "output": "BLUEPRINT: BP_ToggleVisibility\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetActorHiddenInGame [NewHidden=false]\nNODE n4: SetActorHiddenInGame [NewHidden=true]\n\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_01:L01_07", "category": "flipflop"}
{"instruction": "Create a Blueprint that prints Welcome only the first time the player overlaps with the actor using a DoOnce node.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_01:L01_08", "category": "doonce"}
{"instruction": "Create a Blueprint that on overlap, casts the other actor to a Character class. If the cast succeeds, print Player Found.", "output": "BLUEPRINT: BP_CastExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: CastToCharacter\nNODE n3: PrintString [InString=\"Player Found\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.CastSucceeded -> n3.Execute\n\nDATA n1.OtherActor -> n2.Object [Actor]", "source": "lesson:lesson_01:L01_09", "category": "cast"}
{"instruction": "Create a Blueprint with an array of Actors called TargetActors. On BeginPlay, loop through each actor in the array and destroy it.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\n\nVAR TargetActors: Array = None\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: ForEachLoop\nNODE n3: DestroyActor\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.LoopBody -> n3.Execute\n\nDATA n1.TargetActors -> n2.Array [Array]\nDATA n2.ArrayElement -> n3.Target [Actor]", "source": "lesson:lesson_01:L01_10", "category": "foreach"}
{"instruction": "Create a Blueprint with a Gate node. On BeginPlay, open the gate. On Tick, pass through the gate and print Ticking. On pressing the Close input action, close the gate.", "output": "BLUEPRINT: BP_GateExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: Event_Tick\nNODE n4: PrintString [InString=\"Ticking\"]\nNODE n5: Event_InputAction [ActionName=\"Close\"]\n\nEXEC n1.Then -> n2.Open\nEXEC n3.Then -> n2.Enter\nEXEC n2.Exit -> n4.Execute\nEXEC n5.Pressed -> n2.Close", "source": "lesson:lesson_01:L01_11", "category": "gate"}
{"instruction": "Create a Blueprint with a custom event called OnActivate. On BeginPlay, call the custom event. The custom event prints Activated when called.", "output": "BLUEPRINT: BP_CustomEventExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=\"OnActivate\"]\nNODE n3: Event_CustomEvent [EventName=\"OnActivate\"]\nNODE n4: PrintString [InString=\"Activated\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_01:L01_12", "category": "custom_event"}
{"instruction": "Create a Blueprint with an integer variable Score starting at 0. On overlap, add 10 to the score and print the new score.", "output": "BLUEPRINT: BP_ScoreCounter\nPARENT: Actor\n\nVAR Score: Int = 0\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetVariable [VarName=\"Score\"]\nNODE n3: AddInt\nNODE n4: SetVariable [VarName=\"Score\"]\nNODE n5: PrintString\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.Then -> n5.Execute\n\nDATA n2.Value -> n3.A [Int]\nDATA n3.ReturnValue -> n4.Value [Int]\nDATA n4.Value -> n5.InString [String]", "source": "lesson:lesson_01:L01_13", "category": "variable_set_get"}
{"instruction": "Create a Blueprint that spawns a projectile actor at the player's location when the Fire input action is pressed.", "output": "BLUEPRINT: BP_ProjectileSpawner\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: GetActorRotation\nNODE n4: SpawnActor [ActorClass=\"BP_Projectile\"]\n\nEXEC n1.Pressed -> n4.Execute\n\nDATA n2.ReturnValue -> n4.SpawnLocation [Vector]\nDATA n3.ReturnValue -> n4.SpawnRotation [Rotator]", "source": "lesson:lesson_01:L01_14", "category": "spawn_actor"}
{"instruction": "Create a Blueprint that plays a sound effect when the actor is overlapped by another actor.", "output": "BLUEPRINT: BP_SoundOnOverlap\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetActorLocation\nNODE n3: PlaySound [Sound=\"OverlapSound\"]\n\nEXEC n1.Then -> n3.Execute\n\nDATA n2.ReturnValue -> n3.Location [Vector]", "source": "lesson:lesson_01:L01_15", "category": "play_sound"}
{"instruction": "Create a Blueprint that on Tick, gets the distance to another actor stored in a variable called TargetActor. If the distance is less than 500, print Close.", "output": "BLUEPRINT: BP_DistanceChecker\nPARENT: Actor\n\nVAR TargetActor: Actor = None\n\nGRAPH: EventGraph\n\nNODE n1: Event_Tick\nNODE n2: GetDistanceTo\nNODE n3: LessThanFloat\nNODE n4: Branch\nNODE n5: PrintString [InString=\"Close\"]\n\nEXEC n1.Then -> n4.Execute\nEXEC n4.True -> n5.Execute\n\nDATA n1.TargetActor -> n2.OtherActor [Actor]\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.Condition [Bool]", "source": "lesson:lesson_01:L01_16", "category": "distance_check"}
{"instruction": "Create a Blueprint that prints Started on BeginPlay, prints Tick Count each frame using Event Tick, and prints Goodbye before the actor is destroyed using Event EndPlay.", "output": "BLUEPRINT: BP_LifecycleEvents\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_Tick\nNODE n4: PrintString [InString=\"Tick Count\"]\nNODE n5: Event_EndPlay\nNODE n6: PrintString [InString=\"Goodbye\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_01:L01_17", "category": "multi_event"}
{"instruction": "Create a Blueprint with a boolean variable IsVisible starting as true. On pressing Toggle input, flip IsVisible and call SetActorHiddenInGame with the new value.", "output": "BLUEPRINT: BP_VisibilityToggle\nPARENT: Actor\n\nVAR IsVisible: Bool = true\n\nGRAPH: EventGraph\n\nNODE n1: Event_InputAction [ActionName=\"Toggle\"]\nNODE n2: GetVariable [VarName=\"IsVisible\"]\nNODE n3: NotBool\nNODE n4: SetVariable [VarName=\"IsVisible\"]\nNODE n5: SetActorHiddenInGame\n\nEXEC n1.Pressed -> n4.Execute\nEXEC n4.Then -> n5.Execute\n\nDATA n2.Value -> n3.Input [Bool]\nDATA n3.ReturnValue -> n4.Value [Bool]\nDATA n3.ReturnValue -> n5.NewHidden [Bool]", "source": "lesson:lesson_01:L01_18", "category": "set_visibility"}
{"instruction": "Create a Blueprint that on BeginPlay calculates the result of (5 + 3) multiplied by 2 and prints the result.", "output": "BLUEPRINT: BP_MathExample\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: AddFloat [A=5.0, B=3.0]\nNODE n3: MultiplyFloat [B=2.0]\nNODE n4: PrintString\n\nEXEC n1.Then -> n4.Execute\n\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_01:L01_19", "category": "math_chain"}
{"instruction": "Create a Blueprint that on BeginPlay prints Ready, waits 2 seconds, prints Set, waits 1 second, then prints Go.", "output": "BLUEPRINT: BP_Countdown\nPARENT: Actor\n\nGRAPH: EventGraph\n\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Delay [Duration=2.0]\nNODE n4: PrintString [InString=\"Set\"]\nNODE n5: Delay [Duration=1.0]\nNODE n6: PrintString [InString=\"Go\"]\n\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then -> n3.Execute\nEXEC n3.Completed -> n4.Execute\nEXEC n4.Then -> n5.Execute\nEXEC n5.Completed -> n6.Execute", "source": "lesson:lesson_01:L01_20", "category": "delay_chain"}
{"instruction": "Create a Blueprint with a boolean variable IsActive. On BeginPlay, use a Branch node to check IsActive. If true, print Active. If false, print Inactive.", "output": "BLUEPRINT: BP_BranchCheck\nPARENT: Actor\nVAR IsActive: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=IsActive]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Active\"]\nNODE n5: PrintString [InString=\"Inactive\"]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_02:L02_01", "category": "branch"}
{"instruction": "Create a Blueprint that on overlap checks if the overlapping actor has the tag Enemy. If yes, print Danger. If no, print Safe.", "output": "BLUEPRINT: BP_TagBranch\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: ActorHasTag [Tag=\"Enemy\"]\nNODE n3: Branch\nNODE n4: PrintString [InString=\"Danger\"]\nNODE n5: PrintString [InString=\"Safe\"]\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.Condition [Bool]\nEXEC n3.True -> n4.Execute\nEXEC n3.False -> n5.Execute", "source": "lesson:lesson_02:L02_02", "category": "branch"}
{"instruction": "Create a Blueprint with an integer variable Score set to 0. On BeginPlay, set Score to 100 then print the value of Score.", "output": "BLUEPRINT: BP_SetScore\nPARENT: Actor\nVAR Score: Int = 0\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=Score]\nNODE n3: VariableGet [VarName=Score]\nNODE n4: PrintString\nEXEC n1.Then -> n2.Execute\nDATA 100 -> n2.Value [Int]\nEXEC n2.Then -> n4.Execute\nDATA n3.Value -> n4.InString [String]", "source": "lesson:lesson_02:L02_03", "category": "variable_set_get"}
{"instruction": "Create a Blueprint with a float variable Health starting at 100.0. On Event AnyDamage, subtract the damage amount from Health and set the new value.", "output": "BLUEPRINT: BP_HealthTracker\nPARENT: Actor\nVAR Health: Float = 100.0\nGRAPH: EventGraph\nNODE n1: Event_AnyDamage\nNODE n2: VariableGet [VarName=Health]\nNODE n3: Subtract\nNODE n4: VariableSet [VarName=Health]\nEXEC n1.Then -> n4.Execute\nDATA n2.Value -> n3.A [Float]\nDATA n1.Damage -> n3.B [Float]\nDATA n3.ReturnValue -> n4.Value [Float]", "source": "lesson:lesson_02:L02_04", "category": "variable_set_get"}
{"instruction": "Create a Blueprint with a custom event called OnActivate. On BeginPlay, call the custom event OnActivate. The OnActivate event prints Activated.", "output": "BLUEPRINT: BP_CustomActivate\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: CallEvent [EventName=OnActivate]\nNODE n3: Event_Custom [EventName=OnActivate]\nNODE n4: PrintString [InString=\"Activated\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_05", "category": "custom_event"}
{"instruction": "Create a Blueprint with a custom event TakeDamage that takes a float input Amount. When TakeDamage is called, print the Amount value.", "output": "BLUEPRINT: BP_CustomDamage\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Custom [EventName=TakeDamage]\nNODE n2: PrintString\nEXEC n1.Then -> n2.Execute\nDATA n1.Amount -> n2.InString [String]", "source": "lesson:lesson_02:L02_06", "category": "custom_event"}
{"instruction": "Create a Blueprint with a Gate node. On BeginPlay, open the gate. When the player presses the Fire input action, the gate filters execution to print Firing.", "output": "BLUEPRINT: BP_GateExample\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Gate\nNODE n3: Event_InputAction [ActionName=\"Fire\"]\nNODE n4: PrintString [InString=\"Firing\"]\nEXEC n1.Then -> n2.Open\nEXEC n3.Pressed -> n2.Enter\nEXEC n2.Exit -> n4.Execute", "source": "lesson:lesson_02:L02_07", "category": "gate"}
{"instruction": "Create a Blueprint where pressing Interact opens a gate and pressing Fire enters the gate to toggle visibility.", "output": "BLUEPRINT: BP_GateToggle\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: Gate\nNODE n3: Event_InputAction [ActionName=\"Fire\"]\nNODE n4: ToggleVisibility\nEXEC n1.Pressed -> n2.Open\nEXEC n3.Pressed -> n2.Enter\nEXEC n2.Exit -> n4.Execute", "source": "lesson:lesson_02:L02_08", "category": "gate"}
{"instruction": "Create a Blueprint that spawns a projectile actor at the player's location when the Fire input is pressed.", "output": "BLUEPRINT: BP_SpawnProjectile\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Fire\"]\nNODE n2: GetActorLocation\nNODE n3: SpawnActorFromClass [ActorClass=BP_Projectile]\nEXEC n1.Pressed -> n3.Execute\nDATA n2.ReturnValue -> n3.SpawnTransform [Transform]", "source": "lesson:lesson_02:L02_09", "category": "spawn_actor"}
{"instruction": "Create a Blueprint that on BeginPlay spawns 3 enemy actors using a ForEachLoop over an array.", "output": "BLUEPRINT: BP_SpawnEnemies\nPARENT: Actor\nVAR SpawnPoints: Array<Vector>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=SpawnPoints]\nNODE n3: ForEachLoop\nNODE n4: SpawnActorFromClass [ActorClass=BP_Enemy]\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.SpawnTransform [Transform]", "source": "lesson:lesson_02:L02_10", "category": "spawn_actor"}
{"instruction": "Create a Blueprint with an array of Actors called Targets. On BeginPlay, use a ForEachLoop to iterate through Targets and call DestroyActor on each one.", "output": "BLUEPRINT: BP_DestroyAll\nPARENT: Actor\nVAR Targets: Array<Actor>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Targets]\nNODE n3: ForEachLoop\nNODE n4: DestroyActor\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.Target [Actor]", "source": "lesson:lesson_02:L02_11", "category": "foreach"}
{"instruction": "Create a Blueprint that on BeginPlay loops through an array of strings called Messages and prints each one.", "output": "BLUEPRINT: BP_PrintAll\nPARENT: Actor\nVAR Messages: Array<String>\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableGet [VarName=Messages]\nNODE n3: ForEachLoop\nNODE n4: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n2.Value -> n3.Array [Array]\nEXEC n3.LoopBody -> n4.Execute\nDATA n3.ArrayElement -> n4.InString [String]", "source": "lesson:lesson_02:L02_12", "category": "foreach"}
{"instruction": "Create a Blueprint that on Tick gets the distance to the player. If the distance is less than 500, print Close.", "output": "BLUEPRINT: BP_DistanceCheck\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=500.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Close\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute", "source": "lesson:lesson_02:L02_13", "category": "distance_check"}
{"instruction": "Create a Blueprint that on Tick checks distance to the player. If less than 200, print Near. If more than 1000, print Far.", "output": "BLUEPRINT: BP_NearFar\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: GetPlayerPawn\nNODE n3: GetDistanceTo\nNODE n4: LessThan [B=200.0]\nNODE n5: Branch\nNODE n6: PrintString [InString=\"Near\"]\nNODE n7: GreaterThan [B=1000.0]\nNODE n8: Branch\nNODE n9: PrintString [InString=\"Far\"]\nEXEC n1.Then -> n5.Execute\nDATA n2.ReturnValue -> n3.OtherActor [Actor]\nDATA n3.ReturnValue -> n4.A [Float]\nDATA n4.ReturnValue -> n5.Condition [Bool]\nEXEC n5.True -> n6.Execute\nEXEC n5.False -> n8.Execute\nDATA n3.ReturnValue -> n7.A [Float]\nDATA n7.ReturnValue -> n8.Condition [Bool]\nEXEC n8.True -> n9.Execute", "source": "lesson:lesson_02:L02_14", "category": "distance_check"}
{"instruction": "Create a Blueprint with a boolean variable IsVisible starting at true. On BeginPlay, set IsVisible to false and call SetVisibility with NewVisibility set to false.", "output": "BLUEPRINT: BP_HideOnStart\nPARENT: Actor\nVAR IsVisible: Bool = true\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: VariableSet [VarName=IsVisible]\nNODE n3: SetVisibility [NewVisibility=false]\nEXEC n1.Then -> n2.Execute\nDATA false -> n2.Value [Bool]\nEXEC n2.Then -> n3.Execute", "source": "lesson:lesson_02:L02_15", "category": "set_visibility"}
{"instruction": "Create a Blueprint that toggles visibility each time the player presses Interact. Use a FlipFlop and SetVisibility nodes.", "output": "BLUEPRINT: BP_ToggleVis\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_InputAction [ActionName=\"Interact\"]\nNODE n2: FlipFlop\nNODE n3: SetVisibility [NewVisibility=true]\nNODE n4: SetVisibility [NewVisibility=false]\nEXEC n1.Pressed -> n2.Execute\nEXEC n2.A -> n3.Execute\nEXEC n2.B -> n4.Execute", "source": "lesson:lesson_02:L02_16", "category": "set_visibility"}
{"instruction": "Create a Blueprint that on BeginPlay uses a Sequence node to first print Step 1, then print Step 2, then print Step 3.", "output": "BLUEPRINT: BP_SequenceSteps\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Sequence\nNODE n3: PrintString [InString=\"Step 1\"]\nNODE n4: PrintString [InString=\"Step 2\"]\nNODE n5: PrintString [InString=\"Step 3\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Then_0 -> n3.Execute\nEXEC n2.Then_1 -> n4.Execute\nEXEC n2.Then_2 -> n5.Execute", "source": "lesson:lesson_02:L02_17", "category": "sequence"}
{"instruction": "Create a Blueprint that on Tick adds a rotation of 1.0 on the Yaw axis to make the actor spin continuously.", "output": "BLUEPRINT: BP_Spinner\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_Tick\nNODE n2: AddActorLocalRotation [DeltaRotation=(Pitch=0.0,Yaw=1.0,Roll=0.0)]\nEXEC n1.Then -> n2.Execute", "source": "lesson:lesson_02:L02_18", "category": "rotating_actor"}
{"instruction": "Create a Blueprint that when another actor overlaps, prints the name of the overlapping actor using GetDisplayName.", "output": "BLUEPRINT: BP_PrintOverlapper\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: GetDisplayName\nNODE n3: PrintString\nEXEC n1.Then -> n3.Execute\nDATA n1.OtherActor -> n2.Target [Actor]\nDATA n2.ReturnValue -> n3.InString [String]", "source": "lesson:lesson_02:L02_19", "category": "overlap_event"}
{"instruction": "Create a Blueprint that plays a sound at the actor's location when BeginPlay fires. Use PlaySoundAtLocation.", "output": "BLUEPRINT: BP_PlayStartSound\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: GetActorLocation\nNODE n3: PlaySoundAtLocation [Sound=StartSound]\nEXEC n1.Then -> n3.Execute\nDATA n2.ReturnValue -> n3.Location [Vector]", "source": "lesson:lesson_02:L02_20", "category": "play_sound"}
{"instruction": "Create a Blueprint that prints Welcome only the first time the player overlaps, using a DoOnce node.", "output": "BLUEPRINT: BP_WelcomeOnce\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_ActorBeginOverlap\nNODE n2: DoOnce\nNODE n3: PrintString [InString=\"Welcome\"]\nEXEC n1.Then -> n2.Execute\nEXEC n2.Completed -> n3.Execute", "source": "lesson:lesson_02:L02_21", "category": "doonce"}
{"instruction": "Create a Blueprint that on BeginPlay multiplies 5 times 10, adds 25, and prints the result.", "output": "BLUEPRINT: BP_MathChain\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: Multiply [A=5, B=10]\nNODE n3: Add [A=0, B=25]\nNODE n4: PrintString\nEXEC n1.Then -> n4.Execute\nDATA n2.ReturnValue -> n3.A [Float]\nDATA n3.ReturnValue -> n4.InString [String]", "source": "lesson:lesson_02:L02_22", "category": "math_chain"}
{"instruction": "Create a Blueprint that prints Started on BeginPlay and prints Ended on EndPlay.", "output": "BLUEPRINT: BP_StartEnd\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Started\"]\nNODE n3: Event_EndPlay\nNODE n4: PrintString [InString=\"Ended\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Then -> n4.Execute", "source": "lesson:lesson_02:L02_23", "category": "multi_event"}
{"instruction": "Create a Blueprint with three events: BeginPlay prints Ready, pressing Jump prints Jumped, and on overlap prints Touched.", "output": "BLUEPRINT: BP_ThreeEvents\nPARENT: Actor\nGRAPH: EventGraph\nNODE n1: Event_BeginPlay\nNODE n2: PrintString [InString=\"Ready\"]\nNODE n3: Event_InputAction [ActionName=\"Jump\"]\nNODE n4: PrintString [InString=\"Jumped\"]\nNODE n5: Event_ActorBeginOverlap\nNODE n6: PrintString [InString=\"Touched\"]\nEXEC n1.Then -> n2.Execute\nEXEC n3.Pressed -> n4.Execute\nEXEC n5.Then -> n6.Execute", "source": "lesson:lesson_02:L02_24", "category": "multi_event"}
